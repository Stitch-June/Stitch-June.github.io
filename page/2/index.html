<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Stitch&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Stitch&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Stitch&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Stitch&#039;s Blog"><meta property="og:url" content="https://stitch.cn/"><meta property="og:site_name" content="Stitch&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://stitch.cn/img/og_image.png"><meta property="article:author" content="stitch"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://stitch.cn"},"headline":"Stitch's Blog","image":["https://stitch.cn/img/og_image.png"],"author":{"@type":"Person","name":"stitch"},"publisher":{"@type":"Organization","name":"Stitch's Blog","logo":{"@type":"ImageObject","url":{"text":"Stitch's Blog"}}},"description":""}</script><link rel="alternate" href="/atom.xml" title="Stitch&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Stitch&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-05T15:05:29.000Z" title="6/5/2020, 3:05:29 PM">2020-06-05</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Redis/">Redis</a></span><span class="level-item">20 分钟读完 (大约2953个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/05/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html">redis之主从问题处理</a></h1><div class="content"><h2 id="主从复制的常用相关配置"><a href="#主从复制的常用相关配置" class="headerlink" title="主从复制的常用相关配置"></a>主从复制的常用相关配置</h2><ul>
<li><p>Slaveof</p>
<p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
<p><strong>slave</strong>实例需要配置该项，指向<strong>master</strong>的(ip,port)</p>
</li>
<li><p>masterauth</p>
<p><code>masterauth &lt;master-password&gt;</code></p>
<p>如果<strong>master</strong>实例启用了密码保护，则该配置项需要填<strong>master</strong>的启动密码；</p>
<p>如果未启用，需要将该配置项注视掉。</p>
</li>
<li><p>slave-serve-stale-data</p>
<p>指定<strong>slave</strong>与<strong>master</strong>连接中断时的动作。默认为<strong>yes</strong>，表明<strong>slave</strong>会继续应答来自<strong>client</strong>的请求，但这些数据可能已经过期（因为连接中断导致无法从<strong>master</strong>同步）。若配置为<strong>no</strong>，则<strong>slave</strong>除正常应答“<strong>INFO</strong>”和“<strong>SLAVEOF</strong>”命令外，其余来自客户端的请求命令均会得到“<strong>SYNC with master in progress</strong>“的应答，直到该<strong>slave</strong>与<strong>master</strong>连接重建成功或该<strong>slave</strong>被提升为<strong>master</strong>。</p>
</li>
<li><p>slave-read-only</p>
<p>指定<strong>slave</strong>是否只读，默认为<strong>yes</strong>。若配置为<strong>no</strong>，表示<strong>slave</strong>是可写的，但写的内容在主从同步完成后会被删除掉。</p>
</li>
<li><p>repl-disable-tcp-nodelay</p>
<p>指定向<strong>slave</strong>同步数据时，是否禁用<strong>socket</strong>的<strong>NO_DELAY</strong>选项。若配置为<strong>yes</strong>，则禁用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈会合并小包统一发送，这样可以减少主从节点间的包数量并节省宽带，但会增加数据同步到<strong>slave</strong>的时间。若配置为<strong>no</strong>，表明启用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈不会延迟小包的发送时间，这样数据同步的延时会减少，但需要更大的宽带。</p>
</li>
<li><p>slave-priority</p>
<p>指定<strong>slave</strong>的优先级。在不只1个<strong>slave</strong>存在的部署环境下，当<strong>master</strong>宕机时，<strong>Redis Sentinel</strong> 会将<strong>priority</strong>值最小的<strong>slave</strong>提升为<strong>master</strong>。需要注意的是，若该配置项为0，则对应的<strong>slave</strong>永远不会被<strong>Redis Sentinel</strong> 自动提升为<strong>master</strong>。</p>
</li>
</ul>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="复制数据延迟"><a href="#复制数据延迟" class="headerlink" title="复制数据延迟"></a>复制数据延迟</h3><p><strong>Redis</strong>复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络宽带和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或通知客户端避免读取延迟过高的从节点。</p>
<p>具体实现逻辑：</p>
<ul>
<li>监控程序定期检查主从节点的偏移量，主节点偏移量在<code>info replication</code>的<code>master_repl_offset</code>指标记录，从节点偏移量可以查询主节点的<code>slave0</code>字段的<code>offset</code>指标，它们的差值就是主从节点延迟的字节量。</li>
<li>对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点，同时从节点的<code>slave-serve-stable-data</code>参数也与此有关，它控制这种情况下从节点的表现，当从库同主机失去连接或者复制正在进行，从机库有两种运行方式。</li>
</ul>
<h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>当主节点存储大量设置超时的数据时，redis内部需要维护过期数据删除策略，删除策略主要有两种：</p>
<ul>
<li><p>惰性删除</p>
<p>主节点每次处理读取命令时，都会检查健是否超时，如果超时则执行·<code>del</code>命令删除键对象，之后<code>del</code>命令也会异步发给从节点。因为保持复制的一致性，从节点自身永远不会主动删除超时数据。</p>
</li>
<li><p>定时删除</p>
<p><strong>Redis</strong>主节点在内部定时任务会循环采样一定数据量的键，当发现采用的键过期时会执行<code>del</code>命令，之后再同步给从节点。</p>
</li>
</ul>
<h3 id="从节点故障问题"><a href="#从节点故障问题" class="headerlink" title="从节点故障问题"></a>从节点故障问题</h3><p>对于从节点的故障问题，需要在客户端维护一个可用从节点可用列表，当从节点故障时，立刻切换到其他从节点或主节点，<strong>redis Cluster</strong>可以解决这个问题。</p>
<h2 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h2><p>主节点和从节点不同，经常导致主节点和从节点的配置不同，并带来问题。</p>
<p>主从配置不一致是一个容易忽视的问题。对于有些配置主从之间是可以不一致，比如：主节点关闭AOF，从节点开启AOF。但对于内存相关的配置必须要一致，比如<code>maxmemory</code>,<code>hash-max-ziplist-entries</code>等参数。</p>
<p>数据丢失：主机和从机有时候发生配置不一致的情况，例如<code>maxmemory</code>不一致。假如主机配置<code>maxmemory</code>为8G，从机设置为4G，这个时候是可以用的，而且不会报错。但如果要做高可用，让从节点变成主节点的时候，就会发现数据已经丢失，而且无法挽回。</p>
<h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><p>全量复制指的是当<strong>slave</strong>断开并重启后，<strong>runid</strong>产生变化而导致需要在<strong>master</strong>主机里拷贝全部数据。这种拷贝全部数据的过程非常耗资源。</p>
<p>全量复制是不可避免的，例如第一次的全量复制就不可避免，这时我们需要选择小主节点，且<code>maxmemory</code>值不要过大，这样就会比较快。同时选择在低峰值的时候做全量复制。</p>
<p>造成全量复制的原因：</p>
<ul>
<li>主从机的运行<strong>runid</strong>不匹配。解释一下，主节点如果重启，<strong>runid</strong>将会发生变化。如果从节点监控到<strong>runid</strong>不是同一个，它就会认为你的节点不安全。当发生故障转移的时候，如果主节点发生故障，那么从节点就会变成主节点（哨兵和集群）。</li>
<li>复制缓冲区空间不足，比如默认值为1M，可以部分复制，但如果缓冲区不够大的话，首先需要网络中断，部分复制将无法满足。其次需要增大复制缓冲区配置<code>repl-backlog-size</code>，对网络的缓冲增强。</li>
</ul>
<p>怎么解决：</p>
<ul>
<li>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得<strong>runid</strong>发生变化，可能导致不必要的全量复制。</li>
<li>为了解决这个问题，<strong>Redis</strong>提供了<strong>debug reload</strong>的重启方式：重启后，主节点的<strong>runid</strong>和<strong>offset</strong>都不受影响，避免了全量复制。</li>
</ul>
<h2 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h2><p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成大量开销，导致 CPU、内存、带宽消耗。因此我们应该分析出复制风暴发生的场景，提前采用合理的方式规避。规避方式有如下几个。</p>
<h3 id="单节点复制风暴"><a href="#单节点复制风暴" class="headerlink" title="单节点复制风暴"></a>单节点复制风暴</h3><p>当一个主机下面挂了很多个 <strong>slave</strong>从机的时候，主机 <strong>master</strong> 挂了，这时 <strong>master</strong> 主机重启后，因为 <strong>runid</strong> 发生了变化，所有的 <strong>slave</strong> 从机都要做一次全量复制。这将引起单节点和单机器的复制风暴，开销会非常大。</p>
<p>解决：</p>
<ul>
<li>可以采用树状结构降低多个从节点对主节点的消耗。</li>
<li>从节点采用树状树非常有用，网络开销交给位于中间层的从节点，而不必消耗顶层的主节点。但是这种树状结构也带来了运维的复杂性，增加了手动和自动 处理故障转移的难度。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA2LzA1LzI2ZGMzOWNiOWRmZTUucG5n?x-oss-process=image/format,png"></p>
<h3 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h3><p>由于 <strong>Redis</strong> 的单线程架构，通常单台机器会部署多个 <strong>Redis</strong> 实例。当一台机器（<strong>machine</strong>）上同时部署多个主节点（<strong>master</strong>）时，如果每个 <strong>master</strong> 主机只有一台 <strong>slave</strong> 从机，那么当机器宕机以后，会产生大量全量复制。这种情况是非常危险的情况，带宽马上会被占用，会导致不可用。</p>
<p>解决：</p>
<ul>
<li>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。 </li>
<li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA2LzA1LzQ5NzJkZmFkN2EyNTEucG5n?x-oss-process=image/format,png"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>###########从库############## </p>
<p>#设置该数据库为其他数据库的从数据库 </p>
<p><code>slaveof &lt;masterip&gt; &lt;masterport&gt; </code></p>
<p>#主从复制中，设置连接<strong>master</strong>服务器的密码（前提<strong>master</strong>启用了认证） </p>
<p><code>masterauth &lt;master-password&gt; </code></p>
<p># 当从库同主库失去连接或者复制正在进行，从库有两种运行方式： </p>
<p># 1) 如果<code>slave-serve-stale-data</code>设置为<strong>yes</strong>(默认设置)，从库会继续相应客户端的请求 </p>
<p># 2) 如果<code>slave-serve-stale-data</code>设置为<strong>no</strong>，除了<strong>INFO</strong>和<strong>SLAVOF</strong>命令之外的任何请求都会返回一个错误”<strong>SYNC with master in progress</strong>“ </p>
<p><code>slave-serve-stale-data yes </code></p>
<p>#当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高 </p>
<p><code>slave-priority 100</code></p>
<p>#从节点是否只读；默认<strong>yes</strong>只读，为了保持数据一致性，应保持默认。</p>
<p><code>slave-read-only yes</code></p>
<p>########主库配置############## </p>
<p>#在<strong>slave</strong>和<strong>master</strong>同步后（发送<strong>psync</strong>/<strong>sync</strong>），后续的同步是否设置成<strong>TCP_NODELAY</strong>假如设置成<strong>yes</strong>，则<strong>redis</strong>会合并小的<strong>TCP</strong>包从而节省带宽，但会增加同步延迟（40ms），造成<strong>master</strong>与<strong>slave</strong>数据不一致假如设置成<strong>no</strong>，则<strong>redis master</strong>会立即发送同步数据，没有延迟。</p>
<p>#前者关注性能，后者关注一致性 </p>
<p><code>repl-disable-tcp-nodelay no </code></p>
<p>#从库会按照一个时间间隔向主库发送<strong>PING</strong>命令来判断主服务器是否在线，默认是10秒 </p>
<p><code>repl-ping-slave-period 10</code> </p>
<p>#复制积压缓冲区大小设置 </p>
<p><code>repl-backlog-size 1mb</code> </p>
<p>#<strong>master</strong>没有<strong>slave</strong>一段时间会释放复制缓冲区的内存，<code>repl-backlog-ttl</code>用来设置该时间长度。单位为秒。 </p>
<p><code>repl-backlog-ttl 3600</code></p>
<p>#<strong>redis</strong>提供了可以让<strong>master</strong>停止写入的方式，如果配置了<code>min-slaves-to-write</code>，健康的<strong>slave</strong>的个数小于<strong>N</strong>，<strong>mater</strong>就禁止写入。<strong>master</strong>最少得有多少个健康的<strong>slave</strong>存活才能执行写命令。这个配置虽然不能保证<strong>N</strong>个<strong>slave</strong>都一定能接收到<strong>master</strong>的写操作，但是能避免没有足够健康的slave的时候，<strong>master</strong>不能写入来避免数据丢失。设置为0是关闭该功能。 </p>
<p><code>min-slaves-to-write 3</code></p>
<p><code>min-slaves-max-lag 10</code> </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-04T00:15:22.000Z" title="6/4/2020, 12:15:22 AM">2020-06-04</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">28 分钟读完 (大约4167个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/04/redis%E4%B8%BB%E4%BB%8E%E4%B9%8B%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6.html">redis主从之全量复制及增量复制</a></h1><div class="content"><h2 id="主从注意事项"><a href="#主从注意事项" class="headerlink" title="主从注意事项"></a>主从注意事项</h2><p>对于主从复制的好处，在上篇文章我也写了，下面说一下注意事项。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>安全</p>
<p>对于数据比较重要的节点，主节点会通过设置<code>requirepass</code>参数进行密码验证，这时候所有的客户端访问必须使用<code>auth</code>命令进行验证。从节点与主节点的复制链接是通过一个特殊标识的客户端来完成。因此需要配置从节点的<code>masterauth</code>参数与主节点密码保持一致，这样从节点才可以正确地链接到主节点并发起复制流程。</p>
</li>
<li><p>从节点只读</p>
<p>默认情况下<code>slave-read-only=yes</code>配置为只读，由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此没必要就不要动这个配置。</p>
</li>
<li><p>网络延迟问题</p>
<p>主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题，redis为我们提供了<code>repl-disable-tcp-nodelay</code>参数用于控制是否关闭 tcp nodelay，默认是关闭的，说明如下：</p>
<blockquote>
<p>当<strong>关闭</strong>时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟将会变小，但增加了网络宽带的消耗。适用于主从之间的网络环境较好的场景。</p>
<p>当<strong>开启</strong>时，主节点会合并较小的TCP数据包从而节省宽带。默认发送时间间隔取决于Linux的内核，一般默认为40ms。这种配置节省了宽带但增大主从之间的延迟。适用于主从网络环境复杂或宽带紧张的场景。</p>
</blockquote>
</li>
</ul>
<p>部署主从节点时需要考虑网络延迟、宽带使用率、防灾级别等因素，如要求低延迟时，建议同机房部署并关闭<code>repl-disable-tcp-nodelay</code>，如考虑容灾性，可以跨机房部署并开启<code>repl-disable-tcp-nodelay</code>。</p>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; C[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; D[Redis-slave]</span><br></pre></td></tr></table></figure>

<h3 id="树状主从"><a href="#树状主从" class="headerlink" title="树状主从"></a>树状主从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; C[Redis-slave]</span><br><span class="line">B[Redis-slave] --&gt; D[Redis-slave]</span><br><span class="line">B[Redis-slave] --&gt; E[Redis-slave]</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[slaveof] --&gt;|127.0.0.1:6379| B[slave]</span><br><span class="line">B[slave] --&gt; D[保存主节点信息]</span><br><span class="line">D[保存主节点信息] --&gt; E[主从建立socket连接]</span><br><span class="line">E[主从建立socket连接] --&gt; F[发送ping命令]</span><br><span class="line">F[发送ping命令] --&gt; G[权限验证]</span><br><span class="line">G[权限验证] --&gt; H[同步数据集]</span><br><span class="line">H[同步数据集] --&gt; I[命令持续复制]</span><br><span class="line">I[命令持续复制] --&gt; J[master]</span><br></pre></td></tr></table></figure>

<p>从上图可以看出来大致分为6个过程：</p>
<ul>
<li>执行slaveof后从节点保存主节点的地址信息便返回，这时候复制流程还没开始。</li>
<li>从节点内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接，从节点会建立一个socket套接字。</li>
<li>发送ping命令，检测主从之间网络套接字是否可用，检测主节点是否可用接受处理命令。如果发送 ping 命令后，从节点没有收到主节点的 pong 回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连。</li>
<li>如果主节点配置了<code>requirepass</code>参数，则需要密码认证，从节点必须配置<code>masterauth</code>参数保证与主节点相同的密码才能通过验证。</li>
<li>主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。 </li>
<li>当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。 </li>
</ul>
<blockquote>
<p>主从同步的过程中，从节点会把原来的数据清空。</p>
</blockquote>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>同步方式：</p>
<ul>
<li><p>全量复制</p>
<p>用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点。当数据量过大的时候，会造成很大的网络开销。</p>
</li>
<li><p>部分复制</p>
<p>用于处理在主从复制中因网络闪退等原因造成数据丢失场景，当从节点再次连上主节点，如果条件允许，主节点会补发丢失数据给从节点，因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。但需要注意，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制 。</p>
</li>
</ul>
<p>复制偏移量：</p>
<ul>
<li><p>参与复制的主从节点都会维护自身复制偏移量，主节点在处理完写入命令操作后，会把命令的字节长度做累加记录，统计信息在<code>info replication</code>中的<code>master_repl_offset</code>指标中。</p>
</li>
<li><p>从节点每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量<code>slave0:ip=192.168.1.3,port=6379,state=online,offset=116424,lag=0</code></p>
</li>
<li><p>从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在<code>info replication</code>中的<code>slave_repl_offset</code>中。</p>
</li>
</ul>
<p>复制积压缓冲区：</p>
<ul>
<li>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点时被创建，这时主节点响应写命令时，不但会把命令发给从节点，还会写入复制积压缓冲区。</li>
<li>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中 的每个字节对应的复制偏移量(offset) 。由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</li>
</ul>
<p>主节点运行ID：</p>
<ul>
<li>每个redis节点启动后都会动态分配一个40位的十六进制字符串为运行ID。运行ID的主要作用是来唯一识别redis节点，比如从节点保存主节点的运行ID识别自已正在复制是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集（如替换RDB/AOF文件），从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。可以在<code>info server</code>命令查看当前节点的运行ID。</li>
<li>需要注意的是redis关闭再启动，运行的id会随之变化。</li>
</ul>
<p>Psync命令：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA2LzAzL2Q4ZjA2Mjc5YzdlYzQucG5n?x-oss-process=image/format,png"></p>
<ul>
<li>从节点使用<code>psync</code>命令完成部分复制和全量复制功能<code>psync runid offset</code></li>
<li>流程说明：<ul>
<li> 从节点(slave)发送psync命令给主节点，参数runid是当前从节点保存的主节点运行id，如果没有则默认值为 ？, 参数offset是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为-1。</li>
<li>主节点根据<code>pysnc</code>参数和自身数据情况决定响应结果：<ul>
<li>如果回复+FULLRESYNC {runid} {offset}，那么从节点将触发全量复制流程。</li>
<li>如果回复+CONTINUE，从节点将触发部分复制流程。</li>
<li>如果回复-ERR，说明主节点版本低于Redis2.8。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>全量复制流程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA2LzAzLzczNTFiMzg5NTRhYjkucG5n?x-oss-process=image/format,png"></p>
<ul>
<li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行id，所以发送psync ? -1 </li>
<li> 主节点根据psync ? -1解析出当前为全量复制，回复+FULLRESYNC响应(主机会向从机发送 runid 和 offset，因为 slave 并没有对应的 offset，所以是全量复制)</li>
<li>从节点接收主节点的响应数据保存运行ID和偏移量offset(从机 slave 会保存 主机master 的基本信息 save masterInfo)</li>
<li>主节点收到全量复制的命令后，执行bgsave（异步执行），在后台生成RDB文件（快照），并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</li>
<li>主节点发送RDB文件给从节点，从节点把接收到的RDB文件保存在本地并直接作为从节点的数据文件，接收完RDB后从节点打印相关日志，可以在日志中查看主节点发送的数据量(主机send RDB 发送 RDB 文件给从机)<ul>
<li>注意！对于数据量较大的主节点，比如生成的RDB文件超过6GB以上时要格外小心。传输文件这一步操作非常耗时，速度取决于主从节点之间网络带宽。</li>
<li>通过细致分析Full resync和MASTER &lt;-&gt; SLAVE这两行日志的时间差，可以算出RDB文件从创建到传输完毕消耗的总时间。如果总时间超过repl-timeout所配置的值 (默认60秒)，从节点将放弃接受RDB文件并清理已经下载的临时文件，导致全量复制失败;针对数据量较大的节点，建议调大repl-timeout参数防止出现全量同步数据超时; </li>
<li>例如对于千兆网卡的机器，网卡带宽理论峰值大约每秒传输100MB,在不考虑其他进程消耗带宽的情况下，6GB的RDB文件至少需要60秒传输时间，默认配置下，极易出现主从数同步超时。</li>
</ul>
</li>
<li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据致性。(发送缓冲区数据) </li>
<li>从节点接收完主节点传送来的全部数据后会清空自身旧数据(刷新旧的数据，从节点在载入主节点的数据之前要先将老数据清除) </li>
<li>从节点清空数据后开始加载RDB文件，对于较大的RDB文件，这一步操作依然比较消耗时间，可以通过计算日志之间的实际差来判断加载RDB的总消耗时间(加载 RDB 文件将数据库状态更新至主节点执行bgsave时的数据库状态和缓冲区数据的加载。)</li>
<li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化的功能，它会立刻做bgrewriteeaof的操作，为了保证全量复制后AOF持久化文件立刻可用。 通过分析全量复制的所有流程，全量复制是一个非常耗时费力的操作。他的实际开销主要包括： <ul>
<li>主节点bgsave时间</li>
<li>RDB文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB的时间</li>
<li>可能的AOF重写时间</li>
</ul>
</li>
</ul>
<p>部分复制流程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA2LzA0LzY1YjBlNzYzZjRmZDIucG5n?x-oss-process=image/format,png"></p>
<ul>
<li><p>部分复制是 Redis 2.8 以后出现的，之所以要加入部分复制，是因为全量复制会产生很多问题，比如像上面的时间开销大、无法隔离等问题， Redis 希望能够在主节点出现抖动（相当于断开连接）的时候，可以有一些机制将复制的损失降低到最低</p>
</li>
<li><p>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点出问题了并断开复制链接（如果网络抖动（连接断开 connection lost））。</p>
</li>
<li><p>主从连接中断期间主节点依然响应命令，但因复制链接中断命令无法发送给从节点不过主节点内部存在的复制积压缓存去，依然可以保存一段时间的写命令数据，默认最大缓存1MB(主机master 还是会写 replbackbuffer（复制缓冲区）) </p>
</li>
<li><p>当主从节点网络恢复后，从节点会再次连上主节点。(从机slave会继续尝试连接主机)</p>
</li>
<li><p>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行id。因此会把他们当作psync参数发送给主节点，要求进行部分复制操作。(从机 slave 会把自己当前 runid 和偏移量传输给主机 master，并且执行 pysnc 命令同步) </p>
</li>
<li><p>主节点接到psync命令后首先核对参数的runid，如果 master 发现你的偏移量是在缓冲区的范围内，根据参数offset在缓冲区查找复制内内，如果在偏移量之后的数据存在缓存区中，则对从节点发送continue表示可以进行部分复制 </p>
</li>
<li><p>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。(同步了 offset 的部分数据，所以部分复制的基础就是偏移量 offset) </p>
</li>
</ul>
<p>心跳：</p>
<blockquote>
<p>主节点在建立成功后会维护这长连接彼此发送心跳检测</p>
</blockquote>
<ul>
<li>主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过client list命令查看复制相关客户端信息，主节点的连接状态为flags=M,从节点连接状态 flags=S。</li>
<li>主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。</li>
<li>从节点在主线程中每隔1秒发送replconf ack {offset} 命令，给主节点上报自身当前的复制偏移量。</li>
</ul>
<p>缓冲区大小调节：</p>
<ul>
<li>由于缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li>
<li>反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置； </li>
<li>例如 如果网络中断的平均时间是 60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见， 可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-31T16:55:36.000Z" title="5/31/2020, 4:55:36 PM">2020-05-31</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">8 分钟读完 (大约1125个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/31/go%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0.html">Go常见架构模式的实现</a></h1><div class="content"><h2 id="实现pipe-filter-framework"><a href="#实现pipe-filter-framework" class="headerlink" title="实现pipe-filter framework"></a>实现pipe-filter framework</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxL2I3MWU3ZjRjNDliMTQucG5n?x-oss-process=image/format,png"></p>
<p>Pipe-Filter 模式：</p>
<ul>
<li>⾮常适合与数据处理及数据分析系统</li>
<li>Filter封装数据处理的功能</li>
<li>Pipe⽤于连接Filter传递数据或者在异步处理过程中缓冲数据流</li>
<li>进程内同步调⽤时，pipe演变为数据在⽅法调⽤间传递</li>
<li>松耦合：Filter只跟数据（格式）耦合</li>
</ul>
<p>Filter和组合模式：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxL2JjYmI5MWRiNTJhZGQucG5n?x-oss-process=image/format,png"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxLzY4N2IxNWEzNGU5MmQucG5n?x-oss-process=image/format,png"></p>
<p>示例：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxL2FjZjMyODk5NWI1NDcucG5n?x-oss-process=image/format,png"></p>
<p>简单示例代码：</p>
<p><code>filter.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package pipefilter is to define the interfaces and the structures for pipe-filter style implementation</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split_filter.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">	delimiter <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="keyword">string</span>)</span> *<span class="title">SplitFilter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span> <span class="title">Process</span><span class="params">(data Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">	str, ok := data.(<span class="keyword">string</span>) <span class="comment">//检查数据格式/类型，是否可以处理</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">	&#125;</span><br><span class="line">	parts := strings.Split(str, sf.delimiter)</span><br><span class="line">	<span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split_filter_test.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStringSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sf := NewSplitFilter(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">	resp, err := sf.Process(<span class="string">&quot;1,2,3&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	parts, ok := resp.([]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;Repsonse type is %T, but the expected type is string&quot;</span>, parts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(parts, []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;) &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Expected value is &#123;\&quot;1\&quot;,\&quot;2\&quot;,\&quot;3\&quot;&#125;, but actual is %v&quot;</span>, parts)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWrongInput</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sf := NewSplitFilter(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">	_, err := sf.Process(<span class="number">123</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;An error is expected.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现micro-kernel-framework"><a href="#实现micro-kernel-framework" class="headerlink" title="实现micro-kernel framework"></a>实现micro-kernel framework</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxLzMzYmU0MjlhMzRjYWEucG5n?x-oss-process=image/format,png"></p>
<ul>
<li><p>特点</p>
<ul>
<li>易于扩展</li>
<li>错误隔离</li>
<li>保持架构⼀致性</li>
</ul>
</li>
<li><p>要点</p>
</li>
<li><p>内核包含公共流程或通⽤逻辑</p>
<ul>
<li>将可变或可扩展部分规划为扩展点</li>
</ul>
</li>
<li><p>抽象扩展点⾏为，定义接⼝</p>
<ul>
<li>利⽤插件进⾏扩展</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzMxLzhjZjE1NTllNjNlMDIucG5n?x-oss-process=image/format,png"></p>
<p>简单示例代码：</p>
<p><code>agent.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> microkernel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Waiting = <span class="literal">iota</span></span><br><span class="line">	Running</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WrongStateError = errors.New(<span class="string">&quot;can not take the operation in the current state&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CollectorsError <span class="keyword">struct</span> &#123;</span><br><span class="line">	CollectorErrors []error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce CollectorsError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> strs []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, err := <span class="keyword">range</span> ce.CollectorErrors &#123;</span><br><span class="line">		strs = <span class="built_in">append</span>(strs, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(strs, <span class="string">&quot;;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Source  <span class="keyword">string</span></span><br><span class="line">	Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">	OnEvent(evt Event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">	Init(evtReceiver EventReceiver) error</span><br><span class="line">	Start(agtCtx context.Context) error</span><br><span class="line">	Stop() error</span><br><span class="line">	Destory() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">	collectors <span class="keyword">map</span>[<span class="keyword">string</span>]Collector</span><br><span class="line">	evtBuf     <span class="keyword">chan</span> Event</span><br><span class="line">	cancel     context.CancelFunc</span><br><span class="line">	ctx        context.Context</span><br><span class="line">	state      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">EventProcessGroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:</span><br><span class="line">			<span class="keyword">case</span> &lt;-agt.ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(evtSeg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAgent</span><span class="params">(sizeEvtBuf <span class="keyword">int</span>)</span> *<span class="title">Agent</span></span> &#123;</span><br><span class="line">	agt := Agent&#123;</span><br><span class="line">		collectors: <span class="keyword">map</span>[<span class="keyword">string</span>]Collector&#123;&#125;,</span><br><span class="line">		evtBuf:     <span class="built_in">make</span>(<span class="keyword">chan</span> Event, sizeEvtBuf),</span><br><span class="line">		state:      Waiting,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;agt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">RegisterCollector</span><span class="params">(name <span class="keyword">string</span>, collector Collector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">		<span class="keyword">return</span> WrongStateError</span><br><span class="line">	&#125;</span><br><span class="line">	agt.collectors[name] = collector</span><br><span class="line">	<span class="keyword">return</span> collector.Init(agt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">startCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> errs CollectorsError</span><br><span class="line">	<span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			err = collector.Start(ctx)</span><br><span class="line">			mutex.Lock()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">					errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(name, collector, agt.ctx)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">stopCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> errs CollectorsError</span><br><span class="line">	<span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">		<span class="keyword">if</span> err = collector.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">				errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">destoryCollectors</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> errs CollectorsError</span><br><span class="line">	<span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line">		<span class="keyword">if</span> err = collector.Destory(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs.CollectorErrors = <span class="built_in">append</span>(errs.CollectorErrors,</span><br><span class="line">				errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorErrors) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">		<span class="keyword">return</span> WrongStateError</span><br><span class="line">	&#125;</span><br><span class="line">	agt.state = Running</span><br><span class="line">	agt.ctx, agt.cancel = context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> agt.EventProcessGroutine()</span><br><span class="line">	<span class="keyword">return</span> agt.startCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> agt.state != Running &#123;</span><br><span class="line">		<span class="keyword">return</span> WrongStateError</span><br><span class="line">	&#125;</span><br><span class="line">	agt.state = Waiting</span><br><span class="line">	agt.cancel()</span><br><span class="line">	<span class="keyword">return</span> agt.stopCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">Destory</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line">		<span class="keyword">return</span> WrongStateError</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> agt.destoryCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span> <span class="title">OnEvent</span><span class="params">(evt Event)</span></span> &#123;</span><br><span class="line">	agt.evtBuf &lt;- evt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>agent_test.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> microkernel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DemoCollector <span class="keyword">struct</span> &#123;</span><br><span class="line">	evtReceiver EventReceiver</span><br><span class="line">	agtCtx      context.Context</span><br><span class="line">	stopChan    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	name        <span class="keyword">string</span></span><br><span class="line">	content     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollect</span><span class="params">(name <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> *<span class="title">DemoCollector</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DemoCollector&#123;</span><br><span class="line">		stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		name:     name,</span><br><span class="line">		content:  content,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Init</span><span class="params">(evtReceiver EventReceiver)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;initialize collector&quot;</span>, c.name)</span><br><span class="line">	c.evtReceiver = evtReceiver</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Start</span><span class="params">(agtCtx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start collector&quot;</span>, c.name)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-agtCtx.Done():</span><br><span class="line">			c.stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">			c.evtReceiver.OnEvent(Event&#123;c.name, c.content&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;stop collector&quot;</span>, c.name)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-c.stopChan:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;failed to stop for timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *DemoCollector)</span> <span class="title">Destory</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(c.name, <span class="string">&quot;released resources.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAgent</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	agt := NewAgent(<span class="number">100</span>)</span><br><span class="line">	c1 := NewCollect(<span class="string">&quot;c1&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	c2 := NewCollect(<span class="string">&quot;c2&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">	agt.RegisterCollector(<span class="string">&quot;c1&quot;</span>, c1)</span><br><span class="line">	agt.RegisterCollector(<span class="string">&quot;c2&quot;</span>, c2)</span><br><span class="line">	<span class="keyword">if</span> err := agt.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;start error %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(agt.Start())</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	agt.Stop()</span><br><span class="line">	agt.Destory()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-31T00:37:19.000Z" title="5/31/2020, 12:37:19 AM">2020-05-31</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">6 分钟读完 (大约909个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/31/go%E5%8F%8D%E5%B0%84%E7%BC%96%E7%A8%8B.html">Go反射编程</a></h1><div class="content"><p>reflect.TypeOf vs. reflect.ValueOf：</p>
<ul>
<li>reflflect.TypeOf 返回类型 (reflflect.Type)</li>
<li>reflflect.ValueOf 返回值 (reflflect.Value)</li>
<li>可以从 reflflect.Value 获得类型</li>
<li>通过 kind 的来判断类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(v)</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32, reflect.Float64:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Float&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int32, reflect.Int64:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Integer&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Unknown&quot;</span>, t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBasicType</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">12</span></span><br><span class="line">	CheckType(f)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestBasicType</span></span><br><span class="line"><span class="comment">	Float</span></span><br><span class="line"><span class="comment">	--- PASS: TestBasicType (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用反射编写灵活的代码：</p>
<ul>
<li><p>按名字访问结构的成员</p>
<p><code>reflect.ValueOf(*e).FieldByName(&quot;Name&quot;)</code></p>
</li>
<li><p>按名字访问结构的方法</p>
<p><code>reflect.ValueOf(*e).MethodByName(&quot;UpdateAge&quot;).Call([]reflect.Value&#123;reflect.ValueOf(1)&#125;)</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	EmployeeId <span class="keyword">string</span></span><br><span class="line">	Name       <span class="keyword">string</span> <span class="string">`format:&quot;normal&quot;`</span></span><br><span class="line">	Age        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">UpdateAge</span><span class="params">(newVal <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	e.Age = newVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInvokeByName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := &amp;Employee&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">	<span class="comment">// 按名字获取成员</span></span><br><span class="line">	t.Logf(<span class="string">&quot;Name：value(%[1]v)，Type(%[1]T)&quot;</span>, reflect.ValueOf(*e).FieldByName(<span class="string">&quot;Name&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> nameField, ok := reflect.TypeOf(*e).FieldByName(<span class="string">&quot;Name&quot;</span>); !ok &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;Failed to get &#x27;Name&#x27; field.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Log(<span class="string">&quot;Tag:format&quot;</span>, nameField.Tag.Get(<span class="string">&quot;format&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	reflect.ValueOf(e).MethodByName(<span class="string">&quot;UpdateAge&quot;</span>).Call([]reflect.Value&#123;reflect.ValueOf(<span class="number">1</span>)&#125;)</span><br><span class="line">	t.Log(<span class="string">&quot;Updated Age:&quot;</span>, e)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestInvokeByName</span></span><br><span class="line"><span class="comment">	    TestInvokeByName: reflect_test.go:28: Name：value(Mike)，Type(reflect.Value)</span></span><br><span class="line"><span class="comment">	    TestInvokeByName: reflect_test.go:32: Tag:format normal</span></span><br><span class="line"><span class="comment">	    TestInvokeByName: reflect_test.go:35: Updated Age: &amp;&#123;1 Mike 1&#125;</span></span><br><span class="line"><span class="comment">	--- PASS: TestInvokeByName (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Struct Tag：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Age <span class="keyword">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问Struct：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nameField, ok := reflect.TypeOf(*e).FieldByName(<span class="string">&quot;Name&quot;</span>); !ok &#123;</span><br><span class="line">t.Error(<span class="string">&quot;Failed to get &#x27;Name&#x27; field.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Tag:format&quot;</span>, nameField.Tag.Get(<span class="string">&quot;format&quot;</span>)) &#125;</span><br></pre></td></tr></table></figure>

<p>Reflect.Type 和 Reflflect.Value 都有 FieldByName ⽅法，注意他们的区别。</p>
<p>DeepEqual：</p>
<p>比较切片和map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">	CookieID <span class="keyword">string</span></span><br><span class="line">	Name     <span class="keyword">string</span></span><br><span class="line">	Age      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDeepEqual</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	a := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;one&quot;</span>, <span class="number">2</span>: <span class="string">&quot;two&quot;</span>, <span class="number">3</span>: <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">	b := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;one&quot;</span>, <span class="number">2</span>: <span class="string">&quot;two&quot;</span>, <span class="number">4</span>: <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">	fmt.Println(reflect.DeepEqual(a, b))</span><br><span class="line"></span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s3 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;</span><br><span class="line">	t.Log(<span class="string">&quot;s1 == s2?&quot;</span>, reflect.DeepEqual(s1, s2))</span><br><span class="line">	t.Log(<span class="string">&quot;s1 == s3?&quot;</span>, reflect.DeepEqual(s1, s3))</span><br><span class="line"></span><br><span class="line">	c1 := Customer&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">40</span>&#125;</span><br><span class="line">	c2 := Customer&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">40</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.DeepEqual(c1, c2))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestDeepEqual</span></span><br><span class="line"><span class="comment">	false</span></span><br><span class="line"><span class="comment">	    TestDeepEqual: fiexible_reflect_test.go:23: s1 == s2? true</span></span><br><span class="line"><span class="comment">	    TestDeepEqual: fiexible_reflect_test.go:24: s1 == s3? false</span></span><br><span class="line"><span class="comment">	true</span></span><br><span class="line"><span class="comment">	--- PASS: TestDeepEqual (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于“反射”你应该知道的：</p>
<ul>
<li><p>提⾼了程序的灵活性</p>
</li>
<li><p>降低了程序的可读性</p>
</li>
<li><p>降低了程序的性能</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	EmployeeID <span class="keyword">string</span></span><br><span class="line">	Name       <span class="keyword">string</span> <span class="string">`format:&quot;normal&quot;`</span></span><br><span class="line">	Age        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">UpdateAge</span><span class="params">(newVal <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	e.Age = newVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">	CookieID <span class="keyword">string</span></span><br><span class="line">	Name     <span class="keyword">string</span></span><br><span class="line">	Age      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fillBySettings</span><span class="params">(st <span class="keyword">interface</span>&#123;&#125;, settings <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// func (v Value) Elem() Value</span></span><br><span class="line">	<span class="comment">// Elem returns the value that the interface v contains or that the pointer v points to.</span></span><br><span class="line">	<span class="comment">// It panics if v&#x27;s Kind is not Interface or Ptr.</span></span><br><span class="line">	<span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> reflect.TypeOf(st).Kind() != reflect.Ptr &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;the first param should be a pointer to the struct type.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Elem() 获取指针指向的值</span></span><br><span class="line">	<span class="keyword">if</span> reflect.TypeOf(st).Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;the first param should be a pointer to the struct type.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> settings == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;settings is nil.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		field reflect.StructField</span><br><span class="line">		ok    <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> settings &#123;</span><br><span class="line">		<span class="keyword">if</span> field, ok = (reflect.ValueOf(st)).Elem().Type().FieldByName(k); !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> field.Type == reflect.TypeOf(v) &#123;</span><br><span class="line">			vstr := reflect.ValueOf(st)</span><br><span class="line">			vstr = vstr.Elem()</span><br><span class="line">			vstr.FieldByName(k).Set(reflect.ValueOf(v))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFillNameAndAge</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	settings := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">	e := Employee&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := fillBySettings(&amp;e, settings); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(e)</span><br><span class="line">	c := <span class="built_in">new</span>(Customer)</span><br><span class="line">	<span class="keyword">if</span> err := fillBySettings(c, settings); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.Log(*c)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFillNameAndAge</span></span><br><span class="line"><span class="comment">	    TestFillNameAndAge: fiexible_reflect_test.go:69: &#123; Mike 30&#125;</span></span><br><span class="line"><span class="comment">	    TestFillNameAndAge: fiexible_reflect_test.go:74: &#123; Mike 30&#125;</span></span><br><span class="line"><span class="comment">	--- PASS: TestFillNameAndAge (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>”不安全“行为的危险性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUnsafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	i := <span class="number">10</span></span><br><span class="line">	f := *(*<span class="keyword">float64</span>)(unsafe.Pointer(&amp;i))</span><br><span class="line">	t.Log(unsafe.Pointer(&amp;i))</span><br><span class="line">	t.Log(f)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestUnsafe</span></span><br><span class="line"><span class="comment">	    TestUnsafe: unsafe_test.go:11: 0xc000016268</span></span><br><span class="line"><span class="comment">	    TestUnsafe: unsafe_test.go:12: 5e-323</span></span><br><span class="line"><span class="comment">	--- PASS: TestUnsafe (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The cases is suitable for unsafe</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合理的类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	b := *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">	t.Log(b)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestConvert</span></span><br><span class="line"><span class="comment">	    TestConvert: unsafe_test.go:26: [1 2 3 4]</span></span><br><span class="line"><span class="comment">	--- PASS: TestConvert (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类型操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> shareBuffer unsafe.Pointer</span><br><span class="line">	writeDataFn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		data := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			data = <span class="built_in">append</span>(data, i)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.StorePointer(&amp;shareBuffer, unsafe.Pointer(&amp;data))</span><br><span class="line">	&#125;</span><br><span class="line">	readDataFn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		data := atomic.LoadPointer(&amp;shareBuffer)</span><br><span class="line">		fmt.Println(data, *(*[]<span class="keyword">int</span>)(data))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	writeDataFn()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">				writeDataFn()</span><br><span class="line">				time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">				readDataFn()</span><br><span class="line">				time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-24T20:47:37.000Z" title="5/24/2020, 8:47:37 PM">2020-05-24</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">4 分钟读完 (大约534个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/24/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8Abenchmark.html">Go单元测试及Benchmark</a></h1><div class="content"><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>之前在刚开始写了如何编写测试程序</p>
<p>内置单元测试框架：</p>
<ul>
<li><p>Fail, Error: 该测试失败，该测试继续，其他测试继续执⾏</p>
</li>
<li><p>FailNow, Fatal: 该测试失败，该测试中⽌，其他测试继续执⾏</p>
</li>
<li><p>代码覆盖率</p>
<p><code>go test -v -cover</code></p>
</li>
<li><p>断言</p>
<p><a target="_blank" rel="noopener" href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorInCode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	t.Error(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestErrorInCode</span></span><br><span class="line"><span class="comment">	Start</span></span><br><span class="line"><span class="comment">	    TestErrorInCode: functions_test.go:25: Error</span></span><br><span class="line"><span class="comment">	End</span></span><br><span class="line"><span class="comment">	--- FAIL: TestErrorInCode (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFatalInCode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	t.Fatal(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFatalInCode</span></span><br><span class="line"><span class="comment">	Start</span></span><br><span class="line"><span class="comment">	    TestFatalInCode: functions_test.go:38: Error</span></span><br><span class="line"><span class="comment">	--- FAIL: TestFatalInCode (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用断言：</p>
<p><code>go get -u github.com/stretchr/testify</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(op <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> op * op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSquareWithAssert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	inputs := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	expected := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inputs); i++ &#123;</span><br><span class="line">		ret := square(inputs[i])</span><br><span class="line">		assert.Equal(t, expected[i], ret)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>文件名以下划线<code>_benchmark</code>结尾，方法名以<code>Benchmark</code>开头，参数为<code>b *testing.B</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用+=连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConcatStringByAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	assert := assert.New(t)</span><br><span class="line">	elems := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;</span><br><span class="line">	ret := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">		ret += elem</span><br><span class="line">	&#125;</span><br><span class="line">	assert.Equal(<span class="string">&quot;12345&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用buffer连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConcatStringBytesBuffer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	assert := assert.New(t)</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	elems := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">		buf.WriteString(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	assert.Equal(<span class="string">&quot;12345&quot;</span>, buf.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	elems := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		ret := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">			ret += elem</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringBytesBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	elems := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">		<span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">			buf.WriteString(elem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行输入 <code>go test -bench=. -benchmem</code></p>
<p>Windows 下使⽤ go test 命令⾏时，-bench=.应写为-bench=”.”</p>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: eighteen/benchmark</span><br><span class="line">BenchmarkConcatStringByAdd-8             8982729               130 ns/op              16 B/op          4 allocs/op</span><br><span class="line">BenchmarkConcatStringBytesBuffer-8      17703706                64.9 ns/op            64 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      eighteen/benchmark      2.532s</span><br></pre></td></tr></table></figure>

<p>使用 <code>buffer</code> 连接字符串的性能比 <code>+=</code> 要好很多。</p>
<h2 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h2><p>BDD in Go：</p>
<p>项⽬⽹站 ：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a></p>
<p>安装：</p>
<p><code>go get -u github.com/smartystreets/goconvey/convey</code></p>
<p>启动 WEB UI ：</p>
<p><code>$GOPATH/bin/goconvey</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSpec</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	convey.Convey(<span class="string">&quot;Given 2 even numbers&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a := <span class="number">2</span></span><br><span class="line">		b := <span class="number">4</span></span><br><span class="line">		convey.Convey(<span class="string">&quot;When add the two numbers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c := a + b</span><br><span class="line">			convey.Convey(<span class="string">&quot;Then the result is still even&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				convey.So(c%<span class="number">2</span>, convey.ShouldEqual, <span class="number">0</span>)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v  bdd_spec_test.go </span><br><span class="line">=== RUN   TestSpec</span><br><span class="line"></span><br><span class="line">  Given 2 even numbers </span><br><span class="line">    When add the two numbers </span><br><span class="line">      Then the result is still even ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 total assertion</span><br><span class="line"></span><br><span class="line">--- PASS: TestSpec (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.006s</span><br></pre></td></tr></table></figure>

<p>可以看到最后一步为 ✔</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-23T19:44:28.000Z" title="5/23/2020, 7:44:28 PM">2020-05-23</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">8 分钟读完 (大约1242个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/23/go%E5%85%B8%E5%9E%8B%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1.html">Go典型并发任务</a></h1><div class="content"><h2 id="仅运行一次"><a href="#仅运行一次" class="headerlink" title="仅运行一次"></a>仅运行一次</h2><p>最容易联想到的单例模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleInstance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingletonObj</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Create Obj&quot;</span>)</span><br><span class="line">		singleInstance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> singleInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSingletonObj</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			obj := GetSingletonObj()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, unsafe.Pointer(obj))</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestGetSingletonObj</span></span><br><span class="line"><span class="comment">	Create Obj</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	1269f78</span></span><br><span class="line"><span class="comment">	--- PASS: TestGetSingletonObj (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="仅需任意任务完成"><a href="#仅需任意任务完成" class="headerlink" title="仅需任意任务完成"></a>仅需任意任务完成</h2><p>任务堆里面，只需任务一个完成就返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runTask</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;the result is from %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstResponse</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	numOfRunner := <span class="number">10</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 非缓冲channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfRunner; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			ret := runTask(i)</span><br><span class="line">			ch &lt;- ret</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstResponse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(FirstResponse())</span><br><span class="line">	<span class="comment">/** 第一次运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFirstResponse</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: first_response_test.go:27: the result is from 0</span></span><br><span class="line"><span class="comment">	--- PASS: TestFirstResponse (0.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/** 第二次运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFirstResponse</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: first_response_test.go:27: the result is from 3</span></span><br><span class="line"><span class="comment">	--- PASS: TestFirstResponse (0.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为协程的调度机制，所以返回结果不一样。</p>
<p>但这样是存在很大的问题，修改<code>TestFirstResponse</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstResponse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;Before:&quot;</span>, runtime.NumGoroutine()) <span class="comment">// 获取协程数量</span></span><br><span class="line">	t.Log(FirstResponse())</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	t.Log(<span class="string">&quot;After:&quot;</span>, runtime.NumGoroutine()) <span class="comment">// 获取协程数量</span></span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFirstResponse</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: first_response_test.go:28: Before: 2</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: first_response_test.go:29: the result is from 6</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: first_response_test.go:30: After: 11</span></span><br><span class="line"><span class="comment">	--- PASS: TestFirstResponse (0.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用的是非缓冲<strong>channel</strong>，<code>FirstResponse</code>方法只取走了一次，往<strong>channel</strong>放入数据的时候，没有被取走，会造成阻塞。</p>
<p>修改非缓冲<strong>channel</strong> 为缓冲<strong>channel</strong>就行，否则会造成资源耗尽。</p>
<h2 id="所有任务完成"><a href="#所有任务完成" class="headerlink" title="所有任务完成"></a>所有任务完成</h2><p>之前都是用<code>sync.waitGroup</code>实现，这次利用csp机制实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runTask</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;the result is from %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllResponse</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	numOfRunner := <span class="number">10</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 非缓冲channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfRunner; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			ret := runTask(i)</span><br><span class="line">			ch &lt;- ret</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	finalRet := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfRunner; i++ &#123;</span><br><span class="line">		finalRet += &lt;-ch + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> finalRet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstResponse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(AllResponse())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestFirstResponse</span></span><br><span class="line"><span class="comment">	    TestFirstResponse: all_done_test.go:33: the result is from 9</span></span><br><span class="line"><span class="comment">	        the result is from 0</span></span><br><span class="line"><span class="comment">	        the result is from 2</span></span><br><span class="line"><span class="comment">	        the result is from 7</span></span><br><span class="line"><span class="comment">	        the result is from 4</span></span><br><span class="line"><span class="comment">	        the result is from 6</span></span><br><span class="line"><span class="comment">	        the result is from 1</span></span><br><span class="line"><span class="comment">	        the result is from 5</span></span><br><span class="line"><span class="comment">	        the result is from 8</span></span><br><span class="line"><span class="comment">	        the result is from 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	--- PASS: TestFirstResponse (0.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>使用 buffered channel 实现对象池</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIzL2Y2ZGE0NTcyZTQxOWEucG5n?x-oss-process=image/format,png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReusableObj <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	bufChan <span class="keyword">chan</span> *ReusableObj <span class="comment">// 用于缓冲可重用对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewObjPool</span><span class="params">(numOfObj <span class="keyword">int</span>)</span> *<span class="title">ObjPool</span></span> &#123;</span><br><span class="line">	objPool := ObjPool&#123;&#125;</span><br><span class="line">	objPool.bufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReusableObj, numOfObj)</span><br><span class="line">	<span class="comment">// 提前建立好连接</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfObj; i++ &#123;</span><br><span class="line">		objPool.bufChan &lt;- &amp;ReusableObj&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;objPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ObjPool)</span> <span class="title">GetObj</span><span class="params">(timeout time.Duration)</span> <span class="params">(*ReusableObj, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ret := &lt;-p.bufChan:</span><br><span class="line">		<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(timeout): <span class="comment">// 超时控制</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ObjPool)</span> <span class="title">ReleaseObj</span><span class="params">(obj *ReusableObj)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.bufChan &lt;- obj:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestObjPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	pool := NewObjPool(<span class="number">10</span>) <span class="comment">// 创建对象池</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 从对象池中获取</span></span><br><span class="line">		<span class="keyword">if</span> v, err := pool.GetObj(time.Second * <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Error(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">			<span class="comment">// 放入对象池</span></span><br><span class="line">			<span class="keyword">if</span> err := pool.ReleaseObj(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				t.Error(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Pool对象缓存"><a href="#sync-Pool对象缓存" class="headerlink" title="sync.Pool对象缓存"></a>sync.Pool对象缓存</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIzLzI3OGQ1YzgzOTg5YWEucG5n?x-oss-process=image/format,png"></p>
<p><strong>sync.Pool</strong> 对象获取：</p>
<ul>
<li>尝试从私有对象获取</li>
<li>私有对象不存在，尝试从当前 <strong>Processor</strong> 的共享池获取</li>
<li>如果当前 <strong>Processor</strong> 共享池也是空的，那么就尝试去其他 <strong>Processor</strong> 的共享池获取</li>
<li> 如果所有⼦池都是空的，最后就⽤⽤户指定的 New 函数，产⽣⼀个新的对象返回</li>
</ul>
<p><strong>sync.Pool</strong> 对象放回：</p>
<ul>
<li>如果私有对象不存在则保存为私有对象</li>
<li>如果私有对象存在，放⼊当前 <strong>Processor</strong> ⼦池的共享池中</li>
</ul>
<p><strong>sync.Pool</strong> 对象生命周期：</p>
<ul>
<li><strong>GC</strong> 会清除 <strong>sync.Pool</strong> 缓存的对象</li>
<li>对象的缓存有效期为下⼀次 <strong>GC</strong> 之前</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSyncPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	pool := &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Create a new object.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := pool.Get().(<span class="keyword">int</span>) <span class="comment">// 从池中获取并断言类型</span></span><br><span class="line">	fmt.Println(v)        <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">	pool.Put(<span class="number">3</span>)</span><br><span class="line">	v1, _ := pool.Get().(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(v1) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在放进去个 2</span></span><br><span class="line">	pool.Put(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">//为了验证生命周期 这里GC一下</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	v3, _ := pool.Get().(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(v3) <span class="comment">// 100 而不是 2</span></span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestSyncPool</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	100</span></span><br><span class="line"><span class="comment">	3</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	100</span></span><br><span class="line"><span class="comment">	--- PASS: TestSyncPool (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSyncPoolMultiGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	pool := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Create a new object.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pool.Put(<span class="number">100</span>)</span><br><span class="line">	pool.Put(<span class="number">100</span>)</span><br><span class="line">	pool.Put(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			t.Log(pool.Get())</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestSyncPoolMultiGoroutine</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 100</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 100</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	Create a new object.</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 100</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	    TestSyncPoolMultiGoroutine: sync_pool_test.go:59: 10</span></span><br><span class="line"><span class="comment">	--- PASS: TestSyncPoolMultiGoroutine (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>sync.Pool</strong> 总结：</p>
<ul>
<li>适合于通过复用，降低复杂对象的创建和GC代价</li>
<li>协程安全，会有锁的开销</li>
<li>生命周期受GC影响，不适合于做连接池等，需自己管理生命周期的资源的池化</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-21T23:58:30.000Z" title="5/21/2020, 11:58:30 PM">2020-05-21</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">20 分钟读完 (大约2932个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/21/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">Go并发编程</a></h1><div class="content"><h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><p><strong>Thead</strong> vs. <strong>Groutine</strong></p>
<ul>
<li>创建时默认的 <strong>stack</strong> 的大小<ul>
<li>JDK5 以后的 Java Thread stack 默认为1M</li>
<li>Groutine 的 <strong>Stack</strong> 初始化大小为2k</li>
</ul>
</li>
<li>和 KSE（Kernel Space Entity）的对应关系<ul>
<li>Java Thread 是 1:1</li>
<li>Groutine 是 M:N</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIxLzJlMzYxNDNhMDVlYjAucG5n?x-oss-process=image/format,png"></p>
<p><strong>Go</strong>的<strong>GMP</strong>调度：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIxL2FjZmI2YzZkZDIxMjcucG5n?x-oss-process=image/format,png"></p>
<p><strong>M</strong>：系统线程</p>
<p><strong>P</strong>：Go实现的协程处理器</p>
<p><strong>G</strong>：协程</p>
<p>从图中可看出，<strong>Processor</strong> 在不同的系统线程中，每个 <strong>Processor</strong> 都挂着准备运行的协程队列。</p>
<p><strong>Processor</strong> 依次运行协程队列中的协程。</p>
<p>这时候问题就来了，假如一个协程运行的时间特别长，把整个 <strong>Processor</strong> 都占住了，那么在队列中的协程是不是就会被延迟的很久？</p>
<p>在Go启动的时候，会有一个守护线程来去做一个计数，计每个 <strong>Processor</strong> 运行完成的协程的数量，当一段时间内发现，某个 <strong>Processor</strong> 完成协程的数量没有发生变化的时候，就会往这个正在运行的协程任务栈插入一个特别的标记，协程在运行的时候遇到非内联函数，就会读到这个标记，就会把自己中断下来，然后插到这个等候协程队列的队尾，切换到别的协程进行运行。</p>
<p>当某一个协程被系统中断了，例如说 <strong>io</strong> 需要等待的时候，为了提高整体的并发，<strong>Processor</strong> 会把自己移到另一个可使用的系统线程当中，继续执行它所挂的协程队列，当这个被中断的协程被唤醒完成之后，会把自己加入到其中某个 <strong>Processor</strong> 的队列里，会加入到全局等待队列中。</p>
<p>当一个协程被中断的时候，它在寄存器里的运行状态也会保存到这个协程对象里，当协程再次获得运行状态的时候，重写写入寄存器，继续运行。</p>
<p>话不多说，直接上代码，如何在代码里启动一个协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// int 参数</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;(i) <span class="comment">// 传入参数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有可能测试程序结束的非常快 加个等待</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestGroutine</span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">	4</span></span><br><span class="line"><span class="comment">	5</span></span><br><span class="line"><span class="comment">	2</span></span><br><span class="line"><span class="comment">	6</span></span><br><span class="line"><span class="comment">	3</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	8</span></span><br><span class="line"><span class="comment">	9</span></span><br><span class="line"><span class="comment">	7</span></span><br><span class="line"><span class="comment">	--- PASS: TestGroutine (0.05s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存并发机制"><a href="#共享内存并发机制" class="headerlink" title="共享内存并发机制"></a>共享内存并发机制</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>如果你是 <strong>Java</strong> 或者 <strong>C++</strong> 程序员，那么以下代码非常常见，使用锁来进行并发控制（可惜我是个Phper🙈）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// process (thread-safe)</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样Go也提供了这样的机 package sync：</p>
<p><strong>Mutex</strong> 互斥锁</p>
<p><strong>RWLock</strong> 读写锁</p>
<p>不使用锁的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			counter++</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCounter</span></span><br><span class="line"><span class="comment">	    TestCounter: share_memory_test.go:16: counter = 4627</span></span><br><span class="line"><span class="comment">	--- PASS: TestCounter (1.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现结果与预期结果不一样，这是因为 <code>conuter</code> 变量在不同的协程里面去做自增，导致了一个并发的竞争条件，传统意义来讲就是一个不是线程安全的程序。要保证线程安全，就要对共享的内存进行锁保护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterThreadSafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// defer 释放锁</span></span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			<span class="comment">// 加锁</span></span><br><span class="line">			mut.Lock()</span><br><span class="line">			counter++</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCounterThreadSafe</span></span><br><span class="line"><span class="comment">	    TestCounterThreadSafe: share_memory_test.go:40: counter = 5000</span></span><br><span class="line"><span class="comment">	--- PASS: TestCounterThreadSafe (1.01s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次就得到了预期结果。</p>
<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>等待所有协程完成，才能往下执行操作。</p>
<p>上面代码中，怕代码执行太快，所以加了 <strong>sleep</strong>。</p>
<p>但我们无法控制这个 <strong>sleep</strong> 需要睡眠时间。</p>
<p>下面来用 <code>WaitGroup</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 增加一个要等待的协程</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// defer 释放锁</span></span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				mut.Unlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			<span class="comment">// 加锁</span></span><br><span class="line">			mut.Lock()</span><br><span class="line">			counter++</span><br><span class="line">			wg.Done() <span class="comment">// 一个协程完成了</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有添加的协程完成 才继续向下运行</span></span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCounterWaitGroup</span></span><br><span class="line"><span class="comment">	    TestCounterWaitGroup: share_memory_test.go:66: counter = 5000</span></span><br><span class="line"><span class="comment">	--- PASS: TestCounterWaitGroup (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSP并发机制"><a href="#CSP并发机制" class="headerlink" title="CSP并发机制"></a>CSP并发机制</h2><p>有人可能会说不就是 <strong>Actor Model</strong> 嘛</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIxL2Y1YzEzZDIyZjVjZGYucG5n?x-oss-process=image/format,png" alt="Actor Model"></p>
<p><strong>CSP</strong> vs. <strong>Actor</strong></p>
<ul>
<li>和 <strong>Actor</strong> 的直接通讯不同，<strong>CSP</strong>模式则是通过<strong>Channel</strong>进行通讯的，更松耦合一些。</li>
<li><strong>Go</strong>中的<strong>channel</strong>是有容量限制并且独立于处理<strong>Groutine</strong>，而如<strong>Erlang</strong>，<strong>Actor</strong>模式中的<strong>mailbox</strong>容量是无限的，接收进程也总是被动地处理消息。</li>
</ul>
<p><strong>Channel</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIxLzdiNzg2NDNkOGRkYjEucG5n?x-oss-process=image/format,png" alt="channel"></p>
<p><strong>Go</strong>中<strong>Channel</strong>的基本机制：</p>
<ul>
<li><p>上图左边（非缓冲<strong>channel</strong>）：</p>
<p>通讯的两方必须同时在<strong>channel</strong>的两边，才能完成这次交互。任何一方不在，另一方就会被阻塞在那里等待，直到等到另一方才能完成这次交互。</p>
</li>
<li><p>上图右边（缓冲<strong>channel</strong>）：</p>
<p>就是对这个<strong>channel</strong>设置容量，在未满的情况下，放消息的人就能放进去，如果满了，就会发生阻塞等待。</p>
<p>等待拿消息的人去拿，空出来容量。反之，拿消息一样。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">50</span>) <span class="comment">// 模拟阻塞</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;working on something else&quot;</span>)</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>) <span class="comment">// 模拟阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Task is done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(service())</span><br><span class="line">	otherTask()</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestService</span></span><br><span class="line"><span class="comment">	Done</span></span><br><span class="line"><span class="comment">	working on something else</span></span><br><span class="line"><span class="comment">	Task is done.</span></span><br><span class="line"><span class="comment">	--- PASS: TestService (0.16s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由运行结果可知，完全是串行的，耗时为 0.16s</p>
<p>对 <code>service</code>进行改造，在调用的时候启动另外一个协程去执行，而不是阻塞当前写的协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">50</span>) <span class="comment">// 模拟阻塞</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;working on something else&quot;</span>)</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>) <span class="comment">// 模拟阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Task is done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsyncService</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 创建一个非缓冲string类型的channel</span></span><br><span class="line">	<span class="comment">//retCh := make(chan string, 1) // 创建一个容量为1 string类型的缓冲channel</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ret := service()</span><br><span class="line">		fmt.Println(<span class="string">&quot;returned result.&quot;</span>)</span><br><span class="line">		retCh &lt;- ret <span class="comment">// 放入 channel</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;service exited.&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> retCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAsyncService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	retCh := AsyncService()</span><br><span class="line">	otherTask()</span><br><span class="line">	fmt.Println(&lt;-retCh) <span class="comment">// 从channel拿出</span></span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestAsyncService</span></span><br><span class="line"><span class="comment">	working on something else</span></span><br><span class="line"><span class="comment">	returned result.</span></span><br><span class="line"><span class="comment">	Task is done.</span></span><br><span class="line"><span class="comment">	Done</span></span><br><span class="line"><span class="comment">	service exited.</span></span><br><span class="line"><span class="comment">	--- PASS: TestAsyncService (0.10s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看打印的顺序，实现了一个异步返回结果，耗时 0.1s</p>
<h2 id="多路选择和超时"><a href="#多路选择和超时" class="headerlink" title="多路选择和超时"></a>多路选择和超时</h2><p><strong>select</strong>：</p>
<ul>
<li><p>多渠道的选择：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ret := &lt;-retCh:</span><br><span class="line">		t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line">	<span class="keyword">case</span> ret := &lt;-retCh2:</span><br><span class="line">		t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		t.Error(<span class="string">&quot;No one returned&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>超时控制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> ret := &lt;-retCh:</span><br><span class="line">  	t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">	  t.Error(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">500</span>) <span class="comment">// 模拟阻塞</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsyncService</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 创建一个非缓冲channel</span></span><br><span class="line">	<span class="comment">//retCh := make(chan string, 10) // 创建一个容量为10的缓冲channel</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ret := service()</span><br><span class="line">		fmt.Println(<span class="string">&quot;returned result.&quot;</span>)</span><br><span class="line">		retCh &lt;- ret <span class="comment">// 放入 channel</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;service exited.&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> retCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSelect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 上面模拟阻塞 500ms</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ret := &lt;-AsyncService():</span><br><span class="line">		t.Log(ret)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">		t.Error(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestSelect</span></span><br><span class="line"><span class="comment">	    TestSelect: select_test.go:31: time out</span></span><br><span class="line"><span class="comment">	--- FAIL: TestSelect (0.10s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel的关闭和广播"><a href="#channel的关闭和广播" class="headerlink" title="channel的关闭和广播"></a>channel的关闭和广播</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataProducer</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i <span class="comment">// 放入</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataReceiver</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			data := &lt;-ch <span class="comment">// 取出</span></span><br><span class="line">			fmt.Println(data)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	dataProducer(ch, &amp;wg)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	dataReceiver(ch, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCloseChannel</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">	2</span></span><br><span class="line"><span class="comment">	3</span></span><br><span class="line"><span class="comment">	4</span></span><br><span class="line"><span class="comment">	5</span></span><br><span class="line"><span class="comment">	6</span></span><br><span class="line"><span class="comment">	7</span></span><br><span class="line"><span class="comment">	8</span></span><br><span class="line"><span class="comment">	9</span></span><br><span class="line"><span class="comment">	--- PASS: TestCloseChannel (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>dataProducer</code> 放数据的时候放了10个，<code>dataReceiver</code> 也是拿了10个。</p>
<p>这是因为我们知道是10，但正常情况 <code>dataReceiver</code> 才能知道 <code>dataProducer</code> 放完了呢。</p>
<p>其一我们可以做个约定，比如 <code>dataProducer</code> 放入个 -1 ，当 <code>dataReceiver</code> 收到 -1 就退出去。</p>
<p>但是又出来一个新问题，如果有多个 <code>dataReceiver</code> 呢，<code>dataProducer</code> 就得知道有多少个 <code>dataReceiver</code>，来放入多个 -1，问题就是不知道。</p>
<p><strong>channel</strong>的关闭：</p>
<ul>
<li>向关闭的 <strong>channel</strong> 发送数据，会导致 <strong>panic</strong></li>
<li><code>v, ok &lt;-ch; ok</code> 为 <strong>bool</strong> 值，<strong>true</strong> 表示正常接受，<strong>false</strong> 表示通道关闭</li>
<li>所有的 <strong>channel</strong> 接收者都会在 <strong>channel</strong> 关闭时，⽴立刻从阻塞等待中返回且上 述 <strong>ok</strong> 值为 <strong>false</strong>。这个⼴广播机制常被利利⽤用，进⾏行行向多个订阅者同时发送信号。 如:退出信号。</li>
</ul>
<p>改造 <code>dataReceiver</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataReceiver</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> data, ok := &lt;-ch; ok &#123; <span class="comment">// ok 为 true</span></span><br><span class="line">				fmt.Println(data)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 结束循环</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动多个  <code>dataReceiver</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	dataProducer(ch, &amp;wg)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	dataReceiver(ch, &amp;wg)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	dataReceiver(ch, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">  === RUN   TestCloseChannel</span></span><br><span class="line"><span class="comment">  0</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">  5</span></span><br><span class="line"><span class="comment">  6</span></span><br><span class="line"><span class="comment">  7</span></span><br><span class="line"><span class="comment">  8</span></span><br><span class="line"><span class="comment">  4</span></span><br><span class="line"><span class="comment">  9</span></span><br><span class="line"><span class="comment">  --- PASS: TestCloseChannel (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如不判断 <code>ok</code> 呢：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataReceiver</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">11</span>; i++ &#123; <span class="comment">// 上面 dataProducer 放进去了10个</span></span><br><span class="line">			data := &lt;-ch</span><br><span class="line">			fmt.Println(data) <span class="comment">// 当通道被关闭 会返回一个这个通道定义类型的零值</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务的取消"><a href="#任务的取消" class="headerlink" title="任务的取消"></a>任务的取消</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancel_1</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	cancelChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 往 channel 中放入消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancel_2</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(cancelChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isCancelled</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-cancelChan: <span class="comment">// 从 channel 中收到消息 返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cancelChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 启动5个协程任务</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123; <span class="comment">// 每个任务一直在执行</span></span><br><span class="line">				<span class="keyword">if</span> isCancelled(cancelChan) &#123; <span class="comment">// 每次检查是否任务是否进行停止 进行停止</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(i, <span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">		&#125;(i, cancelChan)</span><br><span class="line">	&#125;</span><br><span class="line">	cancel_1(cancelChan)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCancel</span></span><br><span class="line"><span class="comment">	4 Cancelled</span></span><br><span class="line"><span class="comment">	--- PASS: TestCancel (1.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一个 任务被取消掉了，因为 <strong>channel</strong> 传递过去只有一个信号，而这里有5个协程，其它协程没有被取消。</p>
<p>而我们可以传递5个，将它们全部取消，这样的编程坏处，前面的逻辑和有多少个<strong>task</strong>进行耦合，必须事先知道有多少个<strong>task</strong>。</p>
<p>换成第二个取消方法，因为是广播机制，所以所有协程都会收到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cancelChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 启动5个协程任务</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123; <span class="comment">// 每个任务一直在执行</span></span><br><span class="line">				<span class="keyword">if</span> isCancelled(cancelChan) &#123; <span class="comment">// 每次检查是否任务是否进行停止 进行停止</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(i, <span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">		&#125;(i, cancelChan)</span><br><span class="line">	&#125;</span><br><span class="line">	cancel_2(cancelChan)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCancel</span></span><br><span class="line"><span class="comment">	4 Cancelled</span></span><br><span class="line"><span class="comment">	2 Cancelled</span></span><br><span class="line"><span class="comment">	1 Cancelled</span></span><br><span class="line"><span class="comment">	0 Cancelled</span></span><br><span class="line"><span class="comment">	3 Cancelled</span></span><br><span class="line"><span class="comment">	--- PASS: TestCancel (1.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context与任务取消"><a href="#Context与任务取消" class="headerlink" title="Context与任务取消"></a>Context与任务取消</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIxLzE3ZjJmZDQ3NjM2MTYucG5n?x-oss-process=image/format,png"></p>
<p>我们直接取消叶子节点的任务是可以的，但是取消一个父节点，子节点任务不会被取消，当然可以自己去做这种机制。在 <strong>Go</strong> 的1.9版本之后把 <code>Context</code> 并入到内置包里面了。帮我们做这些事。</p>
<p><strong>Context</strong>：</p>
<ul>
<li>根 Context: 通过 context.Background () 创建</li>
<li>⼦ Context: context.WithCancel(parentContext) 创建<ul>
<li>ctx, cancel := context.WithCancel(context.Background())</li>
</ul>
</li>
<li>当前 Context 被取消时，基于他的⼦子 context 都会被取消</li>
<li>接收取消通知 &lt;-ctx.Done()</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isCancelled</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123; <span class="comment">// 启动5个协程任务</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, ctx context.Context)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123; <span class="comment">// 每个任务一直在执行</span></span><br><span class="line">				<span class="keyword">if</span> isCancelled(ctx) &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(i, <span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">		&#125;(i, ctx)</span><br><span class="line">	&#125;</span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCancel</span></span><br><span class="line"><span class="comment">	4 Cancelled</span></span><br><span class="line"><span class="comment">	2 Cancelled</span></span><br><span class="line"><span class="comment">	3 Cancelled</span></span><br><span class="line"><span class="comment">	0 Cancelled</span></span><br><span class="line"><span class="comment">	1 Cancelled</span></span><br><span class="line"><span class="comment">	--- PASS: TestCancel (1.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-20T10:24:48.000Z" title="5/20/2020, 10:24:48 AM">2020-05-20</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">5 分钟读完 (大约779个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/20/go%E5%8C%85%E5%92%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html">Go包和依赖管理</a></h1><div class="content"><h2 id="构建可复用的模块（包）"><a href="#构建可复用的模块（包）" class="headerlink" title="构建可复用的模块（包）"></a>构建可复用的模块（包）</h2><p>package：</p>
<ul>
<li><p>基本复用模块单元</p>
<p>以首字母大写来表明可被包外代码访问</p>
</li>
<li><p>代码的 package 可以和所在的目录不一致</p>
</li>
<li><p>同一目录里的 Go 代码的 package 要保持一致</p>
</li>
</ul>
<p>需要把包目录加入到GOPATH</p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Go</span><br><span class="line">- learning</span><br><span class="line">	- src</span><br><span class="line">		- fifteen</span><br><span class="line">			- client</span><br><span class="line">				- package_test.go</span><br><span class="line">			- series</span><br><span class="line">				- my_series.go</span><br></pre></td></tr></table></figure>

<p>查看 go env</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GOPATH=<span class="string">&quot;/Users/gaobinzhan/Documents/Go/learning:/Users/gaobinzhan/Documents/Go&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个目录已经加入<code>GOPATH</code>里了。</p>
<p><code>my_series.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> series</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母必须大写 才可被包外代码访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>package_test.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fifteen/series&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPackage</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(series.GetFibonacci(<span class="number">5</span>))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestPackage</span></span><br><span class="line"><span class="comment">	    TestPackage: package_test.go:9: [1 2 3 5 8] &lt;nil&gt;</span></span><br><span class="line"><span class="comment">	--- PASS: TestPackage (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init方法：</p>
<ul>
<li>在 <code>main</code> 被执行前，所有依赖的 <code>package</code> 的 <code>init</code> 方法都会被执行</li>
<li>不同包的 <code>init</code> 函数按照包导入的依赖关系决定执行顺序</li>
<li>每个包可以有多个 <code>init</code> 函数</li>
<li>包的每个源文件</li>
</ul>
<p>下面修改文件</p>
<p><code>my_series.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> series</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;init 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;init 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>package_test.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fifteen/series&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPackage</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(series.GetFibonacci(<span class="number">5</span>))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	init 1</span></span><br><span class="line"><span class="comment">	init 2</span></span><br><span class="line"><span class="comment">	=== RUN   TestPackage</span></span><br><span class="line"><span class="comment">	    TestPackage: package_test.go:10: [1 2 3 5 8] &lt;nil&gt;</span></span><br><span class="line"><span class="comment">	--- PASS: TestPackage (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取远程package：</p>
<ul>
<li><p>通过 go get 来获取远程依赖</p>
<p>go get -u 强制从网络更新远程依赖</p>
</li>
<li><p>注意代码在 Github 上的组织形式，以适应 go get</p>
<p>直接以代码路径开始，不要有 src</p>
</li>
</ul>
<p>示例：go get -u <a target="_blank" rel="noopener" href="https://github.com/easierway/concurrent_map">https://github.com/easierway/concurrent_map</a></p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> remote_package</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	cm <span class="string">&quot;github.com/easierway/concurrent_map&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConcurrentMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	m := cm.CreateConcurrentMap(<span class="number">99</span>)</span><br><span class="line">	m.Set(cm.StrKey(<span class="string">&quot;key&quot;</span>), <span class="number">10</span>)</span><br><span class="line">	t.Log(m.Get(cm.StrKey(<span class="string">&quot;key&quot;</span>)))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestConcurrentMap</span></span><br><span class="line"><span class="comment">	    TestConcurrentMap: remote_package_test.go:11: 10 true</span></span><br><span class="line"><span class="comment">	--- PASS: TestConcurrentMap (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Go未解决的依赖问题：</p>
<ul>
<li>同一环境下，不同项目使用同一包的不同版本</li>
<li>无法管理对包的特定版本的依赖</li>
</ul>
<p>vendor路径：</p>
<p>随着 Go 1.5 release 版本的发布，vendor ⽬录被添加到除了 GOPATH 和</p>
<p>GOROOT 之外的依赖⽬录查找的解决⽅案。在 Go 1.6 之前，你需要⼿动</p>
<p>的设置环境变量</p>
<p>查找依赖包路径的解决⽅案如下：</p>
<ul>
<li><p>当前包下的 vendor ⽬录</p>
</li>
<li><p>向上级⽬录查找，直到找到 src 下的 vendor ⽬录</p>
</li>
<li><p>在 GOPATH 下⾯查找依赖包</p>
</li>
<li><p>在 GOROOT ⽬录下查</p>
</li>
</ul>
<p>常用的依赖管理工具：</p>
<ul>
<li><p>godep <a target="_blank" rel="noopener" href="https://github.com/tools/godep">https://github.com/tools/godep</a></p>
</li>
<li><p>glide <a target="_blank" rel="noopener" href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a></p>
</li>
<li><p>dep <a target="_blank" rel="noopener" href="https://github.com/golang/dep">https://github.com/golang/dep</a> </p>
</li>
</ul>
<p>简单用一下</p>
<p>安装 gilde</p>
<p><code>brew install glide</code></p>
<p>删除我们刚刚 go get 下来的包 然后执行 glide init</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzIwLzJjOTJjODYxNjNkNTIucG5n?x-oss-process=image/format,png"></p>
<p>然后会在目录下面生成一个 <code>glide.yaml</code>文件</p>
<p>执行 <code>glide install</code> 会生成 <code>vendor</code> 目录 里面就是我们的依赖包</p>
<p>执行原来的测试文件，依然可以执行成功。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-18T23:21:19.000Z" title="5/18/2020, 11:21:19 PM">2020-05-18</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">8 分钟读完 (大约1254个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/18/go%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html">Go编写好的错误处理</a></h1><div class="content"><h2 id="编写好的错误处理"><a href="#编写好的错误处理" class="headerlink" title="编写好的错误处理"></a>编写好的错误处理</h2><p>Go的错误机制：</p>
<ul>
<li><p>没有异常机制</p>
</li>
<li><p><code>error</code> 类型实现了 <code>error</code> 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过 <code>errors.News</code> 来快速创建错误实例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors.News(<span class="string">&quot;n must be in the range [0,10]&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>拿Fibonacci举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetFibonacci</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(GetFibonacci(<span class="number">10</span>))</span><br><span class="line">	t.Log(GetFibonacci(<span class="number">-10</span>))</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestGetFibonacci</span></span><br><span class="line"><span class="comment">	    TestGetFibonacci: err_test.go:15: [1 2 3 5 8 13 21 34 55 89]</span></span><br><span class="line"><span class="comment">	    TestGetFibonacci: err_test.go:21: [1 2]</span></span><br><span class="line"><span class="comment">	--- PASS: TestGetFibonacci (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到没有对入参进行校验</p>
</blockquote>
<p>现在做下校验：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> || n &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;n should be in [2,100]&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetFibonacci</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果有错误进行错误输出</span></span><br><span class="line">	<span class="keyword">if</span> v, err := GetFibonacci(<span class="number">-10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Log(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestGetFibonacci</span></span><br><span class="line"><span class="comment">	    TestGetFibonacci: err_test.go:22: n should be in [2,100]</span></span><br><span class="line"><span class="comment">	--- FAIL: TestGetFibonacci (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在有个需求，返回的值是太小了还是太大了，返回不同的错误，最简单的方法直接改造<code>GetFibonacci</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;n should be not less than 2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;n should be not larger than 100&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果区分错误类型，依靠字符串去匹配简直太麻烦还容易出错，最常见的解决方法，定义两个预置的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LessThanTwoError = errors.New(<span class="string">&quot;n should be not less than 2&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> LargerThenHundredError = errors.New(<span class="string">&quot;n should be not larger than 100&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, LessThanTwoError</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, LargerThenHundredError</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fibList := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetFibonacci</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果有错误进行错误输出</span></span><br><span class="line">	<span class="keyword">if</span> v, err := GetFibonacci(<span class="number">-10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 假如调用者需要判断错误的就比较简单了</span></span><br><span class="line">		<span class="keyword">if</span> err == LessThanTwoError &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;It is less.&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Log(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestGetFibonacci</span></span><br><span class="line"><span class="comment">	It is less.</span></span><br><span class="line"><span class="comment">	    TestGetFibonacci: err_test.go:36: n should be not less than 2</span></span><br><span class="line"><span class="comment">	--- FAIL: TestGetFibonacci (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>定义不同的错误变量，以便于判断错误类型</p>
</li>
<li><p>及早失败，避免嵌套，提高代码可读性</p>
</li>
</ul>
<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>panic：</p>
<ul>
<li><code>panic</code> 用于不可以恢复的错误</li>
<li><code>panic</code> 退出前会执行 <code>defer</code> 指定的内容</li>
</ul>
<p>panic vs. os.Exit：</p>
<ul>
<li><code>os.Exit</code> 退出时不会调用 <code>defer</code> 指定的函数</li>
<li><code>os.Exit</code> 退出时不输出当前调用栈的信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	os.Exit(<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestExit</span></span><br><span class="line"><span class="comment">	Start</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Process finished with exit code 1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPanic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Finally!&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(errors.New(<span class="string">&quot;Something wrong!&quot;</span>))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestPanic</span></span><br><span class="line"><span class="comment">	Start</span></span><br><span class="line"><span class="comment">	Finally!</span></span><br><span class="line"><span class="comment">	--- FAIL: TestPanic (0.00s)</span></span><br><span class="line"><span class="comment">	panic: Something wrong! [recovered]</span></span><br><span class="line"><span class="comment">		panic: Something wrong!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	goroutine 6 [running]:</span></span><br><span class="line"><span class="comment">	testing.tRunner.func1.1(0x1119860, 0xc000046510)</span></span><br><span class="line"><span class="comment">		/usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:940 +0x2f5</span></span><br><span class="line"><span class="comment">	testing.tRunner.func1(0xc00011a120)</span></span><br><span class="line"><span class="comment">		/usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:943 +0x3f9</span></span><br><span class="line"><span class="comment">	panic(0x1119860, 0xc000046510)</span></span><br><span class="line"><span class="comment">		/usr/local/Cellar/go/1.14.2_1/libexec/src/runtime/panic.go:969 +0x166</span></span><br><span class="line"><span class="comment">	command-line-arguments.TestPanic(0xc00011a120)</span></span><br><span class="line"><span class="comment">		/Users/gaobinzhan/Documents/Go/learning/src/test/err_test.go:65 +0xd7</span></span><br><span class="line"><span class="comment">	testing.tRunner(0xc00011a120, 0x114afa0)</span></span><br><span class="line"><span class="comment">		/usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:991 +0xdc</span></span><br><span class="line"><span class="comment">	created by testing.(*T).Run</span></span><br><span class="line"><span class="comment">		/usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:1042 +0x357</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Process finished with exit code 1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>大家在写c++或者php代码的时候，总有一种习惯不希望这个程序被中断或者退出，用来捕获。</p>
<p>php代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (\<span class="built_in">Throwable</span> <span class="variable">$throwable</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(...)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 恢复错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRecover</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 没有写错误恢复 只是打印出来了</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;recovered from&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(errors.New(<span class="string">&quot;Something wrong!&quot;</span>))</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestRecover</span></span><br><span class="line"><span class="comment">	Start</span></span><br><span class="line"><span class="comment">	recovered from Something wrong!</span></span><br><span class="line"><span class="comment">	--- PASS: TestRecover (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常见的”错误恢复”：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(<span class="string">&quot;recovered panic&quot;</span>,err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>当心！<code>recover</code> 成为恶魔：</p>
<ul>
<li>形成僵尸服务进程，导致 health check 失效。</li>
<li>“Let it Crash!” 往往是我们恢复不确定性错误的最好方法。</li>
</ul>
<p>就如上常见的“错误恢复”只是记录了一下，这样的恢复方式是非常危险的。</p>
<p>一定要当心我们自己 <code>recover</code> 在做的事，因为我们 <code>recover</code> 的时候并不去检测错误到底发生了什么错误，而是简单的记录了一下或者忽略。</p>
<p>这时候可能是系统里面的某些核心资源已经消耗完了，我们这样把它强制恢复掉，其实系统依然不能够正常地工作的，还是导致我们的一些健康检查程序 health check 没有办法检查出当前系统的问题。</p>
<p>因为很多的这种 health check 只是检查当前的系统进程在还是不在，因为我们的进程是在的，所以就会导致一种僵尸服务进程，它好像活着，但它也不能提供服务。</p>
<p>这种情况下个人认为倒不如采用一种可恢复的设计模式其中的一种叫 <code>Let it Crash</code> ，干脆 <code>Crash</code>掉，一旦<code>Crash</code>掉 守护进程 ，就会帮我们的服务进程重新提起来。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-17T18:36:20.000Z" title="5/17/2020, 6:36:20 PM">2020-05-17</time>发表</span><span class="level-item"><time dateTime="2021-10-11T05:56:08.207Z" title="10/11/2021, 5:56:08 AM">2021-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">9 分钟读完 (大约1335个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/17/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html">Go面向对象编程</a></h1><div class="content"><p><strong>Is Go an object-oriented language?</strong></p>
<blockquote>
<p><strong>Yes and no</strong>. Although Go has types and methods and allows an object</p>
<p>oriented style of programming, there is <strong>no type hierarchy</strong>. <strong>The concept</strong> </p>
<p><strong>of “interface” in Go provides a different approach that we believe is</strong> </p>
<p><strong>easy to use and in some ways more general.</strong></p>
<p>Also, the lack of a type hierarchy makes “objects” in Go feel much more </p>
<p>lightweight than in languages such as C++ or Java.</p>
</blockquote>
<h2 id="行为的定义和实现"><a href="#行为的定义和实现" class="headerlink" title="行为的定义和实现"></a>行为的定义和实现</h2><p>结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">string</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实例创建及初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateEmployee</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;         <span class="comment">// 分别把值放进去</span></span><br><span class="line">	e1 := Employee&#123;Name: <span class="string">&quot;Mike&quot;</span>, Age: <span class="number">30</span>&#125; <span class="comment">// 指定某个field的值</span></span><br><span class="line">	e2 := <span class="built_in">new</span>(Employee)                   <span class="comment">// new关键字 去创建指向实例的指针 这里返回的引用/指针 相当于 e:=Employee&#123;&#125;</span></span><br><span class="line">	e2.Id = <span class="string">&quot;2&quot;</span>                           <span class="comment">// 通过 example.filed 去赋值</span></span><br><span class="line">	e2.Name = <span class="string">&quot;Rose&quot;</span></span><br><span class="line">	e2.Age = <span class="number">22</span></span><br><span class="line">	t.Log(e)</span><br><span class="line">	t.Log(e1)</span><br><span class="line">	t.Log(e1.Id)</span><br><span class="line">	t.Log(e2)</span><br><span class="line">	t.Logf(<span class="string">&quot;e is %T&quot;</span>, e)</span><br><span class="line">	t.Logf(<span class="string">&quot;e2 is %T&quot;</span>, e2)</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestCreateEmployee</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:18: &#123;0 Bob 20&#125;</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:19: &#123; Mike 30&#125;</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:20:</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:21: &amp;&#123;2 Rose 22&#125;</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:22: e is test.Employee</span></span><br><span class="line"><span class="comment">	    TestCreateEmployee: encap_test.go:23: e2 is *test.Employee</span></span><br><span class="line"><span class="comment">	--- PASS: TestCreateEmployee (0.00s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>行为定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义方式在实例对应方法被调用时，实例的成员会进行值复制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStructOperations</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">	t.Log(e.String())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestStructOperations</span></span><br><span class="line"><span class="comment">	    TestStructOperations: encap_test.go:46: ID:0-Name:Bob-Age:20</span></span><br><span class="line"><span class="comment">	--- PASS: TestStructOperations (0.00s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常情况下为了避免内存拷贝我们使用第二种定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s/Name:%s/Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStructOperations</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">	t.Log(e.String())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestStructOperations</span></span><br><span class="line"><span class="comment">	    TestStructOperations: encap_test.go:51: ID:0/Name:Bob/Age:20</span></span><br><span class="line"><span class="comment">	--- PASS: TestStructOperations (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Go语言中不管通过指针访问还是通过实例访问，都是一样的</p>
<p>那么这两种定义没有区别吗？？</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address is %x \n&quot;</span>, unsafe.Pointer(&amp;e.Name))</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s/Name:%s/Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStructOperations</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address is %x \n&quot;</span>, unsafe.Pointer(&amp;e.Name))</span><br><span class="line">	t.Log(e.String())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestStructOperations</span></span><br><span class="line"><span class="comment">	Address is c000060370</span></span><br><span class="line"><span class="comment">	Address is c000060370</span></span><br><span class="line"><span class="comment">	    TestStructOperations: encap_test.go:54: ID:0/Name:Bob/Age:20</span></span><br><span class="line"><span class="comment">	--- PASS: TestStructOperations (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现两个地址一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address is %x \n&quot;</span>, unsafe.Pointer(&amp;e.Name))</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStructOperations</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address is %x \n&quot;</span>, unsafe.Pointer(&amp;e.Name))</span><br><span class="line">	t.Log(e.String())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestStructOperations</span></span><br><span class="line"><span class="comment">	Address is c000092370</span></span><br><span class="line"><span class="comment">	Address is c0000923a0</span></span><br><span class="line"><span class="comment">	    TestStructOperations: encap_test.go:55: ID:0-Name:Bob-Age:20</span></span><br><span class="line"><span class="comment">	--- PASS: TestStructOperations (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候两个地址不一致，说明结构体的数据被复制了，会造成开销</p>
<h2 id="Go语言的相关接口"><a href="#Go语言的相关接口" class="headerlink" title="Go语言的相关接口"></a>Go语言的相关接口</h2><p>Java的接口与依赖：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzE3LzIzNGY5MDdkMjdlOTQucG5n?x-oss-process=image/format,png"></p>
<p>Go的 Duck Type 式接口实现：</p>
<ul>
<li>接口为非入侵性，实现不依赖与接口定义</li>
<li>所以接口的定义可以包含在接口使用者包内</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzE3L2IyYzAwNTUyNGM4OWQucG5n?x-oss-process=image/format,png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteHelloWorld() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoProgrammer)</span> <span class="title">WriteHelloWorld</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClient</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Programmer</span><br><span class="line">	p = <span class="built_in">new</span>(GoProgrammer)</span><br><span class="line">	t.Log(p.WriteHelloWorld())</span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestClient</span></span><br><span class="line"><span class="comment">	    TestClient: interface_test.go:19: Hello World</span></span><br><span class="line"><span class="comment">	--- PASS: TestClient (0.00s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口变量：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzE3Lzg3ZTU5NDM1MTUxNzQucG5n?x-oss-process=image/format,png"></p>
<p>自定义类型：</p>
<ul>
<li>type IntConvertionFn func(n int) int</li>
<li>type MyPoint int</li>
</ul>
<h2 id="扩展和复用"><a href="#扩展和复用" class="headerlink" title="扩展和复用"></a>扩展和复用</h2><p>复合：</p>
<ul>
<li>Go不支持继承，可以通过复合的方式来复用</li>
</ul>
<p>匿名类型嵌入：</p>
<p>它不是<strong>继承</strong>，如果我们把“内部 struct”看作父类，把“外部 struct” 看作子类，会发现如下问题：</p>
<ul>
<li>不支持子类替换</li>
<li>子类并不是真正继承了父类的方法<ul>
<li>父类定义的方法无法访问子类的数据和方法</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pet <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pet)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pet)</span> <span class="title">SpeakTo</span><span class="params">(<span class="keyword">string</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.Speak()</span><br><span class="line">	fmt.Println(<span class="string">&quot; &quot;</span>, <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	p *Pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">Speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;Wang!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">SpeakTo</span><span class="params">(<span class="keyword">string</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	d.p.SpeakTo(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDog</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	dog := <span class="built_in">new</span>(Dog)</span><br><span class="line">	dog.SpeakTo(<span class="string">&quot;Gao&quot;</span>) <span class="comment">// 没有打印 Wang! 需要改动 dog中SpeakTo方法</span></span><br><span class="line">	<span class="comment">/** 运行结果：</span></span><br><span class="line"><span class="comment">	=== RUN   TestDog</span></span><br><span class="line"><span class="comment">	...  Gao</span></span><br><span class="line"><span class="comment">	--- PASS: TestDog (0.00s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多态与空接口"><a href="#多态与空接口" class="headerlink" title="多态与空接口"></a>多态与空接口</h2><p>多态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Code <span class="keyword">string</span> <span class="comment">// 自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteHelloWorld() Code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PhpProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoProgrammer)</span> <span class="title">WriteHelloWorld</span><span class="params">()</span> <span class="title">Code</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;fmt.Println(\&quot;Hello World\&quot;)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PhpProgrammer)</span> <span class="title">WriteHelloWorld</span><span class="params">()</span> <span class="title">Code</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;echo \&quot;Hello World\&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFirstProgram</span><span class="params">(p Programmer)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, p, p.WriteHelloWorld())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPolymorphism</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	goProg := <span class="built_in">new</span>(GoProgrammer)</span><br><span class="line">	phpProg := <span class="built_in">new</span>(PhpProgrammer)</span><br><span class="line">	writeFirstProgram(goProg)</span><br><span class="line">	writeFirstProgram(phpProg)</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestPolymorphism</span></span><br><span class="line"><span class="comment">	*test.GoProgrammer fmt.Println(&quot;Hello World&quot;)</span></span><br><span class="line"><span class="comment">	*test.PhpProgrammer echo &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">	--- PASS: TestPolymorphism (0.00s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>空接口与断言：</p>
<ul>
<li><p>空接口可以表示任何类型</p>
</li>
<li><p>通过断言来将空接口转换为制定类型</p>
<p><code>v, ok := p.(int)  // ok=true 时为转换成功</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果传入的参数能被断言成一个整型</span></span><br><span class="line">	<span class="keyword">if</span> i, ok := p.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Integer&quot;</span>, i)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果传入的参数能被断言成一个字符型</span></span><br><span class="line">	<span class="keyword">if</span> s, ok := p.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;String&quot;</span>, s)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Unknow Type&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 也可以通过switch来判断</span></span><br><span class="line">	<span class="comment">/*switch v := p.(type) &#123;</span></span><br><span class="line"><span class="comment">	case int:</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Integer&quot;, v)</span></span><br><span class="line"><span class="comment">	case string:</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;String&quot;, v)</span></span><br><span class="line"><span class="comment">	default:</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Unknow Type&quot;)</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEmptyInterfaceAssertion</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	DoSomething(<span class="number">10</span>)</span><br><span class="line">	DoSomething(<span class="string">&quot;gaobinzhan&quot;</span>)</span><br><span class="line">	<span class="comment">/** 运行结果</span></span><br><span class="line"><span class="comment">	=== RUN   TestEmptyInterfaceAssertion</span></span><br><span class="line"><span class="comment">	Integer 10</span></span><br><span class="line"><span class="comment">	String gaobinzhan</span></span><br><span class="line"><span class="comment">	--- PASS: TestEmptyInterfaceAssertion (0.00s)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go接口最佳实践：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaW5pdS5nYW9iaW56aGFuLmNvbS8yMDIwLzA1LzE3L2Y4YmEwYzZhOGU5NTgucG5n?x-oss-process=image/format,png"></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/44792981?s=400&amp;u=273c6d745868dcacf7889e5da4499b751179f773&amp;v=4" alt="Stitch"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Stitch</p><p class="is-size-6 is-block">Alien monster</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Alien</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Stitch-June" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Stitch-June"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Laravel/"><span class="level-start"><span class="level-item">Laravel</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Php/"><span class="level-start"><span class="level-item">Php</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Swoole/"><span class="level-start"><span class="level-item">Swoole</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/uncategorized/"><span class="level-start"><span class="level-item">uncategorized</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-01T00:48:13.000Z">2021-04-01</time></p><p class="title"><a href="/2021/04/01/redis-%E9%93%BE%E8%A1%A8.html">Redis-链表</a></p><p class="categories"><a href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-31T01:12:26.000Z">2021-03-31</time></p><p class="title"><a href="/2021/03/31/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html">Redis-简单动态字符串SDS</a></p><p class="categories"><a href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-23T06:52:22.000Z">2020-09-23</time></p><p class="title"><a href="/2020/09/23/elasticsearch%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E-%E4%BD%BF%E7%94%A8.html">ElasticSearch全文检索引擎-使用</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-20T19:06:20.000Z">2020-09-20</time></p><p class="title"><a href="/2020/09/20/elasticsearch%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E-%E4%BB%8B%E7%BB%8D.html">ElasticSearch全文检索引擎-介绍</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-20T18:52:44.000Z">2020-09-20</time></p><p class="title"><a href="/2020/09/20/go%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.html">Go基本程序结构</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Stitch&#039;s Blog</a><p class="is-size-7"><span>&copy; 2021 stitch</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>