<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stitch&#39;s Blog</title>
  
  
  <link href="https://stitch.cn/atom.xml" rel="self"/>
  
  <link href="https://stitch.cn/"/>
  <updated>2021-10-01T03:05:23.216Z</updated>
  <id>https://stitch.cn/</id>
  
  <author>
    <name>stitch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-链表</title>
    <link href="https://stitch.cn/2021/04/01/redis-%E9%93%BE%E8%A1%A8.html"/>
    <id>https://stitch.cn/2021/04/01/redis-%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-04-01T00:40:00.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-链表"><a href="#Redis-链表" class="headerlink" title="Redis-链表"></a>Redis-链表</h1><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。</p><p>作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为<code>Redis</code>使用的<code>c</code>语言并没有内置这种数据结构，所以<code>Redis</code>构建了自己的链表实现。</p><p>链表在<code>Redis</code>中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串的时，<code>Redis</code>就会使用链表作为列表键的实现。</p><p>举个例子，以下展示的<code>integers</code>列表键包含了<code>1-1024</code>共一千零二十四个整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN integers</span><br><span class="line">(integer) 1024</span><br><span class="line">redis&gt; LRANGE integers 0 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br><span class="line">9) &quot;9&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">11) &quot;11&quot;</span><br></pre></td></tr></table></figure><p><code>integers</code>列表键的底层实现就是一个链表，链表中的每个节点都保存了一个整数值。<br>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，<code>Redis</code>服务器本身还是要链表保存多个客户端信息的状态信息，以及使用链表来构建客户端输出缓冲区<code>（output buffer）</code>。</p><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>每个链接节点使用一个<code>adlist.h/listNode</code>结构来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">        // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>多个<code>listNode</code>可以通过<code>prev</code>和<code>next</code>指针组成双端列表，如下图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/GppfqG.png"></p><p>虽然仅仅使用多个<code>listNode</code>结构就可以组成链表，但使用<code>adlist.h/list</code>来持有链表的话，操作起来会更方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">        // 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    // 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p><code>list</code>结构为链表提供了表头指针<code>head</code>、表尾指针<code>tail</code>，以及链表长度计数器<code>len</code>，而<code>dup</code>、<code>free</code>和<code>match</code>成员则是用于实现多态链表所需要的类型特定函数：</p><ul><li>  <code>dup</code>函数用于复制链表节点所保存的值；</li><li>  <code>free</code>函数用于释放链表节点所保存的值；</li><li>  <code>match</code>函数则用于对比链表节点所保存的值和另一个输入值是否相等；</li></ul><p>下图是由一个<code>list</code>结构和三个<code>listNode</code>结构组成的链表。</p><p><img src="https://qiniu.gaobinzhan.com/uPic/9MYc5C.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Redis</code>的链表实现的特性可以总结如下：</p><ul><li>  双端：链表节点带有<code>prev</code>和<code>next</code>指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>  无环：表头节点的<code>prev</code>指针和表尾节点的<code>next</code>指针都指向<code>NULL</code>，对链表的访问以<code>NULL</code>为终点。</li><li>  带表头指针和表尾指针：通过<code>list</code>结构的<code>head</code>指针和<code>tail</code>指针，程序获取链表的表头节点和表为节点的复杂度为O(1)。</li><li>  带链表长度计数器：程序使用<code>list</code>结构的<code>len</code>属性来对<code>list</code>持有的链表节点进行计数，程序获取链表中节点数量的的复杂度为O(1)。</li><li>  多态：链表节点使用<code>void*</code>指针来保存节点值，并且可以通过<code>list</code>结构的<code>dup</code>，<code>free</code>，<code>match</code>三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><p>如果我的文章对您有帮助：打赏一下哟！<a href="https://beg.gaobinzhan.com/">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-链表&quot;&gt;&lt;a href=&quot;#Redis-链表&quot; class=&quot;headerlink&quot; title=&quot;Redis-链表&quot;&gt;&lt;/a&gt;Redis-链表&lt;/h1&gt;&lt;p&gt;链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis-简单动态字符串SDS</title>
    <link href="https://stitch.cn/2021/03/31/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html"/>
    <id>https://stitch.cn/2021/03/31/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html</id>
    <published>2021-03-31T01:09:00.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-简单动态字符串SDS"><a href="#Redis-简单动态字符串SDS" class="headerlink" title="Redis-简单动态字符串SDS"></a>Redis-简单动态字符串SDS</h1><blockquote><p>好久没写博客了，今天水一篇文章。</p></blockquote><p><code>Redis</code>没有使用<code>c</code>语言传统的字符串去表示。而是构建了一种名为简单动态字符串<code>（simple dynamic string, SDS）</code>的抽象类型，并将<code>sds</code>用作<code>redis</code>的默认字符串表示。</p><p>举个例子<code>set msg &quot;hello world&quot;</code>：</p><ul><li>  键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg“的<code>sds</code>。</li><li>  键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的<code>sds</code>。</li></ul><p>又比如<code>rpush fruits &quot;apple&quot; &quot;banana&quot;</code>：</p><ul><li>  键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg“的<code>sds</code>。</li><li>  键值对的值是一个列表对象，列表对象包含了两个字符串对象，一个<code>sds</code>保存着<code>apple</code>，另一个保存着<code>banana</code>。</li></ul><h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>每个<code>sds.h/sdshdr</code>结构表示一个<code>SDS</code>值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    // 记录buf数组中已使用字节数量 等于sds所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    // 记录buf数组中未使用的字节数量</span><br><span class="line">    int free;</span><br><span class="line">    </span><br><span class="line">    // 字节数组 用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qiniu.gaobinzhan.com/uPic/BN0M1U.png"></p><ul><li>  <code>free</code>属性值为0，表示这个<code>sds</code>没有分配任何使用空间。</li><li>  <code>len</code>属性值为5，表示这个<code>sds</code>保存了一个五字节长的字符串。</li><li>  <code>buf</code>属性是一个<code>char</code>类型的数组，数组的前5个字节分别保存了为<code>R</code>，<code>e</code>，<code>d</code>，<code>i</code>，<code>s</code>五个字符，而最后一个字节则保存了空字符<code>�</code>。</li></ul><p><code>sds</code>遵循<code>c</code>语言字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在<code>sds</code>的<code>len</code>属性里面。并且为空字符分配额外的1字节空间及添加空字符到字符串末尾等操作都是有<code>sds</code>函数自动完成，所以这个空字符对于<code>sds</code>的使用者是完全透明的。</p><h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p><code>c</code>语言字符串使用长度为<code>N+1</code>的字符数组表示长度为<code>N</code>的字符串，并且字符数组的最后一个元素为空字符<code>�</code>。</p><p>这种简单的字符串不能满足<code>redis</code>对字符串在安全性、效率性以及功能方面的要求。</p><h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p><code>c</code>字符串并不记录自身的长度信息，所以获取一个<code>c</code>字符串的长度，程序需要遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，时间复杂度为<code>O(N)</code>。</p><p><code>sds</code>在<code>len</code>属性记录了<code>sds</code>本身的长度，所以获取一个<code>sds</code>的长度复杂度为<code>O(1)</code>。</p><p>设置和更新<code>sds</code>的长度工作是由<code>sds</code>的<code>api</code>在执行时自动完成的，使用<code>sds</code>无须进行任何手动修改长度的工作。</p><p>通过使用<code>sds</code>而不是<code>c</code>字符串，<code>redis</code>将获取字符串长度所需的时间复杂度从<code>O(N)</code>降低到了<code>O(1)</code>，这确保了获取字符串长度的工作不会成为<code>redis</code>的性能瓶颈。</p><h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p><code>c</code>字符串不记录自身长度将会带来另一个问题：容易造成缓冲区溢出<code>（buffer overflow）</code>。</p><p><code>strcat</code>函数可以将<code>src</code>字符串的内容拼接到<code>dest</code>字符串末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *dest, const char *src);</span><br></pre></td></tr></table></figure><p>因为<code>c</code>字符串不记录自身的长度，所以<code>stract</code>假定用户在执行这个函数时，已经为<code>dest</code>分配了足够多的内存，可以容纳<code>src</code>字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。</p><p>举个例子，假设程序有两个在内存中紧邻着的<code>c</code>字符串<code>s1</code>和<code>s2</code>，其中<code>s1</code>保存了字符串<code>redis</code>，而<code>s2</code>则保存了字符串<code>MongoDb</code>。如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/YVa6A5.png"></p><p>如果一个程序决定通过执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(s1, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure><p>将<code>s1</code>的内容修改为<code>Redis Cluster</code>，但粗心的却忘记了在执行<code>strcat</code>之前为<code>s1</code>分配足够的空间，那么函数执行之后，<code>s1</code>的数据将溢出到<code>s2</code>所在的空间中，导致<code>s2</code>保存的内容被意外的修改。如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/4MUtLG.png"></p><p>与<code>c</code>字符串不同，<code>sds</code>的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当<code>sds</code>的<code>api</code>需要对<code>sds</code>进行修改时，<code>api</code>会先检查<code>sds</code>的空间是否满足修改所需的要求，如果不满足，会自动将<code>sds</code>的空间扩展至执行修改所需要的大小，然后才执行实际的修改操作。所以使用<code>sds</code>不需要手动修改<code>sds</code>的空间大小，也不会出现缓冲区溢出问题。</p><p>举个例子：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/xFGvKA.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, &quot; Cluster&quot;)</span><br></pre></td></tr></table></figure><p><code>sdscat</code>将在执行拼接操作之前检查<code>s</code>的长度是否足够，不够将扩展空间，才去执行拼接操作，拼接完成后的<code>sds</code>如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/0CT0tl.png"></p><p><code>sdscat</code>不仅为这个<code>sds</code>进行拼接操作，还分配了<code>13</code>字节的未使用空间，并且拼接之后的字符串正好也是<code>13</code>字节，这不是<code>bug</code>，而是与<code>sds</code>的分配空间策略有关，下面会说明。</p><h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>因为<code>c</code>字符串的长度和底层数组的长度直接存在着关联关系，所以<code>c</code>语言字符串每次增长或者缩短都要进行一次内存重新分配操作；</p><ul><li>  如果程序执行增长字符串操作，执行操作前，程序需要先通过内存重新分配来扩展底层空间大小，忘记这步操作将会产生缓冲区溢出。</li><li>  如果程序执行缩短字符串操作，执行操作后，程序需要通过内存重新分配来释放字符串不使用的空间，忘记这步操作会产生内存泄露。</li></ul><p>对于<code>redis</code>，经常被用于速度要求严苛、数据被频繁修改的场景，如果每次修改字符串长度都要执行一次内存分配，光是执行内存重新分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁发生，可能会对性能造成影响。</p><p>为了避免<code>c</code>字符串的这种缺陷，<code>sds</code>通过未使用空间解决了字符串长度和底层数组长度之间的关联。通过未使用空间，<code>sds</code>实现了空间预分配和惰性空间释放两种优化策略。</p><p><strong>空间预分配</strong>：</p><p>空间预分配用于优化<code>sds</code>的字符串增长操作：当<code>sds</code>的<code>api</code>对一个<code>sds</code>进行修改，并且需要对<code>sds</code>进行空间扩展的时候，程序不仅会为<code>sds</code>分配修改所必须要的空间，还会为<code>sds</code>分配额外的未使用空间。</p><p>其中，额外分配未使用空间数量由以下公式决定：</p><ul><li>  如果对<code>sds</code>进行修改后，<code>sds</code>的长度将小于<code>1mb</code>，那么程序会分配和<code>len</code>属性同样大小的未使用空间，这时<code>sds</code>的<code>len</code>属性和<code>free</code>的值相同。举个例子，进行修改后<code>len</code>为<code>10</code>，那么<code>free</code>也为<code>10</code>，<code>sds</code>的<code>buf</code>数组的实际长度为<code>10 + 10 + 1 = 21</code>。</li><li>  如果对<code>sds</code>进行修改后，<code>sds</code>的长度将大于<code>1mb</code>，那么程序会分配<code>1mb</code>的使用空间。举个例子，进行修改后<code>len</code>为<code>10mb</code>，那么<code>free</code>为<code>1mb</code>，<code>sds</code>的<code>buf</code>数组的实际长度为<code>10mb + 1mb + 1byte</code>。</li></ul><p><strong>懒惰空间释放</strong></p><p>懒惰空间释放用于优化<code>sds</code>的字符串缩短操作：当<code>sds</code>的<code>api</code>需要缩短<code>sds</code>保存的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的自己，而是使用<code>free</code>属性将这些字节的数量记录起来，并等待将来使用。</p><p>举个例子，<code>sdstrim</code>函数接受一个<code>sds</code>和一个<code>c</code>字符串作为参数，从<code>sds</code>左右两端分别移出所以在<code>c</code>字符串中出现的字符。</p><p>如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/VqVvsH.png"></p><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdstrim(s, &quot;XY&quot;); // 移除 sds 字符串中所有 ‘X’和‘Y’</span><br></pre></td></tr></table></figure><p>会将<code>sds</code>修改成如下图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/W9ADsH.png"></p><p>注意执行<code>sdstrim</code>之后的<code>sds</code>并没有释放出来多余的<code>8</code>字节空间，而是将这<code>8</code>字节空间作为未使用空间保留在了<code>sds</code>里面，如果将来要<code>sds</code>进行增长操作，这些未使用空间就会用上。</p><p>举个例子，现在对<code>s</code>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, &quot; Redis&quot;);</span><br></pre></td></tr></table></figure><p>那么完成这次<code>sdscat</code>操作将不需要执行内存重新分配，因为<code>sds</code>预留的<code>8</code>字节空间足以拼接<code>6</code>个字节的 <code>Redis</code>，通过惰性空间释放策略，<code>sds</code>避免了缩短字符串所需的内存重分配操作，并为将来可能有的增长操作提供了优化，如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/Tq96Th.png"></p><p>与此同时，<code>sds</code>也提供了相应的<code>api</code>，让我们可以在有需要时，真正的释放<code>sds</code>的未使用空间，所以不必担心惰性空间释放策略会造成内存浪费。</p><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p><code>c</code>字符串中的字符必须符合某种编码<code>（比如 ASCII）</code>，并且除了字符串的末尾之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得<code>c</code>字符串只能保存文本数据，不能保存图片、音频这样的二进制数据。</p><p>举个例子，如果有一种使用空字符串分割多个单词的特殊数据格式，那么这种格式就不能使用<code>c</code>字符串来保存，因为<code>c</code>字符串所用的函数之后识别出其中的<code>Redis</code>，而忽略之后的<code>Cluster</code>。如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/AUOHC0.png"></p><p>而<code>sds</code>的<code>buf</code>属性被成为字节数组的原因——<code>redis</code>不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</p><p>例如，使用<code>sds</code>来保存之前提到的数据格式就没有问题，因为<code>sds</code>使用<code>len</code>属性的值而不是空字符来判断字符串是否结束，如图：</p><p><img src="https://qiniu.gaobinzhan.com/uPic/sCJWub.png"></p><h3 id="兼容部分c字符串函数"><a href="#兼容部分c字符串函数" class="headerlink" title="兼容部分c字符串函数"></a>兼容部分c字符串函数</h3><p>虽然<code>sds</code>的<code>api</code>都是二进制安全，但它们一样遵循<code>c</code>字符串以空字符串结尾的惯例：这些<code>api</code>总会将<code>sds</code>保存的数据的末尾设置为空字符，并且总会在为<code>buf</code>数组分配空间时多分配一个字节来容纳这个字符串，这是为了让那些保存文本数据的<code>sds</code>可以重用一部分<code>&lt;string.h&gt;</code>库定义的函数。</p><p><img src="https://qiniu.gaobinzhan.com/uPic/1ntPZ1.png"></p><p>举个例子，如果有一个保存文本数据的<code>sds</code>，如上图，那么我们就可以重用<code>&lt;string.h&gt;/strasecmp</code>函数，使用它来对比<code>sds</code>保存的字符串另一个<code>c</code>字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf, &quot;hello world&quot;);</span><br></pre></td></tr></table></figure><p>遵循<code>c</code>字符串以空字符结尾的惯例，<code>sds</code>可以在有需要时重用<code>&lt;string.h&gt;</code>函数库，避免不必要的代码重复。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C字符串</p><p>SDS</p><p>获取字符串长度的复杂度为O(N)</p><p>获取字符串长度的复杂度为O(1)</p><p>API是不安全的，可能会造成缓冲区溢出</p><p>API是安全的，不会造成缓冲区溢出</p><p>修改字符串长度N次必然需要执行N次内存重分配</p><p>修改字符串长度N次最多需要执行N次内存重分配</p><p>只能保存文本数据</p><p>可以保存文本数据或者二进制数据</p><p>可以使用<code>&lt;string.h&gt;</code>库中的函数</p><p>可以使用一部分<code>&lt;string.h&gt;</code>库中的函数</p><h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><p>如果我的文章对您有帮助：打赏一下哟！<a href="https://beg.gaobinzhan.com/">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-简单动态字符串SDS&quot;&gt;&lt;a href=&quot;#Redis-简单动态字符串SDS&quot; class=&quot;headerlink&quot; title=&quot;Redis-简单动态字符串SDS&quot;&gt;&lt;/a&gt;Redis-简单动态字符串SDS&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;好</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go常用集合</title>
    <link href="https://stitch.cn/2020/09/27/go%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88.html"/>
    <id>https://stitch.cn/2020/09/27/go%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88.html</id>
    <published>2020-09-27T12:28:48.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>[Toc]</p><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int // 声明并初始化为默认零值</span><br><span class="line">a[0] = 1</span><br><span class="line">b := [3]int&#123;1, 2, 3&#125;           // 声明同时初始化</span><br><span class="line">c := [2][2]int&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125; // 多维数组初始化</span><br><span class="line">t.Log(a[0], a[2])</span><br><span class="line">t.Log(b[2])</span><br><span class="line">t.Log(c[1][1])</span><br></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125; // 自动判断长度</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; len(arr); i++ &#123; // 典型写法遍历数组</span><br><span class="line">    t.Log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for idx, e := range arr &#123; // 相当于其它语言的foreach</span><br><span class="line">    t.Log(idx, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, e := range arr &#123; // 我们可能用不到 idx 但go语言定义一个值不去使用编译会不通过 使用_代表不关心这个结果，来占位</span><br><span class="line">    t.Log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截取：</p><p>a[开始索引(包含):结束索引(不包含)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125;</span><br><span class="line">// a[开始索引(包含):结束索引(不包含)]</span><br><span class="line">t.Log(arr[0:1]) // 1</span><br><span class="line">t.Log(arr[2:]) // 3 4 5 6</span><br><span class="line">t.Log(arr[1:len(arr)]) // 2 3 4 5 6</span><br><span class="line">t.Log(arr[1:3]) // 2 3</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>内部结构：</p><p><img src="http://qiniu.gaobinzhan.com/2020/05/13/7106b2933bdf9.jpeg"></p><p>声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var s0 []int            // 定义看起来特别像数组，但没有指定长度</span><br><span class="line">t.Log(len(s0), cap(s0)) // 0 0</span><br><span class="line">s0 = append(s0, 1)</span><br><span class="line">t.Log(len(s0), cap(s0)) // 1 1</span><br><span class="line"></span><br><span class="line">s1 := []int&#123;1, 2, 3, 4&#125; // 初始化一个切片</span><br><span class="line">t.Log(len(s1), cap(s1)) // 4 4</span><br><span class="line"></span><br><span class="line">// []type,len,cap 其中len个元素会被初始化为默认零值，未初始化元素不可以访问</span><br><span class="line">s2 := make([]int, 3, 5)    // len为3 cap为5</span><br><span class="line">t.Log(len(s2), cap(s2))    // 3 5</span><br><span class="line">t.Log(s2[0], s2[1], s2[2]) // 成功被初始化 结果：0 0 0</span><br><span class="line">//t.Log(s2[0], s2[1], s2[2], s2[3]) // 出现了一个错误 index out of range [3]</span><br><span class="line">s2 = append(s2, 1)</span><br><span class="line">t.Log(s2[0], s2[1], s2[2], s2[3]) // 0 0 0 1</span><br><span class="line">t.Log(len(s2), cap(s2))           // 4 5 len变成了4</span><br></pre></td></tr></table></figure><p>共享存储结构：</p><p><img src="http://qiniu.gaobinzhan.com/2020/05/13/775b24bebfd13.jpeg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s := []int&#123;&#125;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    s = append(s, i) // 为什么重新赋值给s,是因为结构体指向的连续存储空间进行了变化,并把原有的连续存储空间拷贝到新的连续存储空间</span><br><span class="line">    t.Log(len(s), cap(s))</span><br><span class="line">&#125;</span><br><span class="line">/** 运行结果：当len不够用的时候会增长，cap不够用的时候增长为前一个cap的2倍</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 1 1</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 2 2</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 3 4</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 4 4</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 5 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 6 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 7 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 8 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 9 16</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 10 16</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="Map声明、元素访问及遍历"><a href="#Map声明、元素访问及遍历" class="headerlink" title="Map声明、元素访问及遍历"></a>Map声明、元素访问及遍历</h2><p>声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m1 := map[int]int&#123;1: 1, 2: 4, 3: 9&#125; // 初始化一个map</span><br><span class="line">t.Log(m1[2])                        // 4</span><br><span class="line">t.Logf(&quot;len m1 = %d&quot;, len(m1))      // len m1 = 3</span><br><span class="line">m2 := map[int]int&#123;&#125;                 // 初始化一个空map</span><br><span class="line">m2[4] = 16                          // 赋值</span><br><span class="line">t.Logf(&quot;len m2 = %d&quot;, len(m2))      // len m2 = 1</span><br><span class="line">m3 := make(map[int]int, 10)         // 使用make初始化map</span><br><span class="line">t.Logf(&quot;len m3 = %d&quot;, len(m3))      // len m3 = 0 填的len为10,但打印出来为0</span><br></pre></td></tr></table></figure><p>元素访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// key在map中存在吗？</span><br><span class="line">// key存在但是对应的值是空值</span><br><span class="line">m1 := map[int]int&#123;&#125;</span><br><span class="line">t.Log(m1[1]) // 0 不存在输出0</span><br><span class="line">m1[2] = 0    // 设置value正好为0</span><br><span class="line">t.Log(m1[2]) // 0 也是0 该如何判断key是否存在呢</span><br><span class="line">// 需要主动去判断</span><br><span class="line">if v, ok := m1[3]; ok &#123;</span><br><span class="line">    t.Logf(&quot;key 3&#x27;s value is %d&quot;, v)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Log(&quot;key 3 is not existing.&quot;) // 将输出这句话</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1[3] = 9</span><br><span class="line">if v, ok := m1[3]; ok &#123;</span><br><span class="line">    t.Logf(&quot;key 3&#x27;s value is %d&quot;, v) // 将输出这句话</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Log(&quot;key 3 is not existing.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m1 := map[int]int&#123;1: 1, 2: 4, 3: 9&#125;</span><br><span class="line">for k, v := range m1 &#123;</span><br><span class="line">    t.Log(k, v)</span><br><span class="line">&#125;</span><br><span class="line">/** 运行结果</span><br><span class="line">    TestTravelMap: map_test.go:41: 1 1</span><br><span class="line">    TestTravelMap: map_test.go:41: 2 4</span><br><span class="line">    TestTravelMap: map_test.go:41: 3 9</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="Map与工厂模式，实现Set"><a href="#Map与工厂模式，实现Set" class="headerlink" title="Map与工厂模式，实现Set"></a>Map与工厂模式，实现Set</h2><ul><li>  Map的value可以是一个方法</li><li>  与Go的Dock type接口方式一起，可以方便的实现单一方法对象的工厂模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m := map[int]func(op int) int&#123;&#125;</span><br><span class="line">m[1] = func(op int) int &#123;</span><br><span class="line">    return op</span><br><span class="line">&#125;</span><br><span class="line">m[2] = func(op int) int &#123;</span><br><span class="line">    return op * op</span><br><span class="line">&#125;</span><br><span class="line">m[3] = func(op int) int &#123;</span><br><span class="line">    return op * op * op</span><br><span class="line">&#125;</span><br><span class="line">t.Log(m[1](2), m[2](2), m[3](2)) // 运行结果 2 4 8</span><br></pre></td></tr></table></figure><p>实现Set：</p><p>Go内置集合中没有Set实现，可以<code>map[type]bool</code></p><ul><li>  元素的唯一性</li><li>基本操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mySet := map[int]bool&#123;&#125;</span><br><span class="line">mySet[1] = true // 添加元素 value置为true</span><br><span class="line">n := 1</span><br><span class="line">if mySet[n] &#123;</span><br><span class="line">    t.Logf(&quot;%d is existing.&quot;, n) // 输出这句话</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Logf(&quot;%d is not existing.&quot;, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(mySet, 1) // 把1这个key从map中删除</span><br><span class="line"></span><br><span class="line">if mySet[n] &#123;</span><br><span class="line">    t.Logf(&quot;%d is existing.&quot;, n)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Logf(&quot;%d is not existing.&quot;, n) // 输出这句话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[Toc]&lt;/p&gt;
&lt;h2 id=&quot;数组和切片&quot;&gt;&lt;a href=&quot;#数组和切片&quot; class=&quot;headerlink&quot; title=&quot;数组和切片&quot;&gt;&lt;/a&gt;数组和切片&lt;/h2&gt;&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>redis之主从问题处理</title>
    <link href="https://stitch.cn/2020/09/27/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html"/>
    <id>https://stitch.cn/2020/09/27/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html</id>
    <published>2020-09-27T12:15:12.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Slaveof  <code>slaveof</code>  <strong>slave</strong>实例需要配置该项，指向<strong>master</strong>的(ip,port)</li><li>masterauth  <code>masterauth</code>  如果<strong>master</strong>实例启用了密码保护，则该配置项需要填<strong>master</strong>的启动密码；  如果未启用，需要将该配置项注视掉。</li><li>slave-serve-stale-data  指定<strong>slave</strong>与<strong>master</strong>连接中断时的动作。默认为<strong>yes</strong>，表明<strong>slave</strong>会继续应答来自<strong>client</strong>的请求，但这些数据可能已经过期（因为连接中断导致无法从<strong>master</strong>同步）。若配置为<strong>no</strong>，则<strong>slave</strong>除正常应答“<strong>INFO</strong>”和“<strong>SLAVEOF</strong>”命令外，其余来自客户端的请求命令均会得到“<strong>SYNC with master in progress</strong>“的应答，直到该<strong>slave</strong>与<strong>master</strong>连接重建成功或该<strong>slave</strong>被提升为<strong>master</strong>。</li><li>slave-read-only  指定<strong>slave</strong>是否只读，默认为<strong>yes</strong>。若配置为<strong>no</strong>，表示<strong>slave</strong>是可写的，但写的内容在主从同步完成后会被删除掉。</li><li>repl-disable-tcp-nodelay  指定向<strong>slave</strong>同步数据时，是否禁用<strong>socket</strong>的<strong>NO_DELAY</strong>选项。若配置为<strong>yes</strong>，则禁用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈会合并小包统一发送，这样可以减少主从节点间的包数量并节省宽带，但会增加数据同步到<strong>slave</strong>的时间。若配置为<strong>no</strong>，表明启用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈不会延迟小包的发送时间，这样数据同步的延时会减少，但需要更大的宽带。</li><li>slave-priority  指定<strong>slave</strong>的优先级。在不只1个<strong>slave</strong>存在的部署环境下，当<strong>master</strong>宕机时，<strong>Redis Sentinel</strong> 会将<strong>priority</strong>值最小的<strong>slave</strong>提升为<strong>master</strong>。需要注意的是，若该配置项为0，则对应的<strong>slave</strong>永远不会被<strong>Redis Sentinel</strong> 自动提升为<strong>master</strong>。</li></ul><p><strong>Redis</strong>复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络宽带和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或通知客户端避免读取延迟过高的从节点。</p><p>具体实现逻辑：</p><ul><li>  监控程序定期检查主从节点的偏移量，主节点偏移量在<code>info replication</code>的<code>master_repl_offset</code>指标记录，从节点偏移量可以查询主节点的<code>slave0</code>字段的<code>offset</code>指标，它们的差值就是主从节点延迟的字节量。</li><li>  对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点，同时从节点的<code>slave-serve-stable-data</code>参数也与此有关，它控制这种情况下从节点的表现，当从库同主机失去连接或者复制正在进行，从机库有两种运行方式。</li></ul><h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>当主节点存储大量设置超时的数据时，redis内部需要维护过期数据删除策略，删除策略主要有两种：</p><ul><li>惰性删除  主节点每次处理读取命令时，都会检查健是否超时，如果超时则执行·<code>del</code>命令删除键对象，之后<code>del</code>命令也会异步发给从节点。因为保持复制的一致性，从节点自身永远不会主动删除超时数据。</li><li>定时删除  <strong>Redis</strong>主节点在内部定时任务会循环采样一定数据量的键，当发现采用的键过期时会执行<code>del</code>命令，之后再同步给从节点。</li></ul><h3 id="从节点故障问题"><a href="#从节点故障问题" class="headerlink" title="从节点故障问题"></a>从节点故障问题</h3><p>对于从节点的故障问题，需要在客户端维护一个可用从节点可用列表，当从节点故障时，立刻切换到其他从节点或主节点，<strong>redis Cluster</strong>可以解决这个问题。</p><h2 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h2><p>主节点和从节点不同，经常导致主节点和从节点的配置不同，并带来问题。</p><p>主从配置不一致是一个容易忽视的问题。对于有些配置主从之间是可以不一致，比如：主节点关闭AOF，从节点开启AOF。但对于内存相关的配置必须要一致，比如<code>maxmemory</code>,<code>hash-max-ziplist-entries</code>等参数。</p><p>数据丢失：主机和从机有时候发生配置不一致的情况，例如<code>maxmemory</code>不一致。假如主机配置<code>maxmemory</code>为8G，从机设置为4G，这个时候是可以用的，而且不会报错。但如果要做高可用，让从节点变成主节点的时候，就会发现数据已经丢失，而且无法挽回。</p><h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><p>全量复制指的是当<strong>slave</strong>断开并重启后，<strong>runid</strong>产生变化而导致需要在<strong>master</strong>主机里拷贝全部数据。这种拷贝全部数据的过程非常耗资源。</p><p>全量复制是不可避免的，例如第一次的全量复制就不可避免，这时我们需要选择小主节点，且<code>maxmemory</code>值不要过大，这样就会比较快。同时选择在低峰值的时候做全量复制。</p><p>造成全量复制的原因：</p><ul><li>  主从机的运行<strong>runid</strong>不匹配。解释一下，主节点如果重启，<strong>runid</strong>将会发生变化。如果从节点监控到<strong>runid</strong>不是同一个，它就会认为你的节点不安全。当发生故障转移的时候，如果主节点发生故障，那么从节点就会变成主节点（哨兵和集群）。</li><li>  复制缓冲区空间不足，比如默认值为1M，可以部分复制，但如果缓冲区不够大的话，首先需要网络中断，部分复制将无法满足。其次需要增大复制缓冲区配置<code>repl-backlog-size</code>，对网络的缓冲增强。</li></ul><p>怎么解决：</p><ul><li>  在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得<strong>runid</strong>发生变化，可能导致不必要的全量复制。</li><li>  为了解决这个问题，<strong>Redis</strong>提供了<strong>debug reload</strong>的重启方式：重启后，主节点的<strong>runid</strong>和<strong>offset</strong>都不受影响，避免了全量复制。</li></ul><h2 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h2><p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成大量开销，导致 CPU、内存、带宽消耗。因此我们应该分析出复制风暴发生的场景，提前采用合理的方式规避。规避方式有如下几个。</p><h3 id="单节点复制风暴"><a href="#单节点复制风暴" class="headerlink" title="单节点复制风暴"></a>单节点复制风暴</h3><p>当一个主机下面挂了很多个 <strong>slave</strong>从机的时候，主机 <strong>master</strong> 挂了，这时 <strong>master</strong> 主机重启后，因为 <strong>runid</strong> 发生了变化，所有的 <strong>slave</strong> 从机都要做一次全量复制。这将引起单节点和单机器的复制风暴，开销会非常大。</p><p>解决：</p><ul><li>  可以采用树状结构降低多个从节点对主节点的消耗。</li><li>  从节点采用树状树非常有用，网络开销交给位于中间层的从节点，而不必消耗顶层的主节点。但是这种树状结构也带来了运维的复杂性，增加了手动和自动 处理故障转移的难度。</li></ul><p><img src="http://qiniu.gaobinzhan.com/2020/06/05/26dc39cb9dfe5.png"></p><h3 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h3><p>由于 <strong>Redis</strong> 的单线程架构，通常单台机器会部署多个 <strong>Redis</strong> 实例。当一台机器（<strong>machine</strong>）上同时部署多个主节点（<strong>master</strong>）时，如果每个 <strong>master</strong> 主机只有一台 <strong>slave</strong> 从机，那么当机器宕机以后，会产生大量全量复制。这种情况是非常危险的情况，带宽马上会被占用，会导致不可用。</p><p>解决：</p><ul><li>  应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</li><li>  当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li></ul><p><img src="http://qiniu.gaobinzhan.com/2020/06/05/4972dfad7a251.png"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>###########从库##############</p><p>#设置该数据库为其他数据库的从数据库</p><p><code>slaveof</code></p><p>#主从复制中，设置连接<strong>master</strong>服务器的密码（前提<strong>master</strong>启用了认证）</p><p><code>masterauth</code></p><p># 当从库同主库失去连接或者复制正在进行，从库有两种运行方式：</p><p># 1) 如果<code>slave-serve-stale-data</code>设置为<strong>yes</strong>(默认设置)，从库会继续相应客户端的请求</p><p># 2) 如果<code>slave-serve-stale-data</code>设置为<strong>no</strong>，除了<strong>INFO</strong>和<strong>SLAVOF</strong>命令之外的任何请求都会返回一个错误”<strong>SYNC with master in progress</strong>“</p><p><code>slave-serve-stale-data yes</code></p><p>#当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高</p><p><code>slave-priority 100</code></p><p>#从节点是否只读；默认<strong>yes</strong>只读，为了保持数据一致性，应保持默认。</p><p><code>slave-read-only yes</code></p><p>########主库配置##############</p><p>#在<strong>slave</strong>和<strong>master</strong>同步后（发送<strong>psync</strong>/<strong>sync</strong>），后续的同步是否设置成<strong>TCP_NODELAY</strong>假如设置成<strong>yes</strong>，则<strong>redis</strong>会合并小的<strong>TCP</strong>包从而节省带宽，但会增加同步延迟（40ms），造成<strong>master</strong>与<strong>slave</strong>数据不一致假如设置成<strong>no</strong>，则<strong>redis master</strong>会立即发送同步数据，没有延迟。</p><p>#前者关注性能，后者关注一致性</p><p><code>repl-disable-tcp-nodelay no</code></p><p>#从库会按照一个时间间隔向主库发送<strong>PING</strong>命令来判断主服务器是否在线，默认是10秒</p><p><code>repl-ping-slave-period 10</code></p><p>#复制积压缓冲区大小设置</p><p><code>repl-backlog-size 1mb</code></p><p>#<strong>master</strong>没有<strong>slave</strong>一段时间会释放复制缓冲区的内存，<code>repl-backlog-ttl</code>用来设置该时间长度。单位为秒。</p><p><code>repl-backlog-ttl 3600</code></p><p>#<strong>redis</strong>提供了可以让<strong>master</strong>停止写入的方式，如果配置了<code>min-slaves-to-write</code>，健康的<strong>slave</strong>的个数小于<strong>N</strong>，<strong>mater</strong>就禁止写入。<strong>master</strong>最少得有多少个健康的<strong>slave</strong>存活才能执行写命令。这个配置虽然不能保证<strong>N</strong>个<strong>slave</strong>都一定能接收到<strong>master</strong>的写操作，但是能避免没有足够健康的slave的时候，<strong>master</strong>不能写入来避免数据丢失。设置为0是关闭该功能。</p><p><code>min-slaves-to-write 3</code></p><p><code>min-slaves-max-lag 10</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Slaveof  &lt;code&gt;slaveof&lt;/code&gt;  &lt;strong&gt;slave&lt;/strong&gt;实例需要配置该项，指向&lt;strong&gt;master&lt;/strong&gt;的(ip,port)&lt;/li&gt;
&lt;li&gt;masterauth  &lt;code&gt;master</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go常见架构模式的实现</title>
    <link href="https://stitch.cn/2020/09/23/go%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://stitch.cn/2020/09/23/go%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0.html</id>
    <published>2020-09-23T09:21:33.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://qiniu.gaobinzhan.com/2020/05/31/b71e7f4c49b14.png"></p><p>Pipe-Filter 模式：</p><ul><li>  ⾮常适合与数据处理及数据分析系统</li><li>  Filter封装数据处理的功能</li><li>  Pipe⽤于连接Filter传递数据或者在异步处理过程中缓冲数据流</li><li>  进程内同步调⽤时，pipe演变为数据在⽅法调⽤间传递</li><li>  松耦合：Filter只跟数据（格式）耦合</li></ul><p>Filter和组合模式：</p><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/bcbb91db52add.png"></p><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/687b15a34e92d.png"></p><p>示例：</p><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/acf328995b547.png"></p><p>简单示例代码：</p><p><code>filter.go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Package pipefilter is to define the interfaces and the structures for pipe-filter style implementation</span><br><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">// Request is the input of the filter</span><br><span class="line">type Request interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Response is the output of the filter</span><br><span class="line">type Response interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Filter interface is the definition of the data processing components</span><br><span class="line">// Pipe-Filter structure</span><br><span class="line">type Filter interface &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>split_filter.go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var SplitFilterWrongFormatError = errors.New(&quot;input data should be string&quot;)</span><br><span class="line"></span><br><span class="line">type SplitFilter struct &#123;</span><br><span class="line">    delimiter string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSplitFilter(delimiter string) *SplitFilter &#123;</span><br><span class="line">    return &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sf *SplitFilter) Process(data Request) (Response, error) &#123;</span><br><span class="line">    str, ok := data.(string) //检查数据格式/类型，是否可以处理</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        return nil, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    return parts, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>split_filter_test.go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestStringSplit(t *testing.T) &#123;</span><br><span class="line">    sf := NewSplitFilter(&quot;,&quot;)</span><br><span class="line">    resp, err := sf.Process(&quot;1,2,3&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        t.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    parts, ok := resp.([]string)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        t.Fatalf(&quot;Repsonse type is %T, but the expected type is string&quot;, parts)</span><br><span class="line">    &#125;</span><br><span class="line">    if !reflect.DeepEqual(parts, []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;) &#123;</span><br><span class="line">        t.Errorf(&quot;Expected value is &#123;\&quot;1\&quot;,\&quot;2\&quot;,\&quot;3\&quot;&#125;, but actual is %v&quot;, parts)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestWrongInput(t *testing.T) &#123;</span><br><span class="line">    sf := NewSplitFilter(&quot;,&quot;)</span><br><span class="line">    _, err := sf.Process(123)</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        t.Fatal(&quot;An error is expected.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现micro-kernel-framework"><a href="#实现micro-kernel-framework" class="headerlink" title="实现micro-kernel framework"></a>实现micro-kernel framework</h2><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/33be429a34caa.png"></p><ul><li>特点</li><li>  要点</li><li>内核包含公共流程或通⽤逻辑</li><li>抽象扩展点⾏为，定义接⼝</li></ul><p>示例：</p><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/8cf1559e63e02.png"></p><p>简单示例代码：</p><p><code>agent.go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package microkernel</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Waiting = iota</span><br><span class="line">    Running</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var WrongStateError = errors.New(&quot;can not take the operation in the current state&quot;)</span><br><span class="line"></span><br><span class="line">type CollectorsError struct &#123;</span><br><span class="line">    CollectorErrors []error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ce CollectorsError) Error() string &#123;</span><br><span class="line">    var strs []string</span><br><span class="line">    for _, err := range ce.CollectorErrors &#123;</span><br><span class="line">        strs = append(strs, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    return strings.Join(strs, &quot;;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Event struct &#123;</span><br><span class="line">    Source  string</span><br><span class="line">    Content string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type EventReceiver interface &#123;</span><br><span class="line">    OnEvent(evt Event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Collector interface &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error</span><br><span class="line">    Start(agtCtx context.Context) error</span><br><span class="line">    Stop() error</span><br><span class="line">    Destory() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Agent struct &#123;</span><br><span class="line">    collectors map[string]Collector</span><br><span class="line">    evtBuf     chan Event</span><br><span class="line">    cancel     context.CancelFunc</span><br><span class="line">    ctx        context.Context</span><br><span class="line">    state      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (agt *Agent) EventProcessGroutine() &#123;</span><br><span class="line">    var evtSeg [10]Event</span><br><span class="line">    for &#123;</span><br><span class="line">        for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case evtSeg[i] =</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://qiniu.gaobinzhan.com/2020/05/31/b71e7f4c49b14.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Pipe-Filter 模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  ⾮常适合与数据处理及数据分析系统&lt;/li&gt;
&lt;li&gt;  Fi</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>消息中间件Kafka - PHP操作使用Kafka</title>
    <link href="https://stitch.cn/2020/09/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6kafka-php%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8kafka.html"/>
    <id>https://stitch.cn/2020/09/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6kafka-php%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8kafka.html</id>
    <published>2020-09-23T08:11:08.000Z</published>
    <updated>2021-10-01T03:05:23.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li>  博主： gaobinzhan</li><li>  发布时间：2019 年 03 月 21 日</li><li>  1366次浏览</li><li>  暂无评论</li><li>  1527字数</li><li>  分类： 消息中间件</li></ul><p>[TOC]</p><blockquote><p><strong>我们需要安装libkafka和rdkafka</strong></p></blockquote><h2 id="安装libkafka"><a href="#安装libkafka" class="headerlink" title="安装libkafka"></a>安装libkafka</h2><ol><li><strong>下载</strong> 去GitHub上克隆下来 <code>git clone https://github.com/edenhill/librdkafka.git</code></li><li><strong>安装</strong> <code>cd librdkafka/</code> <code>./configure &amp;&amp; make &amp;&amp; make install</code> 安装成功界面 没有报错就是安装成功 <img src="http://qiniu.gaobinzhan.com/2019/11/02/0afdf2be1eead.png"></li></ol><h2 id="安装rdkafka"><a href="#安装rdkafka" class="headerlink" title="安装rdkafka"></a>安装rdkafka</h2><ol><li><strong>下载</strong> <code>git clone https://github.com/arnaud-lb/php-rdkafka</code> <code>cd php-rdkafka/</code></li><li><strong>为php安装扩展</strong> 在php-rdkafka这个目录下 <code>phpize</code> 然后会生成源代码安装的脚本 把php-config的位置改成自己php-config的位置 <code>./configure --with-php-config=/usr/local/php/bin/php-config</code> 编译安装 <code>make &amp;&amp; make install</code> 成功后会出现一个文件夹 <img src="http://qiniu.gaobinzhan.com/2019/11/02/24854ed8d1d47.png"> 这个位置就是保存的我们刚刚安装的扩展 进入该目录 <code>cd /usr/local/php/lib/php/extensions/no-debug-non-zts-20170718/</code> 会发现出现个rdkafka.so文件<br> <img src="http://qiniu.gaobinzhan.com/2019/11/02/194c95c93593c.png"> 修改php.ini文件加入 这里的路径就是写自己rdkafka.so文件的路径 <code>extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20170718/rdkafka.so</code> 重启php <code>php-m</code> 出现rdkafka就是安装成功 <img src="http://qiniu.gaobinzhan.com/2019/11/02/402b89b50a15e.png"></li></ol><h2 id="php操作kafka"><a href="#php操作kafka" class="headerlink" title="php操作kafka"></a>php操作kafka</h2><blockquote><p><strong>运行前先开启我们的zookeeper和kafka 上篇文章有如何开启</strong></p></blockquote><ol><li><strong>运行producer</strong><br> kafka默认端口9092 <code>vim producer.php</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;  博主： gaobinzhan&lt;/li&gt;
&lt;li&gt;  发布时间：2019 年 03 月 21 日&lt;/li&gt;
&lt;li&gt;  1366次浏览&lt;/li&gt;
&lt;li&gt;  暂无评论&lt;/li&gt;
&lt;li&gt;  1527字数&lt;/li&gt;
&lt;li&gt;  分类： 消息中间件&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>redis哨兵故障转移及实现</title>
    <link href="https://stitch.cn/2020/09/23/redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://stitch.cn/2020/09/23/redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</id>
    <published>2020-09-23T08:06:04.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在上篇文章中docker-compose搭建redis-sentinel成功的搭建了1主2从3哨兵。</p></blockquote><p><strong>sentinel</strong>是一个特殊的<strong>redis</strong>节点，它有自己专属的<strong>api</strong>：</p><ul><li>  <code>sentinel masters</code> 显示被监控的所有<strong>master</strong>以及它们的状态。</li><li>  <code>sentinel master</code> 显示指定<strong>master</strong>的信息和状态。</li><li>  <code>sentinel slaves</code> 显示指定<strong>master</strong>的所有<strong>slave</strong>及它们的状态。</li><li>  <code>sentinel sentinels</code> 显示指定<strong>master</strong>的<strong>sentinel</strong>节点集合（不包含当前节点）。</li><li>  <code>sentinel get-master-addr-by-name</code> 返回指定<strong>master</strong>的<strong>ip</strong>和<strong>port</strong>，如果正在进行<strong>failover</strong>或者<strong>failover</strong>已经完成，将会显示被提升为<strong>master</strong>的<strong>slave</strong>的<strong>ip</strong>和<strong>port</strong>。</li><li>  <code>sentinel failover</code> 强制<strong>sentinel</strong>执行<strong>failover</strong>，并且不需要得到其它<strong>sentinel</strong>的同意。但是<strong>failover</strong>后会将最新的配置发送给其它<strong>sentinel</strong>。</li></ul><p><code>sentinel masters</code></p><p>展示所有被监控的主节点状态及相关信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel masters</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.2&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………………………</span><br></pre></td></tr></table></figure><p><code>sentinel master</code></p><p>展示指定状态以及相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel master mymaster</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;mymaster&quot;</span><br><span class="line"> 3) &quot;ip&quot;</span><br><span class="line"> 4) &quot;192.168.3.2&quot;</span><br><span class="line"> 5) &quot;port&quot;</span><br><span class="line"> 6) &quot;6379&quot;</span><br><span class="line"> ………………………………</span><br></pre></td></tr></table></figure><p><code>sentinel slaves</code></p><p>展示指定 的从节点状态以及相关的统计信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel slaves mymaster</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;192.168.3.4:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.4&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;192.168.3.3:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.3&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………</span><br></pre></td></tr></table></figure><p><code>sentinel sentinels</code></p><p>展示指定 的<strong>sentinel</strong>节点集合（不包含当前<strong>sentinel</strong>节点）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel sentinels mymaster</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;570de1d8085ec8bd7974431c01c589847c857edf&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.13&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;26379&quot;</span><br><span class="line">………………………………………………</span><br></pre></td></tr></table></figure><p><code>sentinel get-master-addr-by-name</code></p><p>获取主节点信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel get-master-addr-by-name mymaster</span><br><span class="line">1) &quot;192.168.3.2&quot;</span><br><span class="line">2) &quot;6379&quot;</span><br></pre></td></tr></table></figure><p><code>sentinel failover</code></p><p>对进行强制故障转移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel failover mymaster</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:26380&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.3.3:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><p>修改配置：</p><ul><li>  添加新的监听：<code>sentinel monitor test 127.0.0.1 6379 2</code></li><li>  放弃对某个<strong>master</strong>监听：<code>sentinel REMOVE test</code></li><li>  设置配置选项：<code>sentinel set failover-timeout mymaster 180000</code></li></ul><p><strong>Master</strong>可能会因为某些情况宕机了，如果客户端是固定一个地址去访问，肯定是不合理的，所以客户端请求是请求哨兵，从哨兵获取主机地址的信息，或者是从机的信息。可以实现一个例子：</p><ul><li>  随机选择一个哨兵连接，获取主机及从机信息。</li><li>  模拟客户端定时访问，实现简单轮询效果，轮询从节点。</li><li>  连接失败重试访问</li></ul><h2 id="Sentinel故障转移"><a href="#Sentinel故障转移" class="headerlink" title="Sentinel故障转移"></a>Sentinel故障转移</h2><p>执行<code>docker-composer up</code>之后<code>sentinel.conf</code>发生了变化，每个配置文件变化如下：</p><p><code>sentinel\conf\sentinel.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.12 26379 497f733919cb5d41651b4a2b5648c4adffae0a73</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.13 26379 0d0ee41bcb5d765e9ff78ed59de66be049a23a82</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p><code>sentine2\conf\sentinel.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.13 26379 0d0ee41bcb5d765e9ff78ed59de66be049a23a82</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.11 26379 f5f2a73dc0e60514e4f28c6f40517f48fa409eed</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p><code>sentine3\conf\sentinel.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.12 26379 497f733919cb5d41651b4a2b5648c4adffae0a73</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.11 26379 f5f2a73dc0e60514e4f28c6f40517f48fa409eed</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>从变化中可以看出每台<strong>Sentinel</strong>分别记录了<strong>slave</strong>的节点信息和其它<strong>Sentinel</strong>节点信息。</p><p>在宿主机中随便进入一台<strong>Sentinel</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel masters</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.2&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br></pre></td></tr></table></figure><p>可以观察到监听的所有<strong>master</strong>，将<strong>192.168.3.2</strong>这台<strong>master</strong>进行宕机</p><p><code>docker stop redis-master</code></p><p>宕机完之后等待<strong>Sentinel</strong>检测周期过了之后再对<code>sentinel.conf</code>和<code>redis.conf</code>进行观察。</p><p>3台<strong>Sentinel</strong>的<code>sentinel monitor mymaster 192.168.3.2 6379 2</code>变成了<code>sentinel monitor mymaster 192.168.3.4 6379 2</code></p><p>其次master对应的slave节点信息也进行更改。</p><p>而<strong>192.168.3.3</strong>的<code>redis.conf</code>中<code>replicaof 192.168.3.2 6379</code>也变成了<code>replicaof 192.168.3.4 6379</code>。</p><p><strong>192.168.3.2</strong>的<code>redis.conf</code>中<code>replicaof 192.168.3.2 6379</code>这行配置被删除掉了。</p><p>再次启动<strong>192.168.3.2</strong>的<strong>redis</strong>节点，而这台节点的<code>redis.conf</code>中增加了一行<code>replicaof 192.168.3.4 6379</code>。</p><p>其实就是将我们的操作自动化了。</p><h2 id="Sentinel实现原理"><a href="#Sentinel实现原理" class="headerlink" title="Sentinel实现原理"></a>Sentinel实现原理</h2><p><strong>Sentinel</strong>的实现原理，主要分为三个步骤：</p><ul><li>  检测问题：三个定时任务，这三个内部的执行任务可以保证出现问题马上让<strong>Sentinel</strong>知道。</li><li>  发现问题：主观下线和客观下线，当有一台<strong>Sentinel</strong>机器发现问题时，它就会对它主观下线。但是当多个<strong>Sentinel</strong>都发现问题的时候，才会出现客观下线。</li><li>  找到解决问题的<strong>Sentinel</strong>：进行领导者选举，如何在<strong>Sentinel</strong>内部多台节点做领导者选择。</li><li>  解决问题：就是要进行故障转移。</li></ul><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ul><li>每10s每个<strong>Sentinel</strong>对<strong>Master</strong>和<strong>Slave</strong>执行一次<code>Info Replication</code>。  <strong>Redis Sentinel</strong>可以对<strong>Redis</strong>节点做失败判断和故障转移，来<code>Info Replication</code>发现<strong>Slave</strong>节点，来确定主从关系。</li><li>每2s每个<strong>Sentinel</strong>通过<strong>Master</strong>节点的<strong>channel</strong>交换信息（pub/sub）。  类似于发布订阅，<strong>Sentinel</strong>会对主从关系进行判断，通过<code>__sentinel__:hello</code>频道交互。了解主从关系可以帮助更好的自动化操作<strong>Redis</strong>。然后<strong>Sentinel</strong>会告知系统消息给其它<strong>Sentinel</strong>节点，最终达到共识，同时<strong>Sentinel</strong>节点能够互相感知到对方。</li><li>每1s每个<strong>Sentinel</strong>对其它<strong>Sentinel</strong>和<strong>Redis</strong>执行<code>ping</code>。  对每个节点和其它<strong>Sentinel</strong>进行心跳检测，它是失败判断的依据。</li></ul><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>回顾上一篇文章中<strong>Sentinel</strong>的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.3.2 6379 2</span><br><span class="line">sentinel down-after-millseconds mymaster 30000</span><br></pre></td></tr></table></figure><p>主观下线：每个<strong>Sentinel</strong>节点对<strong>Redis</strong>失败的“偏见”。之所以是偏见，只是因为某一台机器30s内没有得到回复。</p><p>客观下线：这个时候需要所以<strong>Sentinel</strong>节点都发现它30s内无回复，才会达到共识。</p><h3 id="领导者选举方式"><a href="#领导者选举方式" class="headerlink" title="领导者选举方式"></a>领导者选举方式</h3><ul><li>  每个做主观下线的Sentinel节点，会像其它的<strong>Sentinel</strong>节点发送命令，要求将它设置成为领导者。</li><li>  收到命令的<strong>Sentinel</strong>节点，如果没有同意通过其它节点发送的命令，那么就会同意请求，否则就会拒绝。</li><li>  如果<strong>Sentinel</strong>节点发现自己的票数超过半数，同时也超过了<code>sentinel monitor mymaster 192.168.3.2 6379 2</code>超过2个的时候，就会成为领导者。</li><li>  进行故障转移操作。</li></ul><h3 id="如何选择“合适”的Slave节点"><a href="#如何选择“合适”的Slave节点" class="headerlink" title="如何选择“合适”的Slave节点"></a>如何选择“合适”的Slave节点</h3><p>​ <strong>Redis</strong>内部其实是有一个优先级配置的，在配置文件中<code>replica-priority</code>，这个参数是<strong>slave</strong>节点的优先级配置，如果存在则返回，如果不存在则继续。当上面这个优先级不满足的时候，<strong>Redis</strong>还会选择复制偏移量最大的<strong>Slave</strong>节点，如果存在则返回，如果不存在则继续。之所以选择偏移量最大，这是因为偏移量越小，和<strong>Master</strong>的数据越不接近，现在<strong>Master</strong>挂掉了，说明这个偏移量小的机器数据可能存在问题，这就是为什么选择偏移量最大的<strong>Slave</strong>的原因。如果发现偏移量都一样，这个时候 <strong>Redis</strong> 会默认选择 <strong>runid</strong> 最小的节点。</p><p>生产环境部署技巧：</p><ul><li><strong>Sentinel</strong>节点不应该部署在一台物理机器上。  这里特意强调物理机是因为一台物理机做成了若干虚拟机或者现今比较流行的容器，它们虽然有不同的<strong>IP</strong>地址，但实际上它们都是同一台物理机，同一台物理机意味着如果这台机器有什么硬件故障，所有的虚拟机都会受到影响，为了实现<strong>Sentinel</strong>节点集合真正的高可用，请勿将<strong>Sentinel</strong>节点部署在同一台物理机器上。</li><li>  部署至少三个且奇数个的<strong>Sentinel</strong>节点。通过增加<strong>Sentinel</strong>节点的个数提高对于故障判定的准确性，因为领导者选举需要至少一半加1个节点。</li></ul><h2 id="Sentinel常见问题"><a href="#Sentinel常见问题" class="headerlink" title="Sentinel常见问题"></a>Sentinel常见问题</h2><p>哨兵集群在发现<strong>master node</strong>挂掉后会进行故障转移，也就是启动其中一个<strong>slave node</strong>为<strong>master node</strong>。在这过程中，可能会导致数据丢失的情况。</p><ul><li>异步复制导致数据丢失  因为<strong>master-&gt;slave</strong>的复制是异步，所以有可能部分还没来得及复制到<strong>slave</strong>就宕机了，此时这些部分数据就丢失了。</li><li>集群脑裂导致数据丢失  脑裂，也就是说。某个<strong>master</strong>所在机器突然脱离了正常的网络，跟其它<strong>slave</strong>机器不能连接，但是实际上<strong>master</strong>还运行着。</li></ul><p>造成的问题：</p><p>​ 此时哨兵可能就会认为<strong>master</strong>宕机了，然后开始选举，将其它<strong>slave</strong>切换成<strong>master</strong>。这时候集群里就会有2个<strong>master</strong>，也就是所谓的脑裂。此时虽然某个<strong>slave</strong>被切换成<strong>master</strong>，但是可能<strong>client</strong>还没来得及切换成新的<strong>master</strong>，还继续写向旧的<strong>master</strong>的数据可能就丢失了。因此旧<strong>master</strong>再次被恢复的时候，会被作为一个<strong>slave</strong>挂到新的<strong>master</strong>上去，自己的数据会被清空，重新从新的<strong>master</strong>复制数据。</p><p>怎么解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>要求至少有一个<strong>slave</strong>，数据复制和同步的延迟不能超过10s。</p><p>如果说一旦所有的<strong>slave</strong>，数据复制和同步的延迟都超过了10s，这个时候，<strong>master</strong>就不会再接收任何请求了。</p><p>上面两个配置可以减少异步复制和脑裂导致的数据丢失。</p><p>异步复制导致的数据丢失：</p><p>​ 在异步复制的过程当中，通过<code>min-slaves-max-lag</code>这个配置，就可以确保的说，一旦<strong>slave</strong>复制数据和<strong>ack</strong>延迟时间太长，就认为可能<strong>master</strong>宕机后损失的数据太多了，那么就拒绝写请求，这样就可以把<strong>master</strong>宕机时由于部分数据未同步到<strong>slave</strong>导致的数据丢失降低到可控范围内。</p><p>集群脑裂导致的数据丢失：</p><p>​ 集群脑裂因为<strong>client</strong>还没来得及切换成新的<strong>master</strong>，还继续写向旧的master的数据可能就丢失了通过<code>min-slaves-to-write</code>确保必须是有多少个从节点连接，并且延迟时间小于<code>min-slaves-max-lag</code>多少秒。</p><p>客户端需要怎么做：</p><p>​ 对于<strong>client</strong>来讲，就需要做些处理，比如先将数据缓存到内存当中，然后过一段时间处理，或者连接失败，接收到错误切换新的<strong>master</strong>处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在上篇文章中docker-compose搭建redis-sentinel成功的搭建了1主2从3哨兵。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;sentinel&lt;/strong&gt;是一个特殊的&lt;strong&gt;redis&lt;/strong</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>redis持久化rdb及aof</title>
    <link href="https://stitch.cn/2020/09/23/redis%E6%8C%81%E4%B9%85%E5%8C%96rdb%E5%8F%8Aaof.html"/>
    <id>https://stitch.cn/2020/09/23/redis%E6%8C%81%E4%B9%85%E5%8C%96rdb%E5%8F%8Aaof.html</id>
    <published>2020-09-23T07:45:39.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>​ 持久化的功能：<strong>Redis</strong>是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将<strong>Redis</strong>中的数据以某种形式（数据或命令）从内存保存到硬盘中。当下次<strong>Redis</strong>重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。<strong>Redis</strong>持久化分为<strong>RDB</strong>和<strong>AOF</strong>，前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存的硬盘。</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>​ <strong>RDB</strong>是一种快照存储持久方式，具体就是将<strong>Redis</strong>某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为<strong>dump.rdb</strong>，而在Redis服务器启动时，会重新加载<strong>dump.rdb</strong>文件的数据到内存当中恢复数据。触发<strong>RDB</strong>持久化过程分为手动触发和自动触发。</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><p>手动触发分别对应<code>save</code>和<code>bgsave</code>命令：</p><p><code>save</code>命令：阻塞当前<strong>Redis</strong>服务器，直到<strong>RDB</strong>过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</p><p><code>bgsave</code>命令：<strong>Redis</strong>进程执行<strong>fork</strong>操作创建子进程，<strong>RDB</strong>持久化过程由子进程负责，完成后自动结束。阻塞只发生在<strong>fork</strong>阶段，一般时间很短。</p><p>显示<code>bgsave</code>命令是针对<code>save</code>阻塞问题做的优化。因此<strong>Redis</strong>内部所有的涉及<strong>RDB</strong>的操作都采用<code>bgsave</code>的方式。</p><p>除了执行命令手动触发之外，<strong>Redis</strong>内部还存在自动触发<strong>RDB</strong>的持久化机制，例如以下场景：</p><ul><li>  使用<code>save</code>相关配置，如<code>save m n</code>。表示<strong>m</strong>秒内数据集存在<strong>n</strong>次修改时，自动触发<code>bgsave</code>。</li><li>  如果从节点执行全量复制操作，主节点自动执行<code>bgsave</code>生成<strong>RDB</strong>文件并发送给从节点。</li><li>  执行<code>debug reload</code>命令重载<strong>Redis</strong>时，也会自动触发<code>save</code>操作。</li><li>  默认情况下执行<code>shutdown</code>命令时，如果没有开启<strong>AOF</strong>持久化功能则自动执行<code>bgsave</code>。</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><code>bgsave</code>是主流的触发<strong>RDB</strong>持久化方式：</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/06/83dd261b57178.png"></p><ul><li>  执行<code>bgsave</code>命令，<strong>Redis</strong>父进程判断当前是否存在正在执行的子进程，如<strong>RDB/AOF</strong>子进程，如果存在<code>bgsave</code>命令直接返回。</li><li>  父进程执行<strong>fork</strong>操作创建子进程，<strong>fork</strong>操作过程中父进程会阻塞，通过<code>info stats</code>命令查看<code>latest_fork_usec</code>选项，可以获得最近一个<strong>fork</strong>操作的耗时，单位为微妙。</li><li>  父进程<strong>fork</strong>完成后，<code>bgsave</code>命令返回<strong>Background saving started</strong>信息并不再阻塞父进程，可以继续响应其它命令。</li><li>  子进程创建<strong>RDB</strong>文件，根据父进程内存生成临时快照文件，完成后原有文件进行原子替换。执行<code>lastsave</code>命令可以获取最后一次生成<strong>RDB</strong>的时间，对应<code>info</code>统计的<code>rdb_last_save_time</code>选项。</li><li>  进程发送信号给父进程表示完成，父进程更新统计信息，具体见<code>info Persistence</code>下的<code>rdb_*</code>相关选项。</li></ul><h3 id="服务器配置自动触发"><a href="#服务器配置自动触发" class="headerlink" title="服务器配置自动触发"></a>服务器配置自动触发</h3><p>​ 除了通过客户端发送命令外，还有一种方式，就是在<strong>Redis</strong>配置文件中的<code>save</code>指定到达触发<strong>RDB</strong>持久化的条件，比如【多少秒内至少达到多少写操作】就开启<strong>RDB</strong>数据同步。</p><p>例如我们可以在配置文件<strong>redis.conf</strong>指定如下的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 900s内至少达到1条写命令</span><br><span class="line">save 900 1</span><br><span class="line"># 300s内至少达到10条写命令</span><br><span class="line">save 300 10</span><br><span class="line"># 60s内至少达到1000条写命令</span><br><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><p>这种通过服务器配置文件触发<strong>RDB</strong>的方式，与<code>bgsave</code>命令类似，达到触发条件时，会<strong>fork</strong>一个子进程进行数据同步，不过最好不要通过这种方式来触发<strong>RDB</strong>持久化，因为设置触发的时间太短，则容易频繁写入<strong>rdb</strong>文件，影响服务器性能，时间设置太长会造成数据丢失。</p><h3 id="RDB文件的处理"><a href="#RDB文件的处理" class="headerlink" title="RDB文件的处理"></a>RDB文件的处理</h3><p>保存：</p><ul><li>  <strong>RDB</strong>文件保存在<strong>dir</strong>配置指定的目录下，文件名通过<strong>dbfilename</strong>配置指定。可通过执行<code>config set dir &#123;newDir&#125;</code>和<code>config set dbfilename &#123;newFileName&#125;</code>运行期动态执行，当下次运行时RDB文件会保存到新目录。</li></ul><p>压缩：</p><ul><li>  <strong>Redis</strong>默认采用<strong>LZF</strong>算法对生存的<strong>RDB</strong>文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数<code>config set rdbcompression &#123;yesno&#125;</code>动态修改。</li><li>  虽然压缩<strong>RDB</strong>会消耗<strong>CPU</strong>，但可大幅度降低文件的体积，方便保存到硬盘或通过网络发送给从节点，因此线上建议开启。</li></ul><h3 id="RDB方式的优缺点"><a href="#RDB方式的优缺点" class="headerlink" title="RDB方式的优缺点"></a>RDB方式的优缺点</h3><p>优点：</p><ul><li>  <strong>RDB</strong>是一个非常紧凑的文件，它保存了<strong>Redis</strong>在某个时间点上的数据集。这种文件非常适合用于备份；比如说，你可以在最近的24小时内，每小时备份一次<strong>RDB</strong>文件，并且在每个月的每一天，也备份一个<strong>RDB</strong>文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>  <strong>RDB</strong>可以最大化<strong>Redis</strong>的性能；父进程在保存<strong>RDB</strong>文件时唯一要做的就是<strong>fork</strong>出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无需执行任何磁盘<strong>I/O</strong>操作。</li><li>  <strong>RDB</strong>在恢复大数据集时的速度要比<strong>AOF</strong>的恢复速度快。</li></ul><p>缺点：</p><ul><li>  <strong>RDB</strong>方式数据没办法做到实时持久化/秒级持久化。如果服务器宕机的话，采用<strong>RDB</strong>的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或者5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>  使用<code>bgsave</code>命令在<strong>fork</strong>子进程时，如果数据量太大，fork的过程也会发生阻塞，另外，<strong>fork</strong>子进程会消耗内存。针对<strong>RDB</strong>不适合做实时持久化的问题，<strong>Redis</strong>提供了<strong>AOF</strong>持久化方式来解决。</li></ul><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>​ <strong>AOF</strong>（append only file）持久化；与<strong>RDB</strong>存储某个时刻的快照不同，<strong>AOF</strong>持久化方式会记录客户端对服务器的每一次写操作命令到日志当中，并将这些操作以<strong>Redis</strong>协议追加保存到以后缀为<strong>aof</strong>文件末尾。</p><h3 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h3><p>​ 开启AOF功能需要设置配置；<code>appendonly yes</code>，默认不开启。<strong>AOF</strong>文件名通过<code>appendfilename</code>配置设置，默认文件名是<strong>appendonly.aof</strong>。保存路径同RDB持久化方式一致，通过dir配置指定。</p><h3 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes #启用aof持久化方式</span><br><span class="line">appendfsync always #每次收到命令就立即强制写入磁盘，最慢的大概只有几百的TPS，但是保证完全的持久化，不推荐使用</span><br><span class="line">appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐</span><br><span class="line">appendfsync no #完全依赖os，性能最好，持久化没保证，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切完全依赖于操作系统的调试了。对于大多数Linux操作系统，是每30s进行一次fsync，将缓冲区中的数据写的磁盘上。</span><br></pre></td></tr></table></figure><h3 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="http://qiniu.gaobinzhan.com/2020/06/07/42bd8316078e8.png"></p><ul><li>  所以的写入命令会追加到<strong>aof_buf</strong>（缓冲区）中。</li><li>  <strong>AOF</strong>缓冲区根据对应的策略向硬盘做同步操作。</li><li>  随着<strong>AOF</strong>文件越来越大，需要定期对<strong>AOF</strong>文件进行重写，达到压缩的目的。</li><li>  当<strong>Redis</strong>服务器重启时，可以加载<strong>AOF</strong>文件进行数据恢复。</li></ul><blockquote><p>在同步期间可能会发生阻塞问题</p></blockquote><p><img src="http://qiniu.gaobinzhan.com/2020/06/07/29fb2a1372aaa.png"></p><ul><li>  若果<strong>AOF</strong>文件<strong>fsync</strong>同步时间大于<strong>2s</strong>，<strong>Redis</strong>主进程就会阻塞。</li><li>  若果<strong>AOF</strong>文件<strong>fsync</strong>同步时间小于<strong>2s</strong>，<strong>Redis</strong>主进程就会返回。</li></ul><p>其实这样做是为了保证文件安全性的一种策略。</p><p><strong>AOF</strong>追加阻塞会产生的问题：</p><ul><li>  <strong>fsync</strong>大于<strong>2s</strong>时候，会阻塞<strong>redis</strong>主进程，我们都知道<strong>redis</strong>主进程是用来执行<strong>redis</strong>命令的，是不能阻塞的。</li><li>  虽然每秒<strong>everysec</strong>刷盘策略，但是实际上不是丢失<strong>1s</strong>数据，实际有可能丢失<strong>2s</strong>数据。</li></ul><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><ul><li>  <strong>AOF</strong>将客户端的每一个写操作都追加到<strong>aof</strong>文件末尾，随着命令不断写入<strong>AOF</strong>，文件会越来越大，为了解决这个问题，<strong>Redis</strong>引入<strong>AOF</strong>重写机制压缩文件体积。</li><li><strong>AOF</strong>文件重写是吧Redis进程内的数据转化为写命令同步到新AOF<strong>文件的过程</strong>。  比如：多条命令可以合并为一个，<code>lpush list a、lpush list b</code>可以转化为<code>lpush list a b</code>。</li><li>  <strong>AOF</strong>重写降低了文件占用空间，除此之外，另一个目的是：更小的<strong>AOF</strong>文件可以更快地被加载。</li></ul><p>触发机制：</p><p><strong>AOF</strong>重写过程可以手动触发和自动触发：</p><ul><li>  手动触发：直接调用<code>bgrewriteaof</code>命令。</li><li>自动触发：根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发。<ul><li>  <code>auto-aof-rewrite-min-size</code>表示运行<strong>AOF</strong>重写时文件最小体积，默认为<strong>64MB</strong>。</li><li>  <code>auto-aof-rewrite-percentage</code>代表当前<strong>AOF</strong>文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</li></ul></li><li>示例：<ul><li>  <code>auto-aof-rewrite-percentage：100</code></li><li>  <code>auto-aof-rewrite-min-size：64mb</code></li></ul></li><li>  默认配置时当<strong>AOF</strong>文件大小是上次<strong>rewrite</strong>后大小的一倍且文件大于<strong>64mb</strong>时触发。</li></ul><p>当触发AOF重写时，内部流程：</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/07/7548fdf5a9cfd.png"></p><p>执行<strong>AOF</strong>重写请求。如果当前进程正在执行<strong>AOF</strong>重写，请求不执行并返回如下响应：<strong>ERR Background append only file rewriting already in progress</strong></p><ul><li>父进程执行<strong>fork</strong>创建子进程，开销等同于<strong>bgsave</strong>过程。<ul><li>  主进程<strong>fork</strong>操作完成后，继续响应其它命令。所以修改命令依然写入<strong>AOF</strong>缓冲区并根据<code>appendfsync</code>策略同步到硬盘，保证原有<strong>AOF</strong>机制正确性。</li><li>  由于<strong>fork</strong>操作运用写时复制技术，子进程只能共享<strong>fork</strong>操作时的内存数据。由于父进程依然响应命令，Redis使用<strong>AOF</strong>重写缓冲区保存这部分新数据，防止新<strong>AOF</strong>文件生成期间丢失这部分数据。</li></ul></li><li>子进程根据内存快照，按照命令合并规则写入新的<strong>AOF</strong>文件，每次批量写入硬盘数据量由配置<code>aof-rewrite-incremental-fsync</code>控制，默认为<strong>32MB</strong>，防止单词刷盘数据过多造成硬盘阻塞。<ul><li>  新<strong>AOF</strong>文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见<code>info persistence</code>的<strong>aof_</strong>*相关统计。</li><li>  父进程把<strong>AOF</strong>重写缓冲区的数据写入到新的AOF文件。</li><li>  使用新<strong>AOF</strong>文件替换老文件，完成<strong>AOF</strong>重写。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>​ 在写入<strong>AOF</strong>日志文件时，如果<strong>Redis</strong>服务器宕机，则<strong>aof</strong>日志文件会出现格式错误，在重启<strong>Redis</strong>服务器时，<strong>Redis</strong>服务器会拒绝载入这个<strong>aof</strong>文件，可以通过命令修复<strong>aof</strong>并恢复数据。</p><p><code>redid-check-aof -fix appendonly.aof</code></p><h3 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h3><p>优点：</p><ul><li>  <strong>AOF</strong>可以设置完全不同步、每秒同步、每次操作同步，默认时每秒同步。因为<strong>AOF</strong>时操作指令的追加，所以可以频繁的大量的同步。</li><li>  <strong>AOF</strong>文件是一个值追加日志的文件，即使服务宕机为写入完整的命令，也可以通过<strong>redis-check-aof</strong>工具修复这些问题。</li><li>  如果<strong>AOF</strong>文件过大，<strong>Redis</strong>会在后台自动地重写<strong>AOF</strong>文件。重写后会使<strong>AOF</strong>文件压缩到最小所需的指令集。</li><li>  <strong>AOF</strong>文件是有序保存数据看的所有写入操作，易读，易分析。即使如果不小心误操作数据看，也很容易找出业务错误指令，恢复到某个数据节点。例如不小<code>FLUSHALL</code>，可以非常容易恢复到执行命令之前。</li></ul><p>缺点：</p><ul><li>  相同数据量下，<strong>AOF</strong>的文件通常体积会比RDB大。因为<strong>AOF</strong>是存指令的，而RDB是所有指令的结果快照。但<strong>AOF</strong>在日志重写后会压缩一些空间。</li><li>  在大量写入和载入的时候，<strong>AOF</strong>的效率会比<strong>RDB</strong>低，因为大量写入，<strong>AOF</strong>会执行更多的保存命令，载入的时候也需要大量的重执行命令来得到最后的结果。<strong>RDB</strong>对此更有优势。</li></ul><h3 id="AOF常用配置"><a href="#AOF常用配置" class="headerlink" title="AOF常用配置"></a>AOF常用配置</h3><p><code>appendonly no</code>：是否开启<strong>AOF</strong></p><p><code>appendfilename &quot;appendonly.aof&quot;</code>：<strong>AOF</strong>文件名</p><p><code>dir ./</code>：<strong>RDB</strong>文件和<strong>AOF</strong>文件所在目录</p><p><code>appendfsync everysec</code>：fsync持久化策略</p><p><code>no-appendfsync-on-rewrite no</code>：<strong>AOF</strong>重写期间是否禁止<strong>fsync</strong>；如果开启该选项，可以减轻文件重写时<strong>CPU</strong>和硬盘的负载（尤其是硬盘），但是可能会丢失<strong>AOF</strong>重写期间的数据；需要在负载和安全性之间进行平衡</p><p><code>auto-aof-rewrite-percentage 100</code>：文件重写触发条件之一</p><p><code>auto-aof-rewrite-min-size 64mb</code>：文件重写触发提交之一</p><p><code>aof-load-truncated yes</code>：如果<strong>AOF</strong>文件结尾损坏，<strong>Redis</strong>启动时是否仍载入<strong>AOF</strong>文件</p><h2 id="重启加载的选择"><a href="#重启加载的选择" class="headerlink" title="重启加载的选择"></a>重启加载的选择</h2><p><strong>AOF</strong>和<strong>RDB</strong>文件都可以用于服务器重启时的数据恢复。</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/07/8836e280f5a12.png"></p><h2 id="持久化的选择"><a href="#持久化的选择" class="headerlink" title="持久化的选择"></a>持久化的选择</h2><p>​ 在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用<strong>RDB</strong>或<strong>AOF</strong>的一种，或同时开启<strong>RDB</strong>和AOF<strong>持久化等</strong>。</p><p>​ 此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机<strong>master</strong>和从机<strong>slave</strong>可以独立的选择持久化方案。</p><p>面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p><ul><li>  如果<strong>Redis</strong>中的数据完全丢弃也没有关系（如<strong>Redis</strong>完全用作<strong>DB</strong>层数据的<strong>cache</strong>），那么无论是单机，还是主从架构，都可以不进行任何持久化。</li><li>  在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择<strong>RDB</strong>对<strong>Redis</strong>的性能更加有利；如果只能接受秒级别的数据丢失，应该选择<strong>AOF</strong>。</li><li>但在多数情况下，我们都会配置主从环境，<strong>slave</strong>的存在既可以实现数据的热备，也可以进行读写分离分担<strong>Redis</strong>读请求，以及在<strong>master</strong>宕掉后继续提供服务。在这种情况下的做法是：<ul><li>  <strong>master</strong>：完全关闭持久化（包括<strong>RDB</strong>和<strong>AOF</strong>），这样可以让master的性能达到最好；</li><li>  slave：关闭<strong>RDB</strong>，开启<strong>AOF</strong>（如果对数据安全要求不高，开启<strong>RDB</strong>关闭<strong>AOF</strong>也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭<strong>AOF</strong>的自动重写，然后添加定时任务，在每天<strong>Redis</strong>闲时（如凌晨12点）调用<code>bgrewriteaof</code>。</li><li>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：<ul><li>  <strong>master</strong>和<strong>slave</strong>进程同时停止：考虑这样一种场景，如果<strong>master</strong>和<strong>slave</strong>在同一个机房，则一次停电事故就可能导致<strong>master</strong>和<strong>slave</strong>机器同时关机，<strong>Redis</strong>进程停止；如果没有持久化，则面临的是数据的完全丢失。</li><li>  <strong>master</strong>误重启：考虑这样一种场景，<strong>master</strong>服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将<strong>master</strong>自动重启，由于没有持久化文件，那么<strong>master</strong>重启后数据是空的，<strong>slave</strong>同步数据也变成了空的；如果<strong>master</strong>和<strong>slave</strong>都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵进行自动的主从切换，也有可能在哨兵轮询到<strong>master</strong>之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。</li></ul></li></ul></li><li>异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。<ul><li>  例如对于单机的情形，可以定时将<strong>RDB</strong>文件或重写后的<strong>AOF</strong>文件，通过<strong>scp</strong>拷贝到远程机器，如阿里云；对于主从的情形，可以定时在<strong>master</strong>上执行<code>bgsave</code>，然后将<strong>RDB</strong>文件拷贝到远程机器，或者在<strong>slave</strong>上执行<code>bgrewriteaof</code>重写<strong>AOF</strong>文件后，将<strong>AOF</strong>文件拷贝到远程机器上。</li><li>  一般来说，由于<strong>RDB</strong>文件文件小、恢复快，因此灾难恢复常用<strong>RDB</strong>文件；异地备份的频率根据数据安全性的需要及其它条件来确定，但最好不要低于一 天一次。</li></ul></li></ul><h2 id="持久化配置方案"><a href="#持久化配置方案" class="headerlink" title="持久化配置方案"></a>持久化配置方案</h2><ul><li>企业级的持久化的配置策略<ul><li>  <code>save 60 10000</code>：如果你希望尽可能确保说，<strong>RDB</strong>最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，低峰期，数据量很少，也没必要 10000-&gt;生成RDB，1000-&gt;RDB，这个根据你自己的应用和业务的数据量，自己去决定</li><li>  <strong>AOF</strong>一定要打开。</li><li>  <code>auto-aof-rewrite-percentage 100</code>: 就是当前<strong>AOF</strong>大小膨胀到超过上次**100%**，上次的两倍</li><li>  <code>auto-aof-rewrite-min-size 64mb</code>: 根据你的数据量来定，<strong>16mb</strong>，<strong>32mb</strong></li></ul></li><li>数据备份方案 <strong>RDB</strong>非常适合做冷备，每次生成之后，就不会再有修改了<ul><li>  写<strong>crontab</strong>定时调度脚本去做数据备份</li><li>  每小时都<strong>copy</strong>一份<strong>rdb</strong>的备份，到一个目录中去，仅仅保留最近<strong>48</strong>小时的备份</li><li>  每天都保留一份当日的<strong>rdb</strong>的备份，到一个目录中去，仅仅保留最近<strong>1</strong>个月的备份</li><li>  每次<strong>copy</strong>备份的时候，都把太旧的备份给删了</li><li>  每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去【crontab】</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​ 持久化的功能：&lt;strong&gt;Redis&lt;/strong&gt;是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将&lt;strong&gt;Redis&lt;/strong&gt;中的数据以某种形式（数据或命令）从内存保存到硬盘中。当下次&lt;strong&gt;Redis&lt;</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go单元测试及Benchmark</title>
    <link href="https://stitch.cn/2020/09/23/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8Abenchmark.html"/>
    <id>https://stitch.cn/2020/09/23/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8Abenchmark.html</id>
    <published>2020-09-23T07:30:04.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>之前在刚开始写了如何编写测试程序。</p><p>内置单元测试框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func TestErrorInCode(t *testing.T) &#123;</span><br><span class="line">    fmt.Println(&quot;Start&quot;)</span><br><span class="line">    t.Error(&quot;Error&quot;)</span><br><span class="line">    fmt.Println(&quot;End&quot;)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestErrorInCode</span><br><span class="line">    Start</span><br><span class="line">        TestErrorInCode: functions_test.go:25: Error</span><br><span class="line">    End</span><br><span class="line">    --- FAIL: TestErrorInCode (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFatalInCode(t *testing.T) &#123;</span><br><span class="line">    fmt.Println(&quot;Start&quot;)</span><br><span class="line">    t.Fatal(&quot;Error&quot;)</span><br><span class="line">    fmt.Println(&quot;End&quot;)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestFatalInCode</span><br><span class="line">    Start</span><br><span class="line">        TestFatalInCode: functions_test.go:38: Error</span><br><span class="line">    --- FAIL: TestFatalInCode (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用断言：</p><p><code>go get -u github.com/stretchr/testify</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func square(op int) int &#123;</span><br><span class="line">    return op * op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestSquareWithAssert(t *testing.T) &#123;</span><br><span class="line">    inputs := [...]int&#123;1, 2, 3&#125;</span><br><span class="line">    expected := [...]int&#123;1, 4, 9&#125;</span><br><span class="line">    for i := 0; i &lt; len(inputs); i++ &#123;</span><br><span class="line">        ret := square(inputs[i])</span><br><span class="line">        assert.Equal(t, expected[i], ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h2><p>文件名以下划线<code>_benchmark</code>结尾，方法名以<code>Benchmark</code>开头，参数为<code>b *testing.B</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 利用+=连接</span><br><span class="line">func TestConcatStringByAdd(t *testing.T) &#123;</span><br><span class="line">    assert := assert.New(t)</span><br><span class="line">    elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    for _, elem := range elems &#123;</span><br><span class="line">        ret += elem</span><br><span class="line">    &#125;</span><br><span class="line">    assert.Equal(&quot;12345&quot;, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用buffer连接</span><br><span class="line">func TestConcatStringBytesBuffer(t *testing.T) &#123;</span><br><span class="line">    assert := assert.New(t)</span><br><span class="line">    var buf bytes.Buffer</span><br><span class="line">    elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">    for _, elem := range elems &#123;</span><br><span class="line">        buf.WriteString(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    assert.Equal(&quot;12345&quot;, buf.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkConcatStringByAdd(b *testing.B) &#123;</span><br><span class="line">    elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        ret := &quot;&quot;</span><br><span class="line">        for _, elem := range elems &#123;</span><br><span class="line">            ret += elem</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkConcatStringBytesBuffer(b *testing.B) &#123;</span><br><span class="line">    elems := []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        var buf bytes.Buffer</span><br><span class="line">        for _, elem := range elems &#123;</span><br><span class="line">            buf.WriteString(elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入 <code>go test -bench=. -benchmem</code></p><p>Windows 下使⽤ go test 命令⾏时，-bench=.应写为-bench=”.”</p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go test -bench=. -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: eighteen/benchmark</span><br><span class="line">BenchmarkConcatStringByAdd-8             8982729               130 ns/op              16 B/op          4 allocs/op</span><br><span class="line">BenchmarkConcatStringBytesBuffer-8      17703706                64.9 ns/op            64 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      eighteen/benchmark      2.532s</span><br></pre></td></tr></table></figure><p>使用 <code>buffer</code> 连接字符串的性能比 <code>+=</code> 要好很多。</p><h2 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h2><p>BDD in Go：</p><p>项⽬⽹站 ：</p><p><a href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a></p><p>安装：</p><p><code>go get -u github.com/smartystreets/goconvey/convey</code></p><p>启动 WEB UI ：</p><p><code>$GOPATH/bin/goconvey</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestSpec(t *testing.T) &#123;</span><br><span class="line">    convey.Convey(&quot;Given 2 even numbers&quot;, t, func() &#123;</span><br><span class="line">        a := 2</span><br><span class="line">        b := 4</span><br><span class="line">        convey.Convey(&quot;When add the two numbers&quot;, func() &#123;</span><br><span class="line">            c := a + b</span><br><span class="line">            convey.Convey(&quot;Then the result is still even&quot;, func() &#123;</span><br><span class="line">                convey.So(c%2, convey.ShouldEqual, 0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v  bdd_spec_test.go </span><br><span class="line">=== RUN   TestSpec</span><br><span class="line"></span><br><span class="line">  Given 2 even numbers </span><br><span class="line">    When add the two numbers </span><br><span class="line">      Then the result is still even ✔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 total assertion</span><br><span class="line"></span><br><span class="line">--- PASS: TestSpec (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.006s</span><br></pre></td></tr></table></figure><p>可以看到最后一步为 ✔</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在刚开始写了如何编写测试程序。&lt;/p&gt;
&lt;p&gt;内置单元测试框架：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>php yield关键字及协程实现</title>
    <link href="https://stitch.cn/2020/09/23/php-yield%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://stitch.cn/2020/09/23/php-yield%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0.html</id>
    <published>2020-09-23T07:16:51.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>迭代是指反复执行一个过程，每执行一次叫做迭代一次</p></blockquote><p>php提供了统一的迭代器接口，之前文章我已经写过了。传送门</p><p>通过实现<code>Iterator</code>接口，可以自行决定如何遍历。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>相比迭代器，生成器提供了更容易的方法来简单实现对象的迭代，性能开销和复杂性大大降低。</p></blockquote><p>一个生成器函数看起来更像一个普通的函数，不同的是普通函数返回的是一个值，而生成器可以<code>yield</code>生成许多个值。</p><p>生成器<code>yield</code>关键字不是返回值，而是返回<code>Generator</code>对象，不能被实力化，且继承了<code>Iterator</code>接口。</p><p>生成器优点：</p><ul><li>  生成器会对php应用的性能有非常大的影响。</li><li>  代码运行时，节省大量内存。</li><li>  适合计算大量的数据。</li></ul><h2 id="颠覆常识的yield"><a href="#颠覆常识的yield" class="headerlink" title="颠覆常识的yield"></a>颠覆常识的yield</h2><p>大家都知道<code>range</code>函数创建一个包含指定范围的元素的数组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;迭代是指反复执行一个过程，每执行一次叫做迭代一次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;php提供了统一的迭代器接口，之前文章我已经写过了。传送门&lt;/p&gt;
&lt;p&gt;通过实现&lt;code&gt;Iterator&lt;/code&gt;接口，可以自行决定如何遍历。&lt;/</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go反射编程</title>
    <link href="https://stitch.cn/2020/09/23/go%E5%8F%8D%E5%B0%84%E7%BC%96%E7%A8%8B.html"/>
    <id>https://stitch.cn/2020/09/23/go%E5%8F%8D%E5%B0%84%E7%BC%96%E7%A8%8B.html</id>
    <published>2020-09-23T07:05:18.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>reflect.TypeOf vs. reflect.ValueOf：</p><ul><li>  reflflect.TypeOf 返回类型 (reflflect.Type)</li><li>  reflflect.ValueOf 返回值 (reflflect.Value)</li><li>  可以从 reflflect.Value 获得类型</li><li>  通过 kind 的来判断类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func CheckType(v interface&#123;&#125;) &#123;</span><br><span class="line">    t := reflect.TypeOf(v)</span><br><span class="line">    switch t.Kind() &#123;</span><br><span class="line">    case reflect.Float32, reflect.Float64:</span><br><span class="line">        fmt.Println(&quot;Float&quot;)</span><br><span class="line">    case reflect.Int, reflect.Int32, reflect.Int64:</span><br><span class="line">        fmt.Println(&quot;Integer&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;Unknown&quot;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestBasicType(t *testing.T) &#123;</span><br><span class="line">    var f float64 = 12</span><br><span class="line">    CheckType(f)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestBasicType</span><br><span class="line">    Float</span><br><span class="line">    --- PASS: TestBasicType (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射编写灵活的代码：</p><ul><li>按名字访问结构的成员  <code>reflect.ValueOf(*e).FieldByName(&quot;Name&quot;)</code></li><li>按名字访问结构的方法  <code>reflect.ValueOf(*e).MethodByName(&quot;UpdateAge&quot;).Call([]reflect.Value&#123;reflect.ValueOf(1)&#125;)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Employee struct &#123;</span><br><span class="line">    EmployeeId string</span><br><span class="line">    Name       string `format:&quot;normal&quot;`</span><br><span class="line">    Age        int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *Employee) UpdateAge(newVal int) &#123;</span><br><span class="line">    e.Age = newVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestInvokeByName(t *testing.T) &#123;</span><br><span class="line">    e := &amp;Employee&#123;&quot;1&quot;, &quot;Mike&quot;, 30&#125;</span><br><span class="line">    // 按名字获取成员</span><br><span class="line">    t.Logf(&quot;Name：value(%[1]v)，Type(%[1]T)&quot;, reflect.ValueOf(*e).FieldByName(&quot;Name&quot;))</span><br><span class="line">    if nameField, ok := reflect.TypeOf(*e).FieldByName(&quot;Name&quot;); !ok &#123;</span><br><span class="line">        t.Error(&quot;Failed to get &#x27;Name&#x27; field.&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t.Log(&quot;Tag:format&quot;, nameField.Tag.Get(&quot;format&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">    reflect.ValueOf(e).MethodByName(&quot;UpdateAge&quot;).Call([]reflect.Value&#123;reflect.ValueOf(1)&#125;)</span><br><span class="line">    t.Log(&quot;Updated Age:&quot;, e)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestInvokeByName</span><br><span class="line">        TestInvokeByName: reflect_test.go:28: Name：value(Mike)，Type(reflect.Value)</span><br><span class="line">        TestInvokeByName: reflect_test.go:32: Tag:format normal</span><br><span class="line">        TestInvokeByName: reflect_test.go:35: Updated Age: &amp;&#123;1 Mike 1&#125;</span><br><span class="line">    --- PASS: TestInvokeByName (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Struct Tag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type BasicInfo struct &#123;</span><br><span class="line">  Name string `json:&quot;name&quot;`</span><br><span class="line">  Age int `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问Struct：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if nameField, ok := reflect.TypeOf(*e).FieldByName(&quot;Name&quot;); !ok &#123;</span><br><span class="line">t.Error(&quot;Failed to get &#x27;Name&#x27; field.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">t.Log(&quot;Tag:format&quot;, nameField.Tag.Get(&quot;format&quot;)) &#125;</span><br></pre></td></tr></table></figure><p>Reflect.Type 和 Reflflect.Value 都有 FieldByName ⽅法，注意他们的区别。</p><p>DeepEqual：</p><p>比较切片和map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Customer struct &#123;</span><br><span class="line">    CookieID string</span><br><span class="line">    Name     string</span><br><span class="line">    Age      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestDeepEqual(t *testing.T) &#123;</span><br><span class="line">    a := map[int]string&#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;three&quot;&#125;</span><br><span class="line">    b := map[int]string&#123;1: &quot;one&quot;, 2: &quot;two&quot;, 4: &quot;three&quot;&#125;</span><br><span class="line">    fmt.Println(reflect.DeepEqual(a, b))</span><br><span class="line"></span><br><span class="line">    s1 := []int&#123;1, 2, 3&#125;</span><br><span class="line">    s2 := []int&#123;1, 2, 3&#125;</span><br><span class="line">    s3 := []int&#123;2, 3, 1&#125;</span><br><span class="line">    t.Log(&quot;s1 == s2?&quot;, reflect.DeepEqual(s1, s2))</span><br><span class="line">    t.Log(&quot;s1 == s3?&quot;, reflect.DeepEqual(s1, s3))</span><br><span class="line"></span><br><span class="line">    c1 := Customer&#123;&quot;1&quot;, &quot;Mike&quot;, 40&#125;</span><br><span class="line">    c2 := Customer&#123;&quot;1&quot;, &quot;Mike&quot;, 40&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(reflect.DeepEqual(c1, c2))</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestDeepEqual</span><br><span class="line">    false</span><br><span class="line">        TestDeepEqual: fiexible_reflect_test.go:23: s1 == s2? true</span><br><span class="line">        TestDeepEqual: fiexible_reflect_test.go:24: s1 == s3? false</span><br><span class="line">    true</span><br><span class="line">    --- PASS: TestDeepEqual (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于“反射”你应该知道的：</p><ul><li>  提⾼了程序的灵活性</li><li>  降低了程序的可读性</li><li>  降低了程序的性能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">type Employee struct &#123;</span><br><span class="line">    EmployeeID string</span><br><span class="line">    Name       string `format:&quot;normal&quot;`</span><br><span class="line">    Age        int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *Employee) UpdateAge(newVal int) &#123;</span><br><span class="line">    e.Age = newVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer struct &#123;</span><br><span class="line">    CookieID string</span><br><span class="line">    Name     string</span><br><span class="line">    Age      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fillBySettings(st interface&#123;&#125;, settings map[string]interface&#123;&#125;) error &#123;</span><br><span class="line"></span><br><span class="line">    // func (v Value) Elem() Value</span><br><span class="line">    // Elem returns the value that the interface v contains or that the pointer v points to.</span><br><span class="line">    // It panics if v&#x27;s Kind is not Interface or Ptr.</span><br><span class="line">    // It returns the zero Value if v is nil.</span><br><span class="line"></span><br><span class="line">    if reflect.TypeOf(st).Kind() != reflect.Ptr &#123;</span><br><span class="line">        return errors.New(&quot;the first param should be a pointer to the struct type.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // Elem() 获取指针指向的值</span><br><span class="line">    if reflect.TypeOf(st).Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">        return errors.New(&quot;the first param should be a pointer to the struct type.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if settings == nil &#123;</span><br><span class="line">        return errors.New(&quot;settings is nil.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var (</span><br><span class="line">        field reflect.StructField</span><br><span class="line">        ok    bool</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    for k, v := range settings &#123;</span><br><span class="line">        if field, ok = (reflect.ValueOf(st)).Elem().Type().FieldByName(k); !ok &#123;</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        if field.Type == reflect.TypeOf(v) &#123;</span><br><span class="line">            vstr := reflect.ValueOf(st)</span><br><span class="line">            vstr = vstr.Elem()</span><br><span class="line">            vstr.FieldByName(k).Set(reflect.ValueOf(v))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestFillNameAndAge(t *testing.T) &#123;</span><br><span class="line">    settings := map[string]interface&#123;&#125;&#123;&quot;Name&quot;: &quot;Mike&quot;, &quot;Age&quot;: 30&#125;</span><br><span class="line">    e := Employee&#123;&#125;</span><br><span class="line">    if err := fillBySettings(&amp;e, settings); err != nil &#123;</span><br><span class="line">        t.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Log(e)</span><br><span class="line">    c := new(Customer)</span><br><span class="line">    if err := fillBySettings(c, settings); err != nil &#123;</span><br><span class="line">        t.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Log(*c)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestFillNameAndAge</span><br><span class="line">        TestFillNameAndAge: fiexible_reflect_test.go:69: &#123; Mike 30&#125;</span><br><span class="line">        TestFillNameAndAge: fiexible_reflect_test.go:74: &#123; Mike 30&#125;</span><br><span class="line">    --- PASS: TestFillNameAndAge (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>”不安全“行为的危险性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">func TestUnsafe(t *testing.T) &#123;</span><br><span class="line">    i := 10</span><br><span class="line">    f := *(*float64)(unsafe.Pointer(&amp;i))</span><br><span class="line">    t.Log(unsafe.Pointer(&amp;i))</span><br><span class="line">    t.Log(f)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestUnsafe</span><br><span class="line">        TestUnsafe: unsafe_test.go:11: 0xc000016268</span><br><span class="line">        TestUnsafe: unsafe_test.go:12: 5e-323</span><br><span class="line">    --- PASS: TestUnsafe (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The cases is suitable for unsafe</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">// 合理的类型转换</span><br><span class="line">func TestConvert(t *testing.T) &#123;</span><br><span class="line">    a := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">    b := *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">    t.Log(b)</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestConvert</span><br><span class="line">        TestConvert: unsafe_test.go:26: [1 2 3 4]</span><br><span class="line">    --- PASS: TestConvert (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子类型操作</span><br><span class="line">func TestAtomic(t *testing.T) &#123;</span><br><span class="line">    var shareBuffer unsafe.Pointer</span><br><span class="line">    writeDataFn := func() &#123;</span><br><span class="line">        data := []int&#123;&#125;</span><br><span class="line">        for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">            data = append(data, i)</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.StorePointer(&amp;shareBuffer, unsafe.Pointer(&amp;data))</span><br><span class="line">    &#125;</span><br><span class="line">    readDataFn := func() &#123;</span><br><span class="line">        data := atomic.LoadPointer(&amp;shareBuffer)</span><br><span class="line">        fmt.Println(data, *(*[]int)(data))</span><br><span class="line">    &#125;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    writeDataFn()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                writeDataFn()</span><br><span class="line">                time.Sleep(time.Microsecond * 100)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                readDataFn()</span><br><span class="line">                time.Sleep(time.Microsecond * 100)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;reflect.TypeOf vs. reflect.ValueOf：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  reflflect.TypeOf 返回类型 (reflflect.Type)&lt;/li&gt;
&lt;li&gt;  reflflect.ValueOf 返回值 (reflflect.Val</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch全文检索引擎-使用</title>
    <link href="https://stitch.cn/2020/09/23/elasticsearch%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E-%E4%BD%BF%E7%94%A8.html"/>
    <id>https://stitch.cn/2020/09/23/elasticsearch%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E-%E4%BD%BF%E7%94%A8.html</id>
    <published>2020-09-23T06:52:22.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="手册官网"><a href="#手册官网" class="headerlink" title="手册官网"></a>手册官网</h4><p>es-docs<br>es-php-docs</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li><strong>创建索引</strong> <code>vim createindex.json</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;refresh_interval&quot;: &quot;5s&quot;,</span><br><span class="line">        &quot;number_of_shards&quot;: 1,</span><br><span class="line">        &quot;number_of_replicas&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;_default_&quot;: &#123;</span><br><span class="line">            &quot;_all&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;products&quot;: &#123;</span><br><span class="line">        &quot;dynamic&quot;: false,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;productid&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;long&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;title&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;analyzed&quot;,</span><br><span class="line">                &quot;analyzer&quot;: &quot;ik&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;descr&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;analyzed&quot;,</span><br><span class="line">                &quot;analyzer&quot;: &quot;ik&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 具体的字段意思手册上都有 创建 <code>curl -XPOST &quot;http://ip:port/shop&quot; -d&#39;@createindex.json</code> 这里的shop就是我们要设置的索引名称 可以自定义<br> products 是 索引的type类型 可以自定义</li><li><strong>添加数据</strong> <code>curl -XPUT &quot;http://119.23.51.33:9200/shop/products/1&quot; -d&#39;&#123;&quot;productid&quot;:1,&quot;title&quot;:&quot;这是一个商品的标题&quot;,&quot;descr&quot;:&quot;这是一个商品的描述&quot;&#125;&#39;</code> <code>curl -XPUT &quot;http://ip:port/shop/products/2?pretty&quot; -d&#39;&#123;&quot;productid&quot;:2,&quot;title&quot;:&quot;这是一部手机&quot;,&quot;descr&quot;:&quot;这是一个苹果手机的描述信息&quot;&#125;&#39;</code> url地址后面的整值要跟文章id一致 pretty就是 Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。</li><li><strong>搜索数据</strong> <code>vim search.json</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;query&quot;: &#123;</span><br><span class="line">         &quot;multi_match&quot;: &#123;</span><br><span class="line">             &quot;query&quot;: &quot;苹果&quot;,</span><br><span class="line">             &quot;fields&quot;: [</span><br><span class="line">                 &quot;title&quot;,</span><br><span class="line">                 &quot;descr&quot;</span><br><span class="line">             ]</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;highlight&quot;: &#123;</span><br><span class="line">         &quot;pre_tags&quot;: [</span><br><span class="line">             &quot;&quot;</span><br><span class="line">         ],</span><br><span class="line">         &quot;post_tags&quot;: [</span><br><span class="line">             &quot;&quot;</span><br><span class="line">         ],</span><br><span class="line">         &quot;fields&quot;: &#123;</span><br><span class="line">             &quot;title&quot;: &#123;&#125;,</span><br><span class="line">             &quot;descr&quot;: &#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> query 要查询的关键字 fields 哪些字段需要被查询 highlight 被查询出来的关键字 进行一些改变 相当于高亮显示 pre_tags 标签开始 post_tags标签结束</li></ol><p>测试</p><p><code>curl -XGET &quot;http://ip:port/shop/_search?pretty&quot; -d&quot;@search.json&quot;</code></p><h4 id="elasticsearch-jdbc"><a href="#elasticsearch-jdbc" class="headerlink" title="elasticsearch-jdbc"></a>elasticsearch-jdbc</h4><p>将数据库的数据同步到elasticsearch</p><ol><li><strong>下载</strong> <code>wget http://xbib.org/repository/org/xbib/elasticsearch/importer/elasticsearch-jdbc/2.3.4.0/elasticsearch-jdbc-2.3.4.0-dist.zip</code> <code>unzip elasticsearch-jdbc-2.3.4.0-dist.zip</code></li><li><strong>修改配置</strong> <code>cd elasticsearch-jdbc-2.3.4.0/bin</code> 为了防止出错 先备份一下 <code>cp mysql-blog.sh mysql-blog.sh.bak</code> <code>vim mysql-blog.sh</code> 将 echo 下的内容替换成以下内容 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot; : &quot;jdbc&quot;,</span><br><span class="line">    &quot;jdbc&quot; : &#123;</span><br><span class="line">        &quot;url&quot; : &quot;jdbc:mysql://localhost:3306/good&quot;,</span><br><span class="line">        &quot;user&quot; : &quot;root&quot;,</span><br><span class="line">        &quot;password&quot; : &quot;1C292567e208&quot;,</span><br><span class="line">        &quot;sql&quot; : &quot;select productid,title,descr,productid as _id from test&quot;,</span><br><span class="line">        &quot;index&quot; : &quot;shop&quot;,</span><br><span class="line">        &quot;type&quot; : &quot;products&quot;,</span><br><span class="line">        &quot;elasticsearch&quot; : &#123;</span><br><span class="line">             &quot;cluster&quot; : &quot;search&quot;,</span><br><span class="line">             &quot;host&quot; : &quot;ip&quot;,</span><br><span class="line">             &quot;port&quot; : 9300</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> url 是我们的数据库 good是库名 对哪个库进行操作 user password 用户名和密码 sql语句 就是 执行后 把查询出来的数据添加到es中 这里呢productid as _id 是因为es的唯一标识是根据_id生成的 index 我们刚刚创建的索引名称 products 是索引type类型 cluster 是我们es配置文件中的项目名称 host port 分别为ip和端口号 port为9300 这个地方不可以改<ol><li><strong>运行</strong> <code>./mysql-blog.sh</code> <code>curl -XGET &quot;http://119.23.51.33:9200/shop/_search?pretty&quot;</code> 可以看到数据库的内容被添加进去了 但是修改数据库内容 或者 添加内容 es却不会改变 下面怎么改变呢</li></ol></li><li><strong>监控 实时同步</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot; : &quot;jdbc&quot;,</span><br><span class="line">    &quot;jdbc&quot; : &#123;</span><br><span class="line">        &quot;url&quot; : &quot;jdbc:mysql://localhost:3306/good&quot;,</span><br><span class="line">        &quot;schedule&quot; : &quot;0 0-59 0-23 ? * *&quot;,</span><br><span class="line">        &quot;user&quot; : &quot;root&quot;,</span><br><span class="line">        &quot;password&quot; : &quot;1C292567e208&quot;,</span><br><span class="line">        &quot;sql&quot; : [&#123;</span><br><span class="line">                &quot;statement&quot;: &quot;select productid,title,descr,productid as _id from test where updatetime &gt; unix_timestamp(?) &quot;,</span><br><span class="line">                &quot;parameter&quot;: [&quot;$metrics.lastexecutionstart&quot;]&#125;</span><br><span class="line">            ],</span><br><span class="line">        &quot;index&quot; : &quot;shop&quot;,</span><br><span class="line">        &quot;type&quot; : &quot;products&quot;,</span><br><span class="line">        &quot;metrics&quot;: &#123;</span><br><span class="line">            &quot;enabled&quot; : true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;elasticsearch&quot; : &#123;</span><br><span class="line">             &quot;cluster&quot; : &quot;search&quot;,</span><br><span class="line">             &quot;host&quot; : &quot;ip&quot;,</span><br><span class="line">             &quot;port&quot; : 9300</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这时需要一个字段去判断 那就是我们数据的修改时间 parameter 里面的内容 就是获取上次脚本执行时间 sql 的where条件 就是判断 修改时间大于上次脚本执行时间 就属于新数据 重新执行下脚本 就可以了 怎么用php操作呢 现在有好多框架的轮子 或者直接看es-php-docs php框架： laravel-elasticsearch<br> yii2-elasticsearch<br> 去GitHub上查找就行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;手册官网&quot;&gt;&lt;a href=&quot;#手册官网&quot; class=&quot;headerlink&quot; title=&quot;手册官网&quot;&gt;&lt;/a&gt;手册官网&lt;/h4&gt;&lt;p&gt;es-docs&lt;br&gt;es-php-docs&lt;/p&gt;
&lt;h4 id=&quot;索引&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>php用select实现I/O复用</title>
    <link href="https://stitch.cn/2020/09/23/php%E7%94%A8select%E5%AE%9E%E7%8E%B0i-o%E5%A4%8D%E7%94%A8.html"/>
    <id>https://stitch.cn/2020/09/23/php%E7%94%A8select%E5%AE%9E%E7%8E%B0i-o%E5%A4%8D%E7%94%A8.html</id>
    <published>2020-09-23T06:48:44.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux Socket服务器短编程时，为了处理大量客户的连接请求，需要使用非阻塞I/O和复用，select、poll和epoll是Linux API提供的I/O复用方式，其实I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。现在比较受欢迎的的nginx就是使用epoll来实现I/O复用支持高并发，所以理解好select，poll，epoll对于nginx如何应对高并发还是很有帮助的。</p><h3 id="select调用过程"><a href="#select调用过程" class="headerlink" title="select调用过程"></a>select调用过程</h3><p><img src="http://qiniu.gaobinzhan.com/2019/12/24/2937c31e6dc23.png"></p><h3 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h3><ul><li>单个进程监控的文件描述符有限，通常为1024*8个文件描述符。  当然可以改进，由于select采用轮询方式扫描文件描述符。文件描述符数量越多，性能越差。</li><li>内核/用户数据拷贝频繁，操作复杂。  select在调用之前，需要手动在应用程序里将要监控的文件描述符添加到fed_set集合中。然后加载到内核进行监控。用户为了检测时间是否发生，还需要在用户程序手动维护一个数组，存储监控文件描述符。当内核事件发生，在将fed_set集合中没有发生的文件描述符清空，然后拷贝到用户区，和数组中的文件描述符进行比对。再调用selecct也是如此。每次调用，都需要了来回拷贝。</li><li>轮回时间效率低  select返回的是整个数组的句柄。应用程序需要遍历整个数组才知道谁发生了变化。轮询代价大。</li><li>select是水平触发  应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作。那么之后select调用还是会将这些文件描述符返回，通知进程。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>Worker.php</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux Socket服务器短编程时，为了处理大量客户的连接请求，需要使用非阻塞I/O和复用，select、poll和epoll是Linux API提供的I/O复用方式，其实I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>redis主从之全量复制及增量复制</title>
    <link href="https://stitch.cn/2020/09/23/redis%E4%B8%BB%E4%BB%8E%E4%B9%8B%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6.html"/>
    <id>https://stitch.cn/2020/09/23/redis%E4%B8%BB%E4%BB%8E%E4%B9%8B%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E5%8F%8A%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6.html</id>
    <published>2020-09-23T06:42:20.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在之前我写了一篇docker实现redis主从复制的文章，点击进入</p></blockquote><p>对于主从复制的好处，在上篇文章我也写了，下面说一下注意事项。</p><p><strong>注意事项</strong>：</p><ul><li>安全  对于数据比较重要的节点，主节点会通过设置<code>requirepass</code>参数进行密码验证，这时候所有的客户端访问必须使用<code>auth</code>命令进行验证。从节点与主节点的复制链接是通过一个特殊标识的客户端来完成。因此需要配置从节点的<code>masterauth</code>参数与主节点密码保持一致，这样从节点才可以正确地链接到主节点并发起复制流程。</li><li>从节点只读  默认情况下<code>slave-read-only=yes</code>配置为只读，由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此没必要就不要动这个配置。</li><li>网络延迟问题  主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题，redis为我们提供了<code>repl-disable-tcp-nodelay</code>参数用于控制是否关闭 tcp nodelay，默认是关闭的，说明如下：<blockquote><p>当<strong>关闭</strong>时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟将会变小，但增加了网络宽带的消耗。适用于主从之间的网络环境较好的场景。</p><p>当<strong>开启</strong>时，主节点会合并较小的TCP数据包从而节省宽带。默认发送时间间隔取决于Linux的内核，一般默认为40ms。这种配置节省了宽带但增大主从之间的延迟。适用于主从网络环境复杂或宽带紧张的场景。</p></blockquote></li></ul><p>部署主从节点时需要考虑网络延迟、宽带使用率、防灾级别等因素，如要求低延迟时，建议同机房部署并关闭<code>repl-disable-tcp-nodelay</code>，如考虑容灾性，可以跨机房部署并开启<code>repl-disable-tcp-nodelay</code>。</p><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br></pre></td></tr></table></figure><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; C[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; D[Redis-slave]</span><br></pre></td></tr></table></figure><h3 id="树状主从"><a href="#树状主从" class="headerlink" title="树状主从"></a>树状主从</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[Redis-master] --&gt; B[Redis-slave]</span><br><span class="line">A[Redis-master] --&gt; C[Redis-slave]</span><br><span class="line">B[Redis-slave] --&gt; D[Redis-slave]</span><br><span class="line">B[Redis-slave] --&gt; E[Redis-slave]</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[slaveof] --&gt;127.0.0.1:6379 B[slave]</span><br><span class="line">B[slave] --&gt; D[保存主节点信息]</span><br><span class="line">D[保存主节点信息] --&gt; E[主从建立socket连接]</span><br><span class="line">E[主从建立socket连接] --&gt; F[发送ping命令]</span><br><span class="line">F[发送ping命令] --&gt; G[权限验证]</span><br><span class="line">G[权限验证] --&gt; H[同步数据集]</span><br><span class="line">H[同步数据集] --&gt; I[命令持续复制]</span><br><span class="line">I[命令持续复制] --&gt; J[master]</span><br></pre></td></tr></table></figure><p>从上图可以看出来大致分为6个过程：</p><ul><li>  执行slaveof后从节点保存主节点的地址信息便返回，这时候复制流程还没开始。</li><li>  从节点内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接，从节点会建立一个socket套接字。</li><li>  发送ping命令，检测主从之间网络套接字是否可用，检测主节点是否可用接受处理命令。如果发送 ping 命令后，从节点没有收到主节点的 pong 回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连。</li><li>  如果主节点配置了<code>requirepass</code>参数，则需要密码认证，从节点必须配置<code>masterauth</code>参数保证与主节点相同的密码才能通过验证。</li><li>  主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。</li><li>  当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li></ul><blockquote><p>主从同步的过程中，从节点会把原来的数据清空。</p></blockquote><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>同步方式：</p><ul><li>全量复制  用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点。当数据量过大的时候，会造成很大的网络开销。</li><li>部分复制  用于处理在主从复制中因网络闪退等原因造成数据丢失场景，当从节点再次连上主节点，如果条件允许，主节点会补发丢失数据给从节点，因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。但需要注意，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制 。</li></ul><p>复制偏移量：</p><ul><li>  参与复制的主从节点都会维护自身复制偏移量，主节点在处理完写入命令操作后，会把命令的字节长度做累加记录，统计信息在<code>info replication</code>中的<code>master_repl_offset</code>指标中。</li><li>  从节点每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量<code>slave0:ip=192.168.1.3,port=6379,state=online,offset=116424,lag=0</code></li><li>  从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在<code>info replication</code>中的<code>slave_repl_offset</code>中。</li></ul><p>复制积压缓冲区：</p><ul><li>  复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点时被创建，这时主节点响应写命令时，不但会把命令发给从节点，还会写入复制积压缓冲区。</li><li>  在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中 的每个字节对应的复制偏移量(offset) 。由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</li></ul><p>主节点运行ID：</p><ul><li>  每个redis节点启动后都会动态分配一个40位的十六进制字符串为运行ID。运行ID的主要作用是来唯一识别redis节点，比如从节点保存主节点的运行ID识别自已正在复制是哪个主节点。如果只使用ip+port的方式识别主节点，那么主节点重启变更了整体数据集（如替换RDB/AOF文件），从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将做全量复制。可以在<code>info server</code>命令查看当前节点的运行ID。</li><li>  需要注意的是redis关闭再启动，运行的id会随之变化。</li></ul><p>Psync命令：</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/03/d8f06279c7ec4.png"></p><ul><li>  从节点使用<code>psync</code>命令完成部分复制和全量复制功能<code>psync runid offset</code></li><li>流程说明：<ul><li>  从节点(slave)发送psync命令给主节点，参数runid是当前从节点保存的主节点运行id，如果没有则默认值为 ？, 参数offset是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为-1。</li><li>主节点根据<code>pysnc</code>参数和自身数据情况决定响应结果：<ul><li>  如果回复+FULLRESYNC {runid} {offset}，那么从节点将触发全量复制流程。</li><li>  如果回复+CONTINUE，从节点将触发部分复制流程。</li><li>  如果回复-ERR，说明主节点版本低于Redis2.8。</li></ul></li></ul></li></ul><p>全量复制流程：</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/03/7351b38954ab9.png"></p><ul><li>  发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行id，所以发送psync ? -1</li><li>  主节点根据psync ? -1解析出当前为全量复制，回复+FULLRESYNC响应(主机会向从机发送 runid 和 offset，因为 slave 并没有对应的 offset，所以是全量复制)</li><li>  从节点接收主节点的响应数据保存运行ID和偏移量offset(从机 slave 会保存 主机master 的基本信息 save masterInfo)</li><li>  主节点收到全量复制的命令后，执行bgsave（异步执行），在后台生成RDB文件（快照），并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</li><li>主节点发送RDB文件给从节点，从节点把接收到的RDB文件保存在本地并直接作为从节点的数据文件，接收完RDB后从节点打印相关日志，可以在日志中查看主节点发送的数据量(主机send RDB 发送 RDB 文件给从机)<ul><li>  注意！对于数据量较大的主节点，比如生成的RDB文件超过6GB以上时要格外小心。传输文件这一步操作非常耗时，速度取决于主从节点之间网络带宽。</li><li>  通过细致分析Full resync和MASTER SLAVE这两行日志的时间差，可以算出RDB文件从创建到传输完毕消耗的总时间。如果总时间超过repl-timeout所配置的值 (默认60秒)，从节点将放弃接受RDB文件并清理已经下载的临时文件，导致全量复制失败;针对数据量较大的节点，建议调大repl-timeout参数防止出现全量同步数据超时;</li><li>  例如对于千兆网卡的机器，网卡带宽理论峰值大约每秒传输100MB,在不考虑其他进程消耗带宽的情况下，6GB的RDB文件至少需要60秒传输时间，默认配置下，极易出现主从数同步超时。</li></ul></li><li>  对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据致性。(发送缓冲区数据)</li><li>  从节点接收完主节点传送来的全部数据后会清空自身旧数据(刷新旧的数据，从节点在载入主节点的数据之前要先将老数据清除)</li><li>  从节点清空数据后开始加载RDB文件，对于较大的RDB文件，这一步操作依然比较消耗时间，可以通过计算日志之间的实际差来判断加载RDB的总消耗时间(加载 RDB 文件将数据库状态更新至主节点执行bgsave时的数据库状态和缓冲区数据的加载。)</li><li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化的功能，它会立刻做bgrewriteeaof的操作，为了保证全量复制后AOF持久化文件立刻可用。 通过分析全量复制的所有流程，全量复制是一个非常耗时费力的操作。他的实际开销主要包括：<ul><li>  主节点bgsave时间</li><li>  RDB文件网络传输时间</li><li>  从节点清空数据时间</li><li>  从节点加载RDB的时间</li><li>  可能的AOF重写时间</li></ul></li></ul><p>部分复制流程：</p><p><img src="http://qiniu.gaobinzhan.com/2020/06/04/57b273afe7d75.png"></p><ul><li>  部分复制是 Redis 2.8 以后出现的，之所以要加入部分复制，是因为全量复制会产生很多问题，比如像上面的时间开销大、无法隔离等问题， Redis 希望能够在主节点出现抖动（相当于断开连接）的时候，可以有一些机制将复制的损失降低到最低</li><li>  当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点出问题了并断开复制链接（如果网络抖动（连接断开 connection lost））。</li><li>  主从连接中断期间主节点依然响应命令，但因复制链接中断命令无法发送给从节点不过主节点内部存在的复制积压缓存去，依然可以保存一段时间的写命令数据，默认最大缓存1MB(主机master 还是会写 replbackbuffer（复制缓冲区）)</li><li>  当主从节点网络恢复后，从节点会再次连上主节点。(从机slave会继续尝试连接主机)</li><li>  当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行id。因此会把他们当作psync参数发送给主节点，要求进行部分复制操作。(从机 slave 会把自己当前 runid 和偏移量传输给主机 master，并且执行 pysnc 命令同步)</li><li>  主节点接到psync命令后首先核对参数的runid，如果 master 发现你的偏移量是在缓冲区的范围内，根据参数offset在缓冲区查找复制内内，如果在偏移量之后的数据存在缓存区中，则对从节点发送continue表示可以进行部分复制</li><li>  主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。(同步了 offset 的部分数据，所以部分复制的基础就是偏移量 offset)</li></ul><p>心跳：</p><blockquote><p>主节点在建立成功后会维护这长连接彼此发送心跳检测</p></blockquote><ul><li>  主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过client list命令查看复制相关客户端信息，主节点的连接状态为flags=M,从节点连接状态 flags=S。</li><li>  主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。</li><li>  从节点在主线程中每隔1秒发送replconf ack {offset} 命令，给主节点上报自身当前的复制偏移量。</li></ul><p>缓冲区大小调节：</p><ul><li>  由于缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li><li>  反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置；</li><li>  例如 如果网络中断的平均时间是 60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见， 可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在之前我写了一篇docker实现redis主从复制的文章，点击进入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于主从复制的好处，在上篇文章我也写了，下面说一下注意事项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go典型并发任务</title>
    <link href="https://stitch.cn/2020/09/20/go%E5%85%B8%E5%9E%8B%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1.html"/>
    <id>https://stitch.cn/2020/09/20/go%E5%85%B8%E5%9E%8B%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1.html</id>
    <published>2020-09-20T19:58:51.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="仅运行一次"><a href="#仅运行一次" class="headerlink" title="仅运行一次"></a>仅运行一次</h2><p>最容易联想到的单例模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type Singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var singleInstance *Singleton</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetSingletonObj() *Singleton &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        fmt.Println(&quot;Create Obj&quot;)</span><br><span class="line">        singleInstance = new(Singleton)</span><br><span class="line">    &#125;)</span><br><span class="line">    return singleInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGetSingletonObj(t *testing.T) &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            obj := GetSingletonObj()</span><br><span class="line">            fmt.Printf(&quot;%x\n&quot;, unsafe.Pointer(obj))</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestGetSingletonObj</span><br><span class="line">    Create Obj</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    1269f78</span><br><span class="line">    --- PASS: TestGetSingletonObj (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仅需任意任务完成"><a href="#仅需任意任务完成" class="headerlink" title="仅需任意任务完成"></a>仅需任意任务完成</h2><p>任务堆里面，只需任务一个完成就返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func runTask(id int) string &#123;</span><br><span class="line">    time.Sleep(10 * time.Millisecond)</span><br><span class="line">    return fmt.Sprintf(&quot;the result is from %d&quot;, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func FirstResponse() string &#123;</span><br><span class="line">    numOfRunner := 10</span><br><span class="line">    ch := make(chan string) // 非缓冲channel</span><br><span class="line">    for i := 0; i &lt; numOfRunner; i++ &#123;</span><br><span class="line">        go func(i int) &#123;</span><br><span class="line">            ret := runTask(i)</span><br><span class="line">            ch</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;仅运行一次&quot;&gt;&lt;a href=&quot;#仅运行一次&quot; class=&quot;headerlink&quot; title=&quot;仅运行一次&quot;&gt;&lt;/a&gt;仅运行一次&lt;/h2&gt;&lt;p&gt;最容易联想到的单例模式：&lt;/p&gt;
&lt;figure class=&quot;highlight pla</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello,Go</title>
    <link href="https://stitch.cn/2020/09/20/hellogo.html"/>
    <id>https://stitch.cn/2020/09/20/hellogo.html</id>
    <published>2020-09-20T19:53:18.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>Go的特点</p><ul><li>  只有25个关键字</li><li>  强类型语言</li><li>  垃圾回收</li><li>  指针直接访问内存</li></ul><p>开发环境构建</p><ul><li>  1.8之前必须设置</li><li>  1.8之后没用设置，将使用默认值</li><li>  扩展名必须为<code>go</code></li></ul><h2 id="编写第一个go程序"><a href="#编写第一个go程序" class="headerlink" title="编写第一个go程序"></a>编写第一个go程序</h2><p>hello.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main // 包，表明代码所在的模块</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">) // 引入代码依赖</span><br><span class="line"></span><br><span class="line">// 功能实现</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种运行方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run hello.go</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build hello.go</span><br><span class="line">$ ls</span><br><span class="line">hello           hello.go</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>应用程序入口：</p><ul><li>  必须是<code>main</code>包 <code>package main</code></li><li>  必须是<code>main</code> 方法 <code>func main()</code></li><li>  文件名不一定是<code>main.go</code></li></ul><p>退出返回值：</p><ul><li>  Go中<code>main</code>函数不支持任何返回值</li><li>  通过<code>os.Exit</code>来返回状态</li></ul><p>获取命令行参数：</p><ul><li>  Go中<code>main</code>函数不支持任何返回值</li><li>  <code>main</code>函数不支持传入参数 func main(arg []string)</li><li>  在程序中直接通过<code>os.Args</code>获取命令行参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main // 包，表明代码所在的模块</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">) // 引入代码依赖</span><br><span class="line"></span><br><span class="line">// 功能实现</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">    fmt.Println(os.Args[0], os.Args[1]) // 默认情况下 参数0返回可执行文件路径</span><br><span class="line">    os.Exit(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run hello.go gaobinzhan</span><br><span class="line">Hello, World!</span><br><span class="line">参数0：/var/folders/qr/9vkwk7xn5rzbtnmykx7sxyv00000gn/T/go-build024626496/b001/exe/hello</span><br><span class="line">参数1：gaobinzhan</span><br><span class="line">exit status 100</span><br></pre></td></tr></table></figure><p><strong>公众号 : Tinkled</strong></p><p><img src="http://qiniu.gaobinzhan.com/2019/12/14/f702d956e8211.jpg?imageView2/2/w/300"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  只有25个关键字&lt;/li&gt;
&lt;li&gt;  强类型语言&lt;/li&gt;
&lt;li&gt;  垃圾回收&lt;/li&gt;
&lt;li&gt;  指针直接访问内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发环境构建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  1.8之前必须设置&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>docker实现redis主从复制</title>
    <link href="https://stitch.cn/2020/09/20/docker%E5%AE%9E%E7%8E%B0redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>https://stitch.cn/2020/09/20/docker%E5%AE%9E%E7%8E%B0redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html</id>
    <published>2020-09-20T19:49:58.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的场景当中单一节点的redis容易面临风险。<br>比如:</p><ul><li>  机器故障。我们部署到一台 Redis 服务器，当发生机器故障时，需要迁移到另外一台服务器并且要保证数据是同步的。而数据是最重要的，如果你不在乎， 基本上也就不会使用 Redis 了。</li></ul><p>要实现分布式数据库的更大的存储容量和承受高并发访问量，我们会将原来集中式数据库的数据分别存储到其他多个网络节点上。</p><p>Redis 为了解决这个单一节点的问题，也会把数据复制多个副本部署到其他节点上进行复制，实现 Redis的高可用，实现对数据的冗余备份，从而保证数据和服务 的高可用。</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><ul><li>  主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到 从节点。</li><li>  默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</li></ul><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul><li>  数据冗余:主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>  故障恢复:当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</li><li>  负载均衡:在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) 分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>  读写分离:可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量;</li><li>  高可用基石:除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h4 id="主从复制启用"><a href="#主从复制启用" class="headerlink" title="主从复制启用"></a>主从复制启用</h4><p>从节点开启主从复制，有3种方式:</p><ul><li>配置文件  在从服务器的配置文件中加入:slaveof<br>  不推荐使用 配置文件可被动态修改</li><li>启动命令  redis-server启动命令后加入 –slaveof</li><li>客户端命令  Redis服务器启动后，直接通过客户端执行命令:slaveof ，则该Redis实例成为从节点。<br>  通过 info replication 命令可以看到复制的一些参数信息</li></ul><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><p>主从复制的原理以及过程必须要掌握，这样我们才知道为什么会出现这些问题 主从复制过程大体可以分为3个阶段:连接建立阶段(即准备阶段)、数据同步阶段、命令传播阶段。在从节点执行 slaveof 命令后，复制过程便开始运作，下面图示大概可以看到， 从图中可以看出复制过程大致分为6个过程</p><p><img src="http://qiniu.gaobinzhan.com/2019/12/19/55f5372ea5837.png"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="dockerfile构建redis镜像"><a href="#dockerfile构建redis镜像" class="headerlink" title="dockerfile构建redis镜像"></a>dockerfile构建redis镜像</h4><p>DockerFile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">RUN sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27; /etc/apk/repositories \</span><br><span class="line">  &amp;&amp; apk add  gcc g++ libc-dev  wget vim  openssl-dev make  linux-headers \</span><br><span class="line">  &amp;&amp; rm -rf /var/cache/apk/*</span><br><span class="line"></span><br><span class="line">#通过选择更小的镜像，删除不必要文件清理不必要的安装缓存，从而瘦身镜像</span><br><span class="line">#创建相关目录能够看到日志信息跟数据跟配置文件</span><br><span class="line">RUN mkdir -p /usr/src/redis \</span><br><span class="line">      &amp;&amp; mkdir -p /usr/src/redis/data \</span><br><span class="line">      &amp;&amp; mkdir -p /usr/src/redis/conf \</span><br><span class="line">      &amp;&amp; mkdir -p /usr/src/redis/log   \</span><br><span class="line">      &amp;&amp; mkdir -p /var/log/redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN wget  -O /usr/src/redis/redis-4.0.11.tar.gz  &quot;http://download.redis.io/releases/redis-4.0.11.tar.gz&quot; \</span><br><span class="line">   &amp;&amp; tar -xzf /usr/src/redis/redis-4.0.11.tar.gz  -C /usr/src/redis \</span><br><span class="line">   &amp;&amp; rm -rf /usr/src/redis/redis-4.0.11.tar.tgz</span><br><span class="line"></span><br><span class="line">RUN cd /usr/src/redis/redis-4.0.11 &amp;&amp;  make &amp;&amp; make PREFIX=/usr/local/redis install \</span><br><span class="line">&amp;&amp; ln -s /usr/local/redis/bin/*  /usr/local/bin/  &amp;&amp; rm -rf /usr/src/redis/redis-4.0.11</span><br><span class="line"></span><br><span class="line">#COPY ./conf/redis.conf  /usr/src/redis/conf</span><br><span class="line"></span><br><span class="line">CMD [&quot;/usr/local/bin/redis-server&quot;,&quot;/usr/src/redis/conf/redis.conf&quot;]</span><br></pre></td></tr></table></figure><p>切换到当前dockfile文件目录下 执行命令</p><p><code>docker build -t redis .</code></p><p>等待构建完成就可以了</p><h4 id="docker创建自定义网络及redis主从集群规划"><a href="#docker创建自定义网络及redis主从集群规划" class="headerlink" title="docker创建自定义网络及redis主从集群规划"></a>docker创建自定义网络及redis主从集群规划</h4><p>执行自定义网络命令<br><code>docker network create --subnet=192.168.1.0/24 redis-network</code></p><p>容器名称</p><p>容器IP地址</p><p>映射端口号</p><p>宿主机IP地址</p><p>服务运行模式</p><p>redis-master</p><p>192.168.1.2</p><p>6380-&gt;6379</p><p>127.0.0.1</p><p>master</p><p>redis-slave</p><p>192.168.1.3</p><p>6381-&gt;6379</p><p>127.0.0.1</p><p>slave</p><h4 id="docker启动容器"><a href="#docker启动容器" class="headerlink" title="docker启动容器"></a>docker启动容器</h4><p>在 /data/ 下面创建该目录结构</p><p>data和log下面文件忽略</p><p><img src="http://qiniu.gaobinzhan.com/2019/12/19/45619a5aa919b.png"></p><p>目录代码</p><p>提取码：r8r1</p><p>下载完放到 /data 下面</p><p>用户可自行定义宿主机目录</p><p>master<br><code>docker run -itd --name redis-master --net redis-network -v /data/redis/master:/usr/src/redis -p 6380:6379 --ip 192.168.1.2 redis</code></p><p>slave<br><code>docker run -itd --name redis-slave --net redis-network -v /data/redis/slave:/usr/src/redis -p 6381:6379 --ip 192.168.1.3 redis</code></p><h4 id="测试主从复制"><a href="#测试主从复制" class="headerlink" title="测试主从复制"></a>测试主从复制</h4><p>主从的配置文件 没有设置redis密码</p><p>开两个终端分别执行</p><p><code>docker exec -it redis-master sh</code></p><p><code>docker exec -it redis-slave sh</code></p><p>进入容器后执行(都要执行)</p><p><code>redis-cli</code></p><p>在slave执行</p><p><code>SLAVEOF 192.168.1.2 6379</code></p><p><code>info replication</code></p><p><img src="http://qiniu.gaobinzhan.com/2019/12/19/1c2dc132f6731.png"></p><p><code>master_link_status</code>为up就成功了！</p><p>当前是通过内网连接 端口号为6379</p><p>如果通过宿主机IP连接 端口号为6380</p><p>这时候在master进行操作 就可以看到slave的变化了！</p><p><img src="http://qiniu.gaobinzhan.com/2019/12/19/639b41e07023f.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在实际的场景当中单一节点的redis容易面临风险。&lt;br&gt;比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  机器故障。我们部署到一台 Redis 服务器，当发生机器故障时，需要迁移到另外一台服务器并且要保证数据是同步的。而数据是最重要的，如果你不在乎， 基本上也就不会使用 Redis </summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>消息中间件Kafka - 介绍及安装</title>
    <link href="https://stitch.cn/2020/09/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6kafka-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85.html"/>
    <id>https://stitch.cn/2020/09/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6kafka-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85.html</id>
    <published>2020-09-20T19:45:11.000Z</published>
    <updated>2021-10-01T03:05:23.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li>  博主： gaobinzhan</li><li>  发布时间：2019 年 03 月 20 日</li><li>  916次浏览</li><li>  暂无评论</li><li>  1815字数</li><li>  分类： 消息中间件</li></ul><p>[TOC]</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>  <strong>高吞吐量</strong>：非常普通的硬件Kafka也可以支持每秒数百万的消息</li><li>  支持通过Kafka服务器和消费机集群来区分消息</li><li>  支持Hadoop并行数据加载</li></ul><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h4><ul><li>  <strong>Broker</strong>：Kafka集群中的一台或多台服务器统称为broker。</li><li>  <strong>Topic</strong>：Kafka处理的消息源（feeds of messages）的不同分类。</li><li>  <strong>Partition</strong>：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li><li>  <strong>Message</strong>：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。</li><li>  <strong>Producers</strong>：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。</li><li>  <strong>Consumers</strong>：消息和数据的消费者，订阅topics并处理其发布的消息的过程叫做consumers。</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><strong>下载</strong> 先安装jdk 然后jdk的安装方式在elasticsearch的安装文章中有，这里就不写了 kafka官网 <code>wget https://www-us.apache.org/dist/kafka/2.1.1/kafka_2.11-2.1.1.tgz</code> 解压 <code>tar -xzvf kafka_2.11-2.1.1.tgz</code></li><li><strong>修改配置文件</strong> <code>cd kafka_2.11-2.1.1/config</code> <code>zookeeper.properties</code> 是zookeeper的配置文件，默认端口号2181，可不做修改 <code>server.properties</code> 是kafka配置文件，将 zookeeper.connect 这行 改为自己的zookeeper地址和端口号 修改完成之后 返回kafka主目录 <code>cd ..</code></li><li><strong>运行zookeeper和kafka</strong> 运行zookeeper <code>bin/zookeeper-server-start.sh config/zookeeper.properties</code> 不要关闭此窗口 再开一个新窗口 重新进入kafka目录 运行kafka <code>bin/kafka-server-start.sh config/server.properties</code></li><li><strong>运行producer和consumer</strong> 跟上步操作一样 不要关闭窗口 重新开 重新进入kafka目录 创建一个topic为test 把ip和port改为自己zookeeper的 <code>bin/kafka-topics.sh --create --zookeeper ip:port --replication-factor 1 --partitions 1 --topic test</code> 运行producer <code>bin/kafka-console-producer.sh --broker-list ip:port --topic test</code> 跟上步操作一样 不要关闭窗口 重新开 重新进入kafka目录 运行consumer <code>bin/kafka-console-consumer.sh --bootstrap-server ip:port --topic test --from-beginning</code> 然后在producer发送信息 会发现 consumer的窗口会出现你发送的消息</li></ol><p>[TOC]</p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>  <strong>高吞吐量</strong>：非常普通的硬件Kafka也可以支持每秒数百万的消息</li><li>  支持通过Kafka服务器和消费机集群来区分消息</li><li>  支持Hadoop并行数据加载</li></ul><h4 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h4><ul><li>  <strong>Broker</strong>：Kafka集群中的一台或多台服务器统称为broker。</li><li>  <strong>Topic</strong>：Kafka处理的消息源（feeds of messages）的不同分类。</li><li>  <strong>Partition</strong>：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li><li>  <strong>Message</strong>：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。</li><li>  <strong>Producers</strong>：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。</li><li>  <strong>Consumers</strong>：消息和数据的消费者，订阅topics并处理其发布的消息的过程叫做consumers。</li></ul><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ol><li><strong>下载</strong> 先安装jdk 然后jdk的安装方式在elasticsearch的安装文章中有，这里就不写了 kafka官网 <code>wget https://www-us.apache.org/dist/kafka/2.1.1/kafka_2.11-2.1.1.tgz</code> 解压 <code>tar -xzvf kafka_2.11-2.1.1.tgz</code></li><li><strong>修改配置文件</strong> <code>cd kafka_2.11-2.1.1/config</code> <code>zookeeper.properties</code> 是zookeeper的配置文件，默认端口号2181，可不做修改 <code>server.properties</code> 是kafka配置文件，将 zookeeper.connect 这行 改为自己的zookeeper地址和端口号 修改完成之后 返回kafka主目录 <code>cd ..</code></li><li><strong>运行zookeeper和kafka</strong> 运行zookeeper <code>bin/zookeeper-server-start.sh config/zookeeper.properties</code> 不要关闭此窗口 再开一个新窗口 重新进入kafka目录 运行kafka <code>bin/kafka-server-start.sh config/server.properties</code></li><li><strong>运行producer和consumer</strong> 跟上步操作一样 不要关闭窗口 重新开 重新进入kafka目录 创建一个topic为test 把ip和port改为自己zookeeper的 <code>bin/kafka-topics.sh --create --zookeeper ip:port --replication-factor 1 --partitions 1 --topic test</code> 运行producer <code>bin/kafka-console-producer.sh --broker-list ip:port --topic test</code> 跟上步操作一样 不要关闭窗口 重新开 重新进入kafka目录 运行consumer <code>bin/kafka-console-consumer.sh --bootstrap-server ip:port --topic test --from-beginning</code> 然后在producer发送信息 会发现 consumer的窗口会出现你发送的消息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;  博主： gaobinzhan&lt;/li&gt;
&lt;li&gt;  发布时间：2019 年 03 月 20 日&lt;/li&gt;
&lt;li&gt;  916次浏览&lt;/li&gt;
&lt;li&gt;  暂无评论&lt;/li&gt;
&lt;li&gt;  1815字数&lt;/li&gt;
&lt;li&gt;  分类： 消息中间件&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>Go编写好的错误处理</title>
    <link href="https://stitch.cn/2020/09/20/go%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"/>
    <id>https://stitch.cn/2020/09/20/go%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html</id>
    <published>2020-09-20T19:39:29.000Z</published>
    <updated>2021-10-01T03:05:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>Go的错误机制：</p><ul><li>  没有异常机制</li><li><code>error</code> 类型实现了 <code>error</code> 接口  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">  Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以通过 <code>errors.News</code> 来快速创建错误实例  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors.News(&quot;n must be in the range [0,10]&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>拿Fibonacci举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func GetFibonacci(n int) []int &#123;</span><br><span class="line">    fibList := []int&#123;1, 2&#125;</span><br><span class="line"></span><br><span class="line">    for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">        fibList = append(fibList, fibList[i-2]+fibList[i-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return fibList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGetFibonacci(t *testing.T) &#123;</span><br><span class="line">    t.Log(GetFibonacci(10))</span><br><span class="line">    t.Log(GetFibonacci(-10))</span><br><span class="line">    /** 运行结果</span><br><span class="line">    === RUN   TestGetFibonacci</span><br><span class="line">        TestGetFibonacci: err_test.go:15: [1 2 3 5 8 13 21 34 55 89]</span><br><span class="line">        TestGetFibonacci: err_test.go:21: [1 2]</span><br><span class="line">    --- PASS: TestGetFibonacci (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到没有对入参进行校验</p></blockquote><p>现在做下校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func GetFibonacci(n int) ([]int, error) &#123;</span><br><span class="line">    if n &lt; 2  n &gt; 100 &#123;</span><br><span class="line">        return nil, errors.New(&quot;n should be in [2,100]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fibList := []int&#123;1, 2&#125;</span><br><span class="line"></span><br><span class="line">    for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">        fibList = append(fibList, fibList[i-2]+fibList[i-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return fibList, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGetFibonacci(t *testing.T) &#123;</span><br><span class="line">    // 如果有错误进行错误输出</span><br><span class="line">    if v, err := GetFibonacci(-10); err != nil &#123;</span><br><span class="line">        t.Error(err)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t.Log(v)</span><br><span class="line">    &#125;</span><br><span class="line">    /** 运行结果</span><br><span class="line">    === RUN   TestGetFibonacci</span><br><span class="line">        TestGetFibonacci: err_test.go:22: n should be in [2,100]</span><br><span class="line">    --- FAIL: TestGetFibonacci (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在有个需求，返回的值是太小了还是太大了，返回不同的错误，最简单的方法直接改造<code>GetFibonacci</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func GetFibonacci(n int) ([]int, error) &#123;</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return nil, errors.New(&quot;n should be not less than 2&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if n &gt; 100 &#123;</span><br><span class="line">        return nil, errors.New(&quot;n should be not larger than 100&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fibList := []int&#123;1, 2&#125;</span><br><span class="line"></span><br><span class="line">    for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">        fibList = append(fibList, fibList[i-2]+fibList[i-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return fibList, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果区分错误类型，依靠字符串去匹配简直太麻烦还容易出错，最常见的解决方法，定义两个预置的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var LessThanTwoError = errors.New(&quot;n should be not less than 2&quot;)</span><br><span class="line">var LargerThenHundredError = errors.New(&quot;n should be not larger than 100&quot;)</span><br><span class="line"></span><br><span class="line">func GetFibonacci(n int) ([]int, error) &#123;</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return nil, LessThanTwoError</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if n &gt; 100 &#123;</span><br><span class="line">        return nil, LargerThenHundredError</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fibList := []int&#123;1, 2&#125;</span><br><span class="line"></span><br><span class="line">    for i := 2; i &lt; n; i++ &#123;</span><br><span class="line">        fibList = append(fibList, fibList[i-2]+fibList[i-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return fibList, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGetFibonacci(t *testing.T) &#123;</span><br><span class="line">    // 如果有错误进行错误输出</span><br><span class="line">    if v, err := GetFibonacci(-10); err != nil &#123;</span><br><span class="line">        // 假如调用者需要判断错误的就比较简单了</span><br><span class="line">        if err == LessThanTwoError &#123;</span><br><span class="line">            fmt.Println(&quot;It is less.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        t.Error(err)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t.Log(v)</span><br><span class="line">    &#125;</span><br><span class="line">    /** 运行结果</span><br><span class="line">    === RUN   TestGetFibonacci</span><br><span class="line">    It is less.</span><br><span class="line">        TestGetFibonacci: err_test.go:36: n should be not less than 2</span><br><span class="line">    --- FAIL: TestGetFibonacci (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>  定义不同的错误变量，以便于判断错误类型</li><li>  及早失败，避免嵌套，提高代码可读性</li></ul><h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>panic：</p><ul><li>  <code>panic</code> 用于不可以恢复的错误</li><li>  <code>panic</code> 退出前会执行 <code>defer</code> 指定的内容</li></ul><p>panic vs. os.Exit：</p><ul><li>  <code>os.Exit</code> 退出时不会调用 <code>defer</code> 指定的函数</li><li>  <code>os.Exit</code> 退出时不输出当前调用栈的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func TestExit(t *testing.T) &#123;</span><br><span class="line">    fmt.Println(&quot;Start&quot;)</span><br><span class="line">    os.Exit(-1)</span><br><span class="line">    /** 运行结果</span><br><span class="line">    === RUN   TestExit</span><br><span class="line">    Start</span><br><span class="line"></span><br><span class="line">    Process finished with exit code 1</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestPanic(t *testing.T) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        fmt.Println(&quot;Finally!&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&quot;Start&quot;)</span><br><span class="line">    panic(errors.New(&quot;Something wrong!&quot;))</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestPanic</span><br><span class="line">    Start</span><br><span class="line">    Finally!</span><br><span class="line">    --- FAIL: TestPanic (0.00s)</span><br><span class="line">    panic: Something wrong! [recovered]</span><br><span class="line">        panic: Something wrong!</span><br><span class="line"></span><br><span class="line">    goroutine 6 [running]:</span><br><span class="line">    testing.tRunner.func1.1(0x1119860, 0xc000046510)</span><br><span class="line">        /usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:940 +0x2f5</span><br><span class="line">    testing.tRunner.func1(0xc00011a120)</span><br><span class="line">        /usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:943 +0x3f9</span><br><span class="line">    panic(0x1119860, 0xc000046510)</span><br><span class="line">        /usr/local/Cellar/go/1.14.2_1/libexec/src/runtime/panic.go:969 +0x166</span><br><span class="line">    command-line-arguments.TestPanic(0xc00011a120)</span><br><span class="line">        /Users/gaobinzhan/Documents/Go/learning/src/test/err_test.go:65 +0xd7</span><br><span class="line">    testing.tRunner(0xc00011a120, 0x114afa0)</span><br><span class="line">        /usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:991 +0xdc</span><br><span class="line">    created by testing.(*T).Run</span><br><span class="line">        /usr/local/Cellar/go/1.14.2_1/libexec/src/testing/testing.go:1042 +0x357</span><br><span class="line"></span><br><span class="line">    Process finished with exit code 1</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>大家在写c++或者php代码的时候，总有一种习惯不希望这个程序被中断或者退出，用来捕获。</p><p>php代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch (\Throwable $throwable) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++ 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;catch(...)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func()&#123;</span><br><span class="line">  if err := recover(); err != nil &#123;</span><br><span class="line">    // 恢复错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func TestRecover(t *testing.T) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err := recover(); err != nil &#123;</span><br><span class="line">            // 没有写错误恢复 只是打印出来了</span><br><span class="line">            fmt.Println(&quot;recovered from&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&quot;Start&quot;)</span><br><span class="line">    panic(errors.New(&quot;Something wrong!&quot;))</span><br><span class="line">    /** 运行结果：</span><br><span class="line">    === RUN   TestRecover</span><br><span class="line">    Start</span><br><span class="line">    recovered from Something wrong!</span><br><span class="line">    --- PASS: TestRecover (0.00s)</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常见的”错误恢复”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">  if err := recover(); err != nil &#123;</span><br><span class="line">    log.Error(&quot;recovered panic&quot;,err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>当心！<code>recover</code> 成为恶魔：</p><ul><li>  形成僵尸服务进程，导致 health check 失效。</li><li>  “Let it Crash!” 往往是我们恢复不确定性错误的最好方法。</li></ul><p>就如上常见的“错误恢复”只是记录了一下，这样的恢复方式是非常危险的。</p><p>一定要当心我们自己 <code>recover</code> 在做的事，因为我们 <code>recover</code> 的时候并不去检测错误到底发生了什么错误，而是简单的记录了一下或者忽略。</p><p>这时候可能是系统里面的某些核心资源已经消耗完了，我们这样把它强制恢复掉，其实系统依然不能够正常地工作的，还是导致我们的一些健康检查程序 health check 没有办法检查出当前系统的问题。</p><p>因为很多的这种 health check 只是检查当前的系统进程在还是不在，因为我们的进程是在的，所以就会导致一种僵尸服务进程，它好像活着，但它也不能提供服务。</p><p>这种情况下个人认为倒不如采用一种可恢复的设计模式其中的一种叫 <code>Let it Crash</code> ，干脆 <code>Crash</code>掉，一旦<code>Crash</code>掉 守护进程 ，就会帮我们的服务进程重新提起来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go的错误机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  没有异常机制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error&lt;/code&gt; 类型实现了 &lt;code&gt;error&lt;/code&gt; 接口  &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>微信自动回复图片</title>
    <link href="https://stitch.cn/2020/09/20/%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%9B%BE%E7%89%87.html"/>
    <id>https://stitch.cn/2020/09/20/%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%9B%BE%E7%89%87.html</id>
    <published>2020-09-20T19:30:36.000Z</published>
    <updated>2021-10-01T03:05:23.220Z</updated>
    
    <content type="html"><![CDATA[<p>在微信开发的页面上，设置好触发的关键词，及触发后跳转到指定的接口地址，如:<a href="http://www.gaobinzhan.com/picture.php">http://www.gaobinzhan.com/picture.php</a><br>然后在网站服务器上创建picture.php文件，文件代码如下：</p><p>这样，在微信服务号上输入对应的关键字，服务号上就会返回对应的图片。</p><p>MediaID的获取方法：登陆微信公众平台-&gt;开发者工具-&gt;在线接口调试工具</p><p><strong>接口类型选：基础支持</strong></p><p>先获取access_token</p><p>access_token每次登陆都会变更</p><p>获取access_token后，接口列表选择多媒体文件上传接口<br>填入access_token，type选择image，media选择要回复的图片，图片上传成功后，就会返回一个MediaID，把它填入上面的代码中就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在微信开发的页面上，设置好触发的关键词，及触发后跳转到指定的接口地址，如:&lt;a href=&quot;http://www.gaobinzhan.com/picture.php&quot;&gt;http://www.gaobinzhan.com/picture.php&lt;/a&gt;&lt;br&gt;然后在网站服务</summary>
      
    
    
    
    <category term="uncategorized" scheme="https://stitch.cn/categories/uncategorized/"/>
    
    
  </entry>
  
</feed>
