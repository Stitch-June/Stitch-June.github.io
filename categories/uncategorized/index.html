<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: uncategorized - Stitch&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Stitch&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Stitch&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Stitch&#039;s Blog"><meta property="og:url" content="http://stitch.cn/"><meta property="og:site_name" content="Stitch&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://stitch.cn/img/og_image.png"><meta property="article:author" content="stitch"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://stitch.cn"},"headline":"Stitch's Blog","image":["http://stitch.cn/img/og_image.png"],"author":{"@type":"Person","name":"stitch"},"publisher":{"@type":"Organization","name":"Stitch's Blog","logo":{"@type":"ImageObject","url":{"text":"Stitch's Blog"}}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Stitch&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">uncategorized</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-01T00:40:00.000Z" title="4/1/2021, 12:40:00 AM">2021-04-01</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">7 分钟读完 (大约986个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/01/redis-%E9%93%BE%E8%A1%A8.html">Redis-链表</a></h1><div class="content"><h1 id="Redis-链表"><a href="#Redis-链表" class="headerlink" title="Redis-链表"></a>Redis-链表</h1><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。</p>
<p>作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为<code>Redis</code>使用的<code>c</code>语言并没有内置这种数据结构，所以<code>Redis</code>构建了自己的链表实现。</p>
<p>链表在<code>Redis</code>中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串的时，<code>Redis</code>就会使用链表作为列表键的实现。</p>
<p>举个例子，以下展示的<code>integers</code>列表键包含了<code>1-1024</code>共一千零二十四个整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN integers</span><br><span class="line">(integer) 1024</span><br><span class="line">redis&gt; LRANGE integers 0 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br><span class="line">9) &quot;9&quot;</span><br><span class="line">10) &quot;10&quot;</span><br><span class="line">11) &quot;11&quot;</span><br></pre></td></tr></table></figure>

<p><code>integers</code>列表键的底层实现就是一个链表，链表中的每个节点都保存了一个整数值。<br>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，<code>Redis</code>服务器本身还是要链表保存多个客户端信息的状态信息，以及使用链表来构建客户端输出缓冲区<code>（output buffer）</code>。</p>
<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>每个链接节点使用一个<code>adlist.h/listNode</code>结构来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">        // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个<code>listNode</code>可以通过<code>prev</code>和<code>next</code>指针组成双端列表，如下图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/GppfqG.png"></p>
<p>虽然仅仅使用多个<code>listNode</code>结构就可以组成链表，但使用<code>adlist.h/list</code>来持有链表的话，操作起来会更方便：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">        // 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    // 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>

<p><code>list</code>结构为链表提供了表头指针<code>head</code>、表尾指针<code>tail</code>，以及链表长度计数器<code>len</code>，而<code>dup</code>、<code>free</code>和<code>match</code>成员则是用于实现多态链表所需要的类型特定函数：</p>
<ul>
<li>  <code>dup</code>函数用于复制链表节点所保存的值；</li>
<li>  <code>free</code>函数用于释放链表节点所保存的值；</li>
<li>  <code>match</code>函数则用于对比链表节点所保存的值和另一个输入值是否相等；</li>
</ul>
<p>下图是由一个<code>list</code>结构和三个<code>listNode</code>结构组成的链表。</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/9MYc5C.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Redis</code>的链表实现的特性可以总结如下：</p>
<ul>
<li>  双端：链表节点带有<code>prev</code>和<code>next</code>指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li>
<li>  无环：表头节点的<code>prev</code>指针和表尾节点的<code>next</code>指针都指向<code>NULL</code>，对链表的访问以<code>NULL</code>为终点。</li>
<li>  带表头指针和表尾指针：通过<code>list</code>结构的<code>head</code>指针和<code>tail</code>指针，程序获取链表的表头节点和表为节点的复杂度为O(1)。</li>
<li>  带链表长度计数器：程序使用<code>list</code>结构的<code>len</code>属性来对<code>list</code>持有的链表节点进行计数，程序获取链表中节点数量的的复杂度为O(1)。</li>
<li>  多态：链表节点使用<code>void*</code>指针来保存节点值，并且可以通过<code>list</code>结构的<code>dup</code>，<code>free</code>，<code>match</code>三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><p>如果我的文章对您有帮助：打赏一下哟！<a target="_blank" rel="noopener" href="https://beg.gaobinzhan.com/">传送门</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-31T01:09:00.000Z" title="3/31/2021, 1:09:00 AM">2021-03-31</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">22 分钟读完 (大约3281个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/31/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html">Redis-简单动态字符串SDS</a></h1><div class="content"><h1 id="Redis-简单动态字符串SDS"><a href="#Redis-简单动态字符串SDS" class="headerlink" title="Redis-简单动态字符串SDS"></a>Redis-简单动态字符串SDS</h1><blockquote>
<p>好久没写博客了，今天水一篇文章。</p>
</blockquote>
<p><code>Redis</code>没有使用<code>c</code>语言传统的字符串去表示。而是构建了一种名为简单动态字符串<code>（simple dynamic string, SDS）</code>的抽象类型，并将<code>sds</code>用作<code>redis</code>的默认字符串表示。</p>
<p>举个例子<code>set msg &quot;hello world&quot;</code>：</p>
<ul>
<li>  键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg“的<code>sds</code>。</li>
<li>  键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的<code>sds</code>。</li>
</ul>
<p>又比如<code>rpush fruits &quot;apple&quot; &quot;banana&quot;</code>：</p>
<ul>
<li>  键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg“的<code>sds</code>。</li>
<li>  键值对的值是一个列表对象，列表对象包含了两个字符串对象，一个<code>sds</code>保存着<code>apple</code>，另一个保存着<code>banana</code>。</li>
</ul>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>每个<code>sds.h/sdshdr</code>结构表示一个<code>SDS</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    // 记录buf数组中已使用字节数量 等于sds所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    </span><br><span class="line">    // 记录buf数组中未使用的字节数量</span><br><span class="line">    int free;</span><br><span class="line">    </span><br><span class="line">    // 字节数组 用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://qiniu.gaobinzhan.com/uPic/BN0M1U.png"></p>
<ul>
<li>  <code>free</code>属性值为0，表示这个<code>sds</code>没有分配任何使用空间。</li>
<li>  <code>len</code>属性值为5，表示这个<code>sds</code>保存了一个五字节长的字符串。</li>
<li>  <code>buf</code>属性是一个<code>char</code>类型的数组，数组的前5个字节分别保存了为<code>R</code>，<code>e</code>，<code>d</code>，<code>i</code>，<code>s</code>五个字符，而最后一个字节则保存了空字符<code>�</code>。</li>
</ul>
<p><code>sds</code>遵循<code>c</code>语言字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在<code>sds</code>的<code>len</code>属性里面。并且为空字符分配额外的1字节空间及添加空字符到字符串末尾等操作都是有<code>sds</code>函数自动完成，所以这个空字符对于<code>sds</code>的使用者是完全透明的。</p>
<h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p><code>c</code>语言字符串使用长度为<code>N+1</code>的字符数组表示长度为<code>N</code>的字符串，并且字符数组的最后一个元素为空字符<code>�</code>。</p>
<p>这种简单的字符串不能满足<code>redis</code>对字符串在安全性、效率性以及功能方面的要求。</p>
<h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p><code>c</code>字符串并不记录自身的长度信息，所以获取一个<code>c</code>字符串的长度，程序需要遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，时间复杂度为<code>O(N)</code>。</p>
<p><code>sds</code>在<code>len</code>属性记录了<code>sds</code>本身的长度，所以获取一个<code>sds</code>的长度复杂度为<code>O(1)</code>。</p>
<p>设置和更新<code>sds</code>的长度工作是由<code>sds</code>的<code>api</code>在执行时自动完成的，使用<code>sds</code>无须进行任何手动修改长度的工作。</p>
<p>通过使用<code>sds</code>而不是<code>c</code>字符串，<code>redis</code>将获取字符串长度所需的时间复杂度从<code>O(N)</code>降低到了<code>O(1)</code>，这确保了获取字符串长度的工作不会成为<code>redis</code>的性能瓶颈。</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p><code>c</code>字符串不记录自身长度将会带来另一个问题：容易造成缓冲区溢出<code>（buffer overflow）</code>。</p>
<p><code>strcat</code>函数可以将<code>src</code>字符串的内容拼接到<code>dest</code>字符串末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *dest, const char *src);</span><br></pre></td></tr></table></figure>

<p>因为<code>c</code>字符串不记录自身的长度，所以<code>stract</code>假定用户在执行这个函数时，已经为<code>dest</code>分配了足够多的内存，可以容纳<code>src</code>字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出。</p>
<p>举个例子，假设程序有两个在内存中紧邻着的<code>c</code>字符串<code>s1</code>和<code>s2</code>，其中<code>s1</code>保存了字符串<code>redis</code>，而<code>s2</code>则保存了字符串<code>MongoDb</code>。如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/YVa6A5.png"></p>
<p>如果一个程序决定通过执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(s1, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure>

<p>将<code>s1</code>的内容修改为<code>Redis Cluster</code>，但粗心的却忘记了在执行<code>strcat</code>之前为<code>s1</code>分配足够的空间，那么函数执行之后，<code>s1</code>的数据将溢出到<code>s2</code>所在的空间中，导致<code>s2</code>保存的内容被意外的修改。如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/4MUtLG.png"></p>
<p>与<code>c</code>字符串不同，<code>sds</code>的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当<code>sds</code>的<code>api</code>需要对<code>sds</code>进行修改时，<code>api</code>会先检查<code>sds</code>的空间是否满足修改所需的要求，如果不满足，会自动将<code>sds</code>的空间扩展至执行修改所需要的大小，然后才执行实际的修改操作。所以使用<code>sds</code>不需要手动修改<code>sds</code>的空间大小，也不会出现缓冲区溢出问题。</p>
<p>举个例子：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/xFGvKA.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, &quot; Cluster&quot;)</span><br></pre></td></tr></table></figure>

<p><code>sdscat</code>将在执行拼接操作之前检查<code>s</code>的长度是否足够，不够将扩展空间，才去执行拼接操作，拼接完成后的<code>sds</code>如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/0CT0tl.png"></p>
<p><code>sdscat</code>不仅为这个<code>sds</code>进行拼接操作，还分配了<code>13</code>字节的未使用空间，并且拼接之后的字符串正好也是<code>13</code>字节，这不是<code>bug</code>，而是与<code>sds</code>的分配空间策略有关，下面会说明。</p>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>因为<code>c</code>字符串的长度和底层数组的长度直接存在着关联关系，所以<code>c</code>语言字符串每次增长或者缩短都要进行一次内存重新分配操作；</p>
<ul>
<li>  如果程序执行增长字符串操作，执行操作前，程序需要先通过内存重新分配来扩展底层空间大小，忘记这步操作将会产生缓冲区溢出。</li>
<li>  如果程序执行缩短字符串操作，执行操作后，程序需要通过内存重新分配来释放字符串不使用的空间，忘记这步操作会产生内存泄露。</li>
</ul>
<p>对于<code>redis</code>，经常被用于速度要求严苛、数据被频繁修改的场景，如果每次修改字符串长度都要执行一次内存分配，光是执行内存重新分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁发生，可能会对性能造成影响。</p>
<p>为了避免<code>c</code>字符串的这种缺陷，<code>sds</code>通过未使用空间解决了字符串长度和底层数组长度之间的关联。通过未使用空间，<code>sds</code>实现了空间预分配和惰性空间释放两种优化策略。</p>
<p><strong>空间预分配</strong>：</p>
<p>空间预分配用于优化<code>sds</code>的字符串增长操作：当<code>sds</code>的<code>api</code>对一个<code>sds</code>进行修改，并且需要对<code>sds</code>进行空间扩展的时候，程序不仅会为<code>sds</code>分配修改所必须要的空间，还会为<code>sds</code>分配额外的未使用空间。</p>
<p>其中，额外分配未使用空间数量由以下公式决定：</p>
<ul>
<li>  如果对<code>sds</code>进行修改后，<code>sds</code>的长度将小于<code>1mb</code>，那么程序会分配和<code>len</code>属性同样大小的未使用空间，这时<code>sds</code>的<code>len</code>属性和<code>free</code>的值相同。举个例子，进行修改后<code>len</code>为<code>10</code>，那么<code>free</code>也为<code>10</code>，<code>sds</code>的<code>buf</code>数组的实际长度为<code>10 + 10 + 1 = 21</code>。</li>
<li>  如果对<code>sds</code>进行修改后，<code>sds</code>的长度将大于<code>1mb</code>，那么程序会分配<code>1mb</code>的使用空间。举个例子，进行修改后<code>len</code>为<code>10mb</code>，那么<code>free</code>为<code>1mb</code>，<code>sds</code>的<code>buf</code>数组的实际长度为<code>10mb + 1mb + 1byte</code>。</li>
</ul>
<p><strong>懒惰空间释放</strong></p>
<p>懒惰空间释放用于优化<code>sds</code>的字符串缩短操作：当<code>sds</code>的<code>api</code>需要缩短<code>sds</code>保存的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的自己，而是使用<code>free</code>属性将这些字节的数量记录起来，并等待将来使用。</p>
<p>举个例子，<code>sdstrim</code>函数接受一个<code>sds</code>和一个<code>c</code>字符串作为参数，从<code>sds</code>左右两端分别移出所以在<code>c</code>字符串中出现的字符。</p>
<p>如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/VqVvsH.png"></p>
<p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdstrim(s, &quot;XY&quot;); // 移除 sds 字符串中所有 ‘X’和‘Y’</span><br></pre></td></tr></table></figure>

<p>会将<code>sds</code>修改成如下图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/W9ADsH.png"></p>
<p>注意执行<code>sdstrim</code>之后的<code>sds</code>并没有释放出来多余的<code>8</code>字节空间，而是将这<code>8</code>字节空间作为未使用空间保留在了<code>sds</code>里面，如果将来要<code>sds</code>进行增长操作，这些未使用空间就会用上。</p>
<p>举个例子，现在对<code>s</code>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s, &quot; Redis&quot;);</span><br></pre></td></tr></table></figure>

<p>那么完成这次<code>sdscat</code>操作将不需要执行内存重新分配，因为<code>sds</code>预留的<code>8</code>字节空间足以拼接<code>6</code>个字节的 <code>Redis</code>，通过惰性空间释放策略，<code>sds</code>避免了缩短字符串所需的内存重分配操作，并为将来可能有的增长操作提供了优化，如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/Tq96Th.png"></p>
<p>与此同时，<code>sds</code>也提供了相应的<code>api</code>，让我们可以在有需要时，真正的释放<code>sds</code>的未使用空间，所以不必担心惰性空间释放策略会造成内存浪费。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p><code>c</code>字符串中的字符必须符合某种编码<code>（比如 ASCII）</code>，并且除了字符串的末尾之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得<code>c</code>字符串只能保存文本数据，不能保存图片、音频这样的二进制数据。</p>
<p>举个例子，如果有一种使用空字符串分割多个单词的特殊数据格式，那么这种格式就不能使用<code>c</code>字符串来保存，因为<code>c</code>字符串所用的函数之后识别出其中的<code>Redis</code>，而忽略之后的<code>Cluster</code>。如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/AUOHC0.png"></p>
<p>而<code>sds</code>的<code>buf</code>属性被成为字节数组的原因——<code>redis</code>不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</p>
<p>例如，使用<code>sds</code>来保存之前提到的数据格式就没有问题，因为<code>sds</code>使用<code>len</code>属性的值而不是空字符来判断字符串是否结束，如图：</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/sCJWub.png"></p>
<h3 id="兼容部分c字符串函数"><a href="#兼容部分c字符串函数" class="headerlink" title="兼容部分c字符串函数"></a>兼容部分c字符串函数</h3><p>虽然<code>sds</code>的<code>api</code>都是二进制安全，但它们一样遵循<code>c</code>字符串以空字符串结尾的惯例：这些<code>api</code>总会将<code>sds</code>保存的数据的末尾设置为空字符，并且总会在为<code>buf</code>数组分配空间时多分配一个字节来容纳这个字符串，这是为了让那些保存文本数据的<code>sds</code>可以重用一部分<code>&lt;string.h&gt;</code>库定义的函数。</p>
<p><img src="https://qiniu.gaobinzhan.com/uPic/1ntPZ1.png"></p>
<p>举个例子，如果有一个保存文本数据的<code>sds</code>，如上图，那么我们就可以重用<code>&lt;string.h&gt;/strasecmp</code>函数，使用它来对比<code>sds</code>保存的字符串另一个<code>c</code>字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf, &quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<p>遵循<code>c</code>字符串以空字符结尾的惯例，<code>sds</code>可以在有需要时重用<code>&lt;string.h&gt;</code>函数库，避免不必要的代码重复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C字符串</p>
<p>SDS</p>
<p>获取字符串长度的复杂度为O(N)</p>
<p>获取字符串长度的复杂度为O(1)</p>
<p>API是不安全的，可能会造成缓冲区溢出</p>
<p>API是安全的，不会造成缓冲区溢出</p>
<p>修改字符串长度N次必然需要执行N次内存重分配</p>
<p>修改字符串长度N次最多需要执行N次内存重分配</p>
<p>只能保存文本数据</p>
<p>可以保存文本数据或者二进制数据</p>
<p>可以使用<code>&lt;string.h&gt;</code>库中的函数</p>
<p>可以使用一部分<code>&lt;string.h&gt;</code>库中的函数</p>
<h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><p>如果我的文章对您有帮助：打赏一下哟！<a target="_blank" rel="noopener" href="https://beg.gaobinzhan.com/">传送门</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-27T12:28:48.000Z" title="9/27/2020, 12:28:48 PM">2020-09-27</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">6 分钟读完 (大约946个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/27/go%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88-binzs-blog.html">Go常用集合</a></h1><div class="content"><p>[Toc]</p>
<h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int // 声明并初始化为默认零值</span><br><span class="line">a[0] = 1</span><br><span class="line">b := [3]int&#123;1, 2, 3&#125;           // 声明同时初始化</span><br><span class="line">c := [2][2]int&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125; // 多维数组初始化</span><br><span class="line">t.Log(a[0], a[2])</span><br><span class="line">t.Log(b[2])</span><br><span class="line">t.Log(c[1][1])</span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125; // 自动判断长度</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; len(arr); i++ &#123; // 典型写法遍历数组</span><br><span class="line">    t.Log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for idx, e := range arr &#123; // 相当于其它语言的foreach</span><br><span class="line">    t.Log(idx, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, e := range arr &#123; // 我们可能用不到 idx 但go语言定义一个值不去使用编译会不通过 使用_代表不关心这个结果，来占位</span><br><span class="line">    t.Log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截取：</p>
<p>a[开始索引(包含):结束索引(不包含)]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125;</span><br><span class="line">// a[开始索引(包含):结束索引(不包含)]</span><br><span class="line">t.Log(arr[0:1]) // 1</span><br><span class="line">t.Log(arr[2:]) // 3 4 5 6</span><br><span class="line">t.Log(arr[1:len(arr)]) // 2 3 4 5 6</span><br><span class="line">t.Log(arr[1:3]) // 2 3</span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>内部结构：</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/13/7106b2933bdf9.jpeg"></p>
<p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var s0 []int            // 定义看起来特别像数组，但没有指定长度</span><br><span class="line">t.Log(len(s0), cap(s0)) // 0 0</span><br><span class="line">s0 = append(s0, 1)</span><br><span class="line">t.Log(len(s0), cap(s0)) // 1 1</span><br><span class="line"></span><br><span class="line">s1 := []int&#123;1, 2, 3, 4&#125; // 初始化一个切片</span><br><span class="line">t.Log(len(s1), cap(s1)) // 4 4</span><br><span class="line"></span><br><span class="line">// []type,len,cap 其中len个元素会被初始化为默认零值，未初始化元素不可以访问</span><br><span class="line">s2 := make([]int, 3, 5)    // len为3 cap为5</span><br><span class="line">t.Log(len(s2), cap(s2))    // 3 5</span><br><span class="line">t.Log(s2[0], s2[1], s2[2]) // 成功被初始化 结果：0 0 0</span><br><span class="line">//t.Log(s2[0], s2[1], s2[2], s2[3]) // 出现了一个错误 index out of range [3]</span><br><span class="line">s2 = append(s2, 1)</span><br><span class="line">t.Log(s2[0], s2[1], s2[2], s2[3]) // 0 0 0 1</span><br><span class="line">t.Log(len(s2), cap(s2))           // 4 5 len变成了4</span><br></pre></td></tr></table></figure>

<p>共享存储结构：</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/13/775b24bebfd13.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s := []int&#123;&#125;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    s = append(s, i) // 为什么重新赋值给s,是因为结构体指向的连续存储空间进行了变化,并把原有的连续存储空间拷贝到新的连续存储空间</span><br><span class="line">    t.Log(len(s), cap(s))</span><br><span class="line">&#125;</span><br><span class="line">/** 运行结果：当len不够用的时候会增长，cap不够用的时候增长为前一个cap的2倍</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 1 1</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 2 2</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 3 4</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 4 4</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 5 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 6 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 7 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 8 8</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 9 16</span><br><span class="line">    TestSliceGrowing: slice_test.go:28: 10 16</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="Map声明、元素访问及遍历"><a href="#Map声明、元素访问及遍历" class="headerlink" title="Map声明、元素访问及遍历"></a>Map声明、元素访问及遍历</h2><p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m1 := map[int]int&#123;1: 1, 2: 4, 3: 9&#125; // 初始化一个map</span><br><span class="line">t.Log(m1[2])                        // 4</span><br><span class="line">t.Logf(&quot;len m1 = %d&quot;, len(m1))      // len m1 = 3</span><br><span class="line">m2 := map[int]int&#123;&#125;                 // 初始化一个空map</span><br><span class="line">m2[4] = 16                          // 赋值</span><br><span class="line">t.Logf(&quot;len m2 = %d&quot;, len(m2))      // len m2 = 1</span><br><span class="line">m3 := make(map[int]int, 10)         // 使用make初始化map</span><br><span class="line">t.Logf(&quot;len m3 = %d&quot;, len(m3))      // len m3 = 0 填的len为10,但打印出来为0</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// key在map中存在吗？</span><br><span class="line">// key存在但是对应的值是空值</span><br><span class="line">m1 := map[int]int&#123;&#125;</span><br><span class="line">t.Log(m1[1]) // 0 不存在输出0</span><br><span class="line">m1[2] = 0    // 设置value正好为0</span><br><span class="line">t.Log(m1[2]) // 0 也是0 该如何判断key是否存在呢</span><br><span class="line">// 需要主动去判断</span><br><span class="line">if v, ok := m1[3]; ok &#123;</span><br><span class="line">    t.Logf(&quot;key 3&#x27;s value is %d&quot;, v)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Log(&quot;key 3 is not existing.&quot;) // 将输出这句话</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1[3] = 9</span><br><span class="line">if v, ok := m1[3]; ok &#123;</span><br><span class="line">    t.Logf(&quot;key 3&#x27;s value is %d&quot;, v) // 将输出这句话</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Log(&quot;key 3 is not existing.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m1 := map[int]int&#123;1: 1, 2: 4, 3: 9&#125;</span><br><span class="line">for k, v := range m1 &#123;</span><br><span class="line">    t.Log(k, v)</span><br><span class="line">&#125;</span><br><span class="line">/** 运行结果</span><br><span class="line">    TestTravelMap: map_test.go:41: 1 1</span><br><span class="line">    TestTravelMap: map_test.go:41: 2 4</span><br><span class="line">    TestTravelMap: map_test.go:41: 3 9</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="Map与工厂模式，实现Set"><a href="#Map与工厂模式，实现Set" class="headerlink" title="Map与工厂模式，实现Set"></a>Map与工厂模式，实现Set</h2><ul>
<li>  Map的value可以是一个方法</li>
<li>  与Go的Dock type接口方式一起，可以方便的实现单一方法对象的工厂模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m := map[int]func(op int) int&#123;&#125;</span><br><span class="line">m[1] = func(op int) int &#123;</span><br><span class="line">    return op</span><br><span class="line">&#125;</span><br><span class="line">m[2] = func(op int) int &#123;</span><br><span class="line">    return op * op</span><br><span class="line">&#125;</span><br><span class="line">m[3] = func(op int) int &#123;</span><br><span class="line">    return op * op * op</span><br><span class="line">&#125;</span><br><span class="line">t.Log(m[1](2), m[2](2), m[3](2)) // 运行结果 2 4 8</span><br></pre></td></tr></table></figure>

<p>实现Set：</p>
<p>Go内置集合中没有Set实现，可以<code>map[type]bool</code></p>
<ul>
<li>  元素的唯一性</li>
<li>基本操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mySet := map[int]bool&#123;&#125;</span><br><span class="line">mySet[1] = true // 添加元素 value置为true</span><br><span class="line">n := 1</span><br><span class="line">if mySet[n] &#123;</span><br><span class="line">    t.Logf(&quot;%d is existing.&quot;, n) // 输出这句话</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Logf(&quot;%d is not existing.&quot;, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(mySet, 1) // 把1这个key从map中删除</span><br><span class="line"></span><br><span class="line">if mySet[n] &#123;</span><br><span class="line">    t.Logf(&quot;%d is existing.&quot;, n)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    t.Logf(&quot;%d is not existing.&quot;, n) // 输出这句话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-27T12:15:12.000Z" title="9/27/2020, 12:15:12 PM">2020-09-27</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">19 分钟读完 (大约2900个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/27/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86-binzs-blog.html">redis之主从问题处理</a></h1><div class="content"><ul>
<li>Slaveof  <code>slaveof</code>  <strong>slave</strong>实例需要配置该项，指向<strong>master</strong>的(ip,port)</li>
<li>masterauth  <code>masterauth</code>  如果<strong>master</strong>实例启用了密码保护，则该配置项需要填<strong>master</strong>的启动密码；  如果未启用，需要将该配置项注视掉。</li>
<li>slave-serve-stale-data  指定<strong>slave</strong>与<strong>master</strong>连接中断时的动作。默认为<strong>yes</strong>，表明<strong>slave</strong>会继续应答来自<strong>client</strong>的请求，但这些数据可能已经过期（因为连接中断导致无法从<strong>master</strong>同步）。若配置为<strong>no</strong>，则<strong>slave</strong>除正常应答“<strong>INFO</strong>”和“<strong>SLAVEOF</strong>”命令外，其余来自客户端的请求命令均会得到“<strong>SYNC with master in progress</strong>“的应答，直到该<strong>slave</strong>与<strong>master</strong>连接重建成功或该<strong>slave</strong>被提升为<strong>master</strong>。</li>
<li>slave-read-only  指定<strong>slave</strong>是否只读，默认为<strong>yes</strong>。若配置为<strong>no</strong>，表示<strong>slave</strong>是可写的，但写的内容在主从同步完成后会被删除掉。</li>
<li>repl-disable-tcp-nodelay  指定向<strong>slave</strong>同步数据时，是否禁用<strong>socket</strong>的<strong>NO_DELAY</strong>选项。若配置为<strong>yes</strong>，则禁用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈会合并小包统一发送，这样可以减少主从节点间的包数量并节省宽带，但会增加数据同步到<strong>slave</strong>的时间。若配置为<strong>no</strong>，表明启用<strong>NO_DELAY</strong>，则<strong>TCP</strong>协议栈不会延迟小包的发送时间，这样数据同步的延时会减少，但需要更大的宽带。</li>
<li>slave-priority  指定<strong>slave</strong>的优先级。在不只1个<strong>slave</strong>存在的部署环境下，当<strong>master</strong>宕机时，<strong>Redis Sentinel</strong> 会将<strong>priority</strong>值最小的<strong>slave</strong>提升为<strong>master</strong>。需要注意的是，若该配置项为0，则对应的<strong>slave</strong>永远不会被<strong>Redis Sentinel</strong> 自动提升为<strong>master</strong>。</li>
</ul>
<p><strong>Redis</strong>复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络宽带和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或通知客户端避免读取延迟过高的从节点。</p>
<p>具体实现逻辑：</p>
<ul>
<li>  监控程序定期检查主从节点的偏移量，主节点偏移量在<code>info replication</code>的<code>master_repl_offset</code>指标记录，从节点偏移量可以查询主节点的<code>slave0</code>字段的<code>offset</code>指标，它们的差值就是主从节点延迟的字节量。</li>
<li>  对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点，同时从节点的<code>slave-serve-stable-data</code>参数也与此有关，它控制这种情况下从节点的表现，当从库同主机失去连接或者复制正在进行，从机库有两种运行方式。</li>
</ul>
<h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>当主节点存储大量设置超时的数据时，redis内部需要维护过期数据删除策略，删除策略主要有两种：</p>
<ul>
<li>惰性删除  主节点每次处理读取命令时，都会检查健是否超时，如果超时则执行·<code>del</code>命令删除键对象，之后<code>del</code>命令也会异步发给从节点。因为保持复制的一致性，从节点自身永远不会主动删除超时数据。</li>
<li>定时删除  <strong>Redis</strong>主节点在内部定时任务会循环采样一定数据量的键，当发现采用的键过期时会执行<code>del</code>命令，之后再同步给从节点。</li>
</ul>
<h3 id="从节点故障问题"><a href="#从节点故障问题" class="headerlink" title="从节点故障问题"></a>从节点故障问题</h3><p>对于从节点的故障问题，需要在客户端维护一个可用从节点可用列表，当从节点故障时，立刻切换到其他从节点或主节点，<strong>redis Cluster</strong>可以解决这个问题。</p>
<h2 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h2><p>主节点和从节点不同，经常导致主节点和从节点的配置不同，并带来问题。</p>
<p>主从配置不一致是一个容易忽视的问题。对于有些配置主从之间是可以不一致，比如：主节点关闭AOF，从节点开启AOF。但对于内存相关的配置必须要一致，比如<code>maxmemory</code>,<code>hash-max-ziplist-entries</code>等参数。</p>
<p>数据丢失：主机和从机有时候发生配置不一致的情况，例如<code>maxmemory</code>不一致。假如主机配置<code>maxmemory</code>为8G，从机设置为4G，这个时候是可以用的，而且不会报错。但如果要做高可用，让从节点变成主节点的时候，就会发现数据已经丢失，而且无法挽回。</p>
<h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><p>全量复制指的是当<strong>slave</strong>断开并重启后，<strong>runid</strong>产生变化而导致需要在<strong>master</strong>主机里拷贝全部数据。这种拷贝全部数据的过程非常耗资源。</p>
<p>全量复制是不可避免的，例如第一次的全量复制就不可避免，这时我们需要选择小主节点，且<code>maxmemory</code>值不要过大，这样就会比较快。同时选择在低峰值的时候做全量复制。</p>
<p>造成全量复制的原因：</p>
<ul>
<li>  主从机的运行<strong>runid</strong>不匹配。解释一下，主节点如果重启，<strong>runid</strong>将会发生变化。如果从节点监控到<strong>runid</strong>不是同一个，它就会认为你的节点不安全。当发生故障转移的时候，如果主节点发生故障，那么从节点就会变成主节点（哨兵和集群）。</li>
<li>  复制缓冲区空间不足，比如默认值为1M，可以部分复制，但如果缓冲区不够大的话，首先需要网络中断，部分复制将无法满足。其次需要增大复制缓冲区配置<code>repl-backlog-size</code>，对网络的缓冲增强。</li>
</ul>
<p>怎么解决：</p>
<ul>
<li>  在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得<strong>runid</strong>发生变化，可能导致不必要的全量复制。</li>
<li>  为了解决这个问题，<strong>Redis</strong>提供了<strong>debug reload</strong>的重启方式：重启后，主节点的<strong>runid</strong>和<strong>offset</strong>都不受影响，避免了全量复制。</li>
</ul>
<h2 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h2><p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成大量开销，导致 CPU、内存、带宽消耗。因此我们应该分析出复制风暴发生的场景，提前采用合理的方式规避。规避方式有如下几个。</p>
<h3 id="单节点复制风暴"><a href="#单节点复制风暴" class="headerlink" title="单节点复制风暴"></a>单节点复制风暴</h3><p>当一个主机下面挂了很多个 <strong>slave</strong>从机的时候，主机 <strong>master</strong> 挂了，这时 <strong>master</strong> 主机重启后，因为 <strong>runid</strong> 发生了变化，所有的 <strong>slave</strong> 从机都要做一次全量复制。这将引起单节点和单机器的复制风暴，开销会非常大。</p>
<p>解决：</p>
<ul>
<li>  可以采用树状结构降低多个从节点对主节点的消耗。</li>
<li>  从节点采用树状树非常有用，网络开销交给位于中间层的从节点，而不必消耗顶层的主节点。但是这种树状结构也带来了运维的复杂性，增加了手动和自动 处理故障转移的难度。</li>
</ul>
<p><img src="http://qiniu.gaobinzhan.com/2020/06/05/26dc39cb9dfe5.png"></p>
<h3 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h3><p>由于 <strong>Redis</strong> 的单线程架构，通常单台机器会部署多个 <strong>Redis</strong> 实例。当一台机器（<strong>machine</strong>）上同时部署多个主节点（<strong>master</strong>）时，如果每个 <strong>master</strong> 主机只有一台 <strong>slave</strong> 从机，那么当机器宕机以后，会产生大量全量复制。这种情况是非常危险的情况，带宽马上会被占用，会导致不可用。</p>
<p>解决：</p>
<ul>
<li>  应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。</li>
<li>  当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。</li>
</ul>
<p><img src="http://qiniu.gaobinzhan.com/2020/06/05/4972dfad7a251.png"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>###########从库##############</p>
<p>#设置该数据库为其他数据库的从数据库</p>
<p><code>slaveof</code></p>
<p>#主从复制中，设置连接<strong>master</strong>服务器的密码（前提<strong>master</strong>启用了认证）</p>
<p><code>masterauth</code></p>
<p># 当从库同主库失去连接或者复制正在进行，从库有两种运行方式：</p>
<p># 1) 如果<code>slave-serve-stale-data</code>设置为<strong>yes</strong>(默认设置)，从库会继续相应客户端的请求</p>
<p># 2) 如果<code>slave-serve-stale-data</code>设置为<strong>no</strong>，除了<strong>INFO</strong>和<strong>SLAVOF</strong>命令之外的任何请求都会返回一个错误”<strong>SYNC with master in progress</strong>“</p>
<p><code>slave-serve-stale-data yes</code></p>
<p>#当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高</p>
<p><code>slave-priority 100</code></p>
<p>#从节点是否只读；默认<strong>yes</strong>只读，为了保持数据一致性，应保持默认。</p>
<p><code>slave-read-only yes</code></p>
<p>########主库配置##############</p>
<p>#在<strong>slave</strong>和<strong>master</strong>同步后（发送<strong>psync</strong>/<strong>sync</strong>），后续的同步是否设置成<strong>TCP_NODELAY</strong>假如设置成<strong>yes</strong>，则<strong>redis</strong>会合并小的<strong>TCP</strong>包从而节省带宽，但会增加同步延迟（40ms），造成<strong>master</strong>与<strong>slave</strong>数据不一致假如设置成<strong>no</strong>，则<strong>redis master</strong>会立即发送同步数据，没有延迟。</p>
<p>#前者关注性能，后者关注一致性</p>
<p><code>repl-disable-tcp-nodelay no</code></p>
<p>#从库会按照一个时间间隔向主库发送<strong>PING</strong>命令来判断主服务器是否在线，默认是10秒</p>
<p><code>repl-ping-slave-period 10</code></p>
<p>#复制积压缓冲区大小设置</p>
<p><code>repl-backlog-size 1mb</code></p>
<p>#<strong>master</strong>没有<strong>slave</strong>一段时间会释放复制缓冲区的内存，<code>repl-backlog-ttl</code>用来设置该时间长度。单位为秒。</p>
<p><code>repl-backlog-ttl 3600</code></p>
<p>#<strong>redis</strong>提供了可以让<strong>master</strong>停止写入的方式，如果配置了<code>min-slaves-to-write</code>，健康的<strong>slave</strong>的个数小于<strong>N</strong>，<strong>mater</strong>就禁止写入。<strong>master</strong>最少得有多少个健康的<strong>slave</strong>存活才能执行写命令。这个配置虽然不能保证<strong>N</strong>个<strong>slave</strong>都一定能接收到<strong>master</strong>的写操作，但是能避免没有足够健康的slave的时候，<strong>master</strong>不能写入来避免数据丢失。设置为0是关闭该功能。</p>
<p><code>min-slaves-to-write 3</code></p>
<p><code>min-slaves-max-lag 10</code></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T09:21:33.000Z" title="9/23/2020, 9:21:33 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">4 分钟读完 (大约532个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/go%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-binzs-blog.html">Go常见架构模式的实现</a></h1><div class="content"><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/b71e7f4c49b14.png"></p>
<p>Pipe-Filter 模式：</p>
<ul>
<li>  ⾮常适合与数据处理及数据分析系统</li>
<li>  Filter封装数据处理的功能</li>
<li>  Pipe⽤于连接Filter传递数据或者在异步处理过程中缓冲数据流</li>
<li>  进程内同步调⽤时，pipe演变为数据在⽅法调⽤间传递</li>
<li>  松耦合：Filter只跟数据（格式）耦合</li>
</ul>
<p>Filter和组合模式：</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/31/bcbb91db52add.png"></p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/31/687b15a34e92d.png"></p>
<p>示例：</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/31/acf328995b547.png"></p>
<p>简单示例代码：</p>
<p><code>filter.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Package pipefilter is to define the interfaces and the structures for pipe-filter style implementation</span><br><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">// Request is the input of the filter</span><br><span class="line">type Request interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Response is the output of the filter</span><br><span class="line">type Response interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Filter interface is the definition of the data processing components</span><br><span class="line">// Pipe-Filter structure</span><br><span class="line">type Filter interface &#123;</span><br><span class="line">    Process(data Request) (Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split_filter.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var SplitFilterWrongFormatError = errors.New(&quot;input data should be string&quot;)</span><br><span class="line"></span><br><span class="line">type SplitFilter struct &#123;</span><br><span class="line">    delimiter string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSplitFilter(delimiter string) *SplitFilter &#123;</span><br><span class="line">    return &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sf *SplitFilter) Process(data Request) (Response, error) &#123;</span><br><span class="line">    str, ok := data.(string) //检查数据格式/类型，是否可以处理</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        return nil, SplitFilterWrongFormatError</span><br><span class="line">    &#125;</span><br><span class="line">    parts := strings.Split(str, sf.delimiter)</span><br><span class="line">    return parts, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split_filter_test.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package pipefilter</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestStringSplit(t *testing.T) &#123;</span><br><span class="line">    sf := NewSplitFilter(&quot;,&quot;)</span><br><span class="line">    resp, err := sf.Process(&quot;1,2,3&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        t.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    parts, ok := resp.([]string)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        t.Fatalf(&quot;Repsonse type is %T, but the expected type is string&quot;, parts)</span><br><span class="line">    &#125;</span><br><span class="line">    if !reflect.DeepEqual(parts, []string&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;) &#123;</span><br><span class="line">        t.Errorf(&quot;Expected value is &#123;\&quot;1\&quot;,\&quot;2\&quot;,\&quot;3\&quot;&#125;, but actual is %v&quot;, parts)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestWrongInput(t *testing.T) &#123;</span><br><span class="line">    sf := NewSplitFilter(&quot;,&quot;)</span><br><span class="line">    _, err := sf.Process(123)</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        t.Fatal(&quot;An error is expected.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现micro-kernel-framework"><a href="#实现micro-kernel-framework" class="headerlink" title="实现micro-kernel framework"></a>实现micro-kernel framework</h2><p><img src="http://qiniu.gaobinzhan.com/2020/05/31/33be429a34caa.png"></p>
<ul>
<li>特点</li>
<li>  要点</li>
<li>内核包含公共流程或通⽤逻辑</li>
<li>抽象扩展点⾏为，定义接⼝</li>
</ul>
<p>示例：</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/05/31/8cf1559e63e02.png"></p>
<p>简单示例代码：</p>
<p><code>agent.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package microkernel</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Waiting = iota</span><br><span class="line">    Running</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var WrongStateError = errors.New(&quot;can not take the operation in the current state&quot;)</span><br><span class="line"></span><br><span class="line">type CollectorsError struct &#123;</span><br><span class="line">    CollectorErrors []error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ce CollectorsError) Error() string &#123;</span><br><span class="line">    var strs []string</span><br><span class="line">    for _, err := range ce.CollectorErrors &#123;</span><br><span class="line">        strs = append(strs, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    return strings.Join(strs, &quot;;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Event struct &#123;</span><br><span class="line">    Source  string</span><br><span class="line">    Content string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type EventReceiver interface &#123;</span><br><span class="line">    OnEvent(evt Event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Collector interface &#123;</span><br><span class="line">    Init(evtReceiver EventReceiver) error</span><br><span class="line">    Start(agtCtx context.Context) error</span><br><span class="line">    Stop() error</span><br><span class="line">    Destory() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Agent struct &#123;</span><br><span class="line">    collectors map[string]Collector</span><br><span class="line">    evtBuf     chan Event</span><br><span class="line">    cancel     context.CancelFunc</span><br><span class="line">    ctx        context.Context</span><br><span class="line">    state      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (agt *Agent) EventProcessGroutine() &#123;</span><br><span class="line">    var evtSeg [10]Event</span><br><span class="line">    for &#123;</span><br><span class="line">        for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case evtSeg[i] =</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T08:27:18.000Z" title="9/23/2020, 8:27:18 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.932Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">1 分钟读完 (大约157个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/%E9%93%BE%E6%8E%A5%E5%BA%93-binzs-blog.html">链接库</a></h1><div class="content"><blockquote>
<p>名称：Binz’s Blog<br>地址：<a target="_blank" rel="noopener" href="https://blog.gaobinzhan.com/%E6%8F%8F%E8%BF%B0%EF%BC%9A%E4%B8%8D%E7%AE%A1%E6%A2%A6%E6%83%B3%E6%9C%89%E5%A4%9A%E8%BF%9C,%E8%B5%B0%E4%BA%86%E5%A4%9A%E5%B0%91%E5%BC%AF%E8%B7%AF,%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9,%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E4%BC%9A%E5%9B%9E%E5%88%B0,%E9%82%A3%E4%B8%AA%E6%9C%80%E5%88%9D%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%81">https://blog.gaobinzhan.com/描述：不管梦想有多远,走了多少弯路,总有一天,我们还是会回到,那个最初的地方！</a></p>
<p>头像：<a target="_blank" rel="noopener" href="https://qiniu.gaobinzhan.com/2019/11/01/8854cd3f450d1.jpg">https://qiniu.gaobinzhan.com/2019/11/01/8854cd3f450d1.jpg</a></p>
</blockquote>
<blockquote>
<p>博客名称：（网站名称）博客网址：（需带协议）博客头像：（需一张图片）</p>
<p>博客介绍：[ 简介，没有也没事 ]</p>
</blockquote>
<blockquote>
<p>申请链接前请先添加本博链接！本站坚决不收政治的 / 涉黄的！网络技术 / 个人博客优先~</p>
<p>成功添加本站后请留言提醒！</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T08:12:22.000Z" title="9/23/2020, 8:12:22 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.932Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">9 分钟读完 (大约1275个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-binzs-blog-2.html">微服务架构常见的分布式事务解决方案</a></h1><div class="content"><p>多个服务，位于不同主机，不同的网络当中，没有办法用本地事务保证要么一起成功，要么一起失败。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p><strong>BA</strong>: Basic Availability 基本业务可用性（支持分区失败）</p>
<p><strong>S</strong>: Soft state 柔性状态（状态允许有短时间不同步，异步）</p>
<p><strong>E</strong>: Eventual consistency 最终一致性（最终数据是一致的，但不是实时一致）</p>
<p>原子性（A）与持久性（D）必须根本保障</p>
<p>为了可用性、性能与降级服务的需要，只有降低一致性( C ) 与 隔离性( I ) 的要求</p>
<p>酸碱平衡(ACID-BASE Balance)</p>
<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>对于共享数据系统，最多只能同时拥有CAP其中的两个，没法三者兼顾。</p>
<p>任意两者的组合都有其适用场景</p>
<p>真实系统应当是ACID与BASE的混合体</p>
<p>不同类型的业务可以也应当区别对待</p>
<p><img src="http://qiniu.gaobinzhan.com/2020/03/25/3513fb8ec53c2.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="http://qiniu.gaobinzhan.com/2020/03/25/7a81db1712105.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>业务处理服务在业务事务提交前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不真正发送。业务处理服务在业务事务提交后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>业务处理服务在业务事务回滚后，向实时消息服务取消发送。消息状态确认系统定期找到未确认发送或回滚发送的消息，向业务处理服务询问消息状态，业务处理服务根据消息ID或消息内容确定该消息是否有效</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>被动方的处理结果不影响主动方的处理结果,被动方的消息处理操作是幂等操作</p>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>可靠消息系统建设成本</p>
<p>一次消息发送需要两次请求，业务处理服务需实现消息状态回查接口</p>
<h3 id="优点、适用范围"><a href="#优点、适用范围" class="headerlink" title="优点、适用范围"></a>优点、适用范围</h3><p>消息数据独立存储、独立伸缩，降低业务系统与消息系统间的耦合</p>
<h3 id="方案特点"><a href="#方案特点" class="headerlink" title="方案特点"></a>方案特点</h3><p>兼容所有实现AMQP标准的MQ中间件</p>
<p>确保业务数据可靠的前提下，实现业务数据的最终一致（理想状态下基本是准实时一致）</p>
<h2 id="柔性事务解决方案-TCC（两阶段型、补偿型）"><a href="#柔性事务解决方案-TCC（两阶段型、补偿型）" class="headerlink" title="柔性事务解决方案 TCC（两阶段型、补偿型）"></a>柔性事务解决方案 TCC（两阶段型、补偿型）</h2><p><img src="http://qiniu.gaobinzhan.com/2020/03/25/dacf286d3b822.png"></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>一个完整的业务活动由一个主业务服务与若干从业务服务组成</p>
<p>主业务服务负责发起并完成整个业务活动</p>
<p>从业务服务提供TCC型业务操作</p>
<p>业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作</p>
<h3 id="成本-1"><a href="#成本-1" class="headerlink" title="成本"></a>成本</h3><p>实现TCC操作的成本</p>
<p>业务活动结束时confirm或cancel操作的执行成本</p>
<p>业务活动日志成本</p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>强隔离性、严格一致性要求的业务活动</p>
<p>适用于执行时间较短的业务（比如处理账户、收费等业务）</p>
<h3 id="用到的服务模式"><a href="#用到的服务模式" class="headerlink" title="用到的服务模式"></a>用到的服务模式</h3><p>TCC操作、幂等操作、可补偿操作、可查询操作</p>
<h3 id="方案特点-1"><a href="#方案特点-1" class="headerlink" title="方案特点"></a>方案特点</h3><p>不与具体的服务框架耦合（在RPC架构中通用）</p>
<p>位于业务服务层，而非资源层</p>
<p>可以灵活选择业务资源的锁定粒度</p>
<h2 id="最大努力通知型"><a href="#最大努力通知型" class="headerlink" title="最大努力通知型"></a>最大努力通知型</h2><p><img src="http://qiniu.gaobinzhan.com/2020/03/25/6b81229982919.png"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失。</p>
<p>业务活动的被动方根据定时策略，向业务活动主动方查询，恢复丢失的业务消息。</p>
<h3 id="约束-1"><a href="#约束-1" class="headerlink" title="约束"></a>约束</h3><p>被动方的处理结果不影响主动方的处理结果</p>
<h3 id="成本-2"><a href="#成本-2" class="headerlink" title="成本"></a>成本</h3><p>业务查询与校对系统的建设成本</p>
<h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p>对业务最终一致性的时间敏感度低</p>
<p>跨企业的业务活动</p>
<h3 id="方案特点-2"><a href="#方案特点-2" class="headerlink" title="方案特点"></a>方案特点</h3><p>业务活动的主动方在完成业务处理后，向业务活动被动方发送通知消息（允许消息丢失）主动方可以设置时间阶梯型通知规则，在通知失败后按规则重复通知，直到通知N次后不主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息</p>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T08:11:08.000Z" title="9/23/2020, 8:11:08 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.932Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">2 分钟读完 (大约336个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6kafka-php%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8kafka-binzs-blog.html">消息中间件Kafka - PHP操作使用Kafka</a></h1><div class="content"><ul>
<li>  博主： gaobinzhan</li>
<li>  发布时间：2019 年 03 月 21 日</li>
<li>  1366次浏览</li>
<li>  暂无评论</li>
<li>  1527字数</li>
<li>  分类： 消息中间件</li>
</ul>
<p>[TOC]</p>
<blockquote>
<p><strong>我们需要安装libkafka和rdkafka</strong></p>
</blockquote>
<h2 id="安装libkafka"><a href="#安装libkafka" class="headerlink" title="安装libkafka"></a>安装libkafka</h2><ol>
<li><strong>下载</strong> 去GitHub上克隆下来 <code>git clone https://github.com/edenhill/librdkafka.git</code></li>
<li><strong>安装</strong> <code>cd librdkafka/</code> <code>./configure &amp;&amp; make &amp;&amp; make install</code> 安装成功界面 没有报错就是安装成功 <img src="http://qiniu.gaobinzhan.com/2019/11/02/0afdf2be1eead.png"></li>
</ol>
<h2 id="安装rdkafka"><a href="#安装rdkafka" class="headerlink" title="安装rdkafka"></a>安装rdkafka</h2><ol>
<li><strong>下载</strong> <code>git clone https://github.com/arnaud-lb/php-rdkafka</code> <code>cd php-rdkafka/</code></li>
<li><strong>为php安装扩展</strong> 在php-rdkafka这个目录下 <code>phpize</code> 然后会生成源代码安装的脚本 把php-config的位置改成自己php-config的位置 <code>./configure --with-php-config=/usr/local/php/bin/php-config</code> 编译安装 <code>make &amp;&amp; make install</code> 成功后会出现一个文件夹 <img src="http://qiniu.gaobinzhan.com/2019/11/02/24854ed8d1d47.png"> 这个位置就是保存的我们刚刚安装的扩展 进入该目录 <code>cd /usr/local/php/lib/php/extensions/no-debug-non-zts-20170718/</code> 会发现出现个rdkafka.so文件<br> <img src="http://qiniu.gaobinzhan.com/2019/11/02/194c95c93593c.png"> 修改php.ini文件加入 这里的路径就是写自己rdkafka.so文件的路径 <code>extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20170718/rdkafka.so</code> 重启php <code>php-m</code> 出现rdkafka就是安装成功 <img src="http://qiniu.gaobinzhan.com/2019/11/02/402b89b50a15e.png"></li>
</ol>
<h2 id="php操作kafka"><a href="#php操作kafka" class="headerlink" title="php操作kafka"></a>php操作kafka</h2><blockquote>
<p><strong>运行前先开启我们的zookeeper和kafka 上篇文章有如何开启</strong></p>
</blockquote>
<ol>
<li><strong>运行producer</strong><br> kafka默认端口9092 <code>vim producer.php</code></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T08:06:04.000Z" title="9/23/2020, 8:06:04 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.928Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">19 分钟读完 (大约2796个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0-binzs-blog.html">redis哨兵故障转移及实现</a></h1><div class="content"><blockquote>
<p>在上篇文章中docker-compose搭建redis-sentinel成功的搭建了1主2从3哨兵。</p>
</blockquote>
<p><strong>sentinel</strong>是一个特殊的<strong>redis</strong>节点，它有自己专属的<strong>api</strong>：</p>
<ul>
<li>  <code>sentinel masters</code> 显示被监控的所有<strong>master</strong>以及它们的状态。</li>
<li>  <code>sentinel master</code> 显示指定<strong>master</strong>的信息和状态。</li>
<li>  <code>sentinel slaves</code> 显示指定<strong>master</strong>的所有<strong>slave</strong>及它们的状态。</li>
<li>  <code>sentinel sentinels</code> 显示指定<strong>master</strong>的<strong>sentinel</strong>节点集合（不包含当前节点）。</li>
<li>  <code>sentinel get-master-addr-by-name</code> 返回指定<strong>master</strong>的<strong>ip</strong>和<strong>port</strong>，如果正在进行<strong>failover</strong>或者<strong>failover</strong>已经完成，将会显示被提升为<strong>master</strong>的<strong>slave</strong>的<strong>ip</strong>和<strong>port</strong>。</li>
<li>  <code>sentinel failover</code> 强制<strong>sentinel</strong>执行<strong>failover</strong>，并且不需要得到其它<strong>sentinel</strong>的同意。但是<strong>failover</strong>后会将最新的配置发送给其它<strong>sentinel</strong>。</li>
</ul>
<p><code>sentinel masters</code></p>
<p>展示所有被监控的主节点状态及相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel masters</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.2&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………………………</span><br></pre></td></tr></table></figure>

<p><code>sentinel master</code></p>
<p>展示指定状态以及相关的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel master mymaster</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;mymaster&quot;</span><br><span class="line"> 3) &quot;ip&quot;</span><br><span class="line"> 4) &quot;192.168.3.2&quot;</span><br><span class="line"> 5) &quot;port&quot;</span><br><span class="line"> 6) &quot;6379&quot;</span><br><span class="line"> ………………………………</span><br></pre></td></tr></table></figure>

<p><code>sentinel slaves</code></p>
<p>展示指定 的从节点状态以及相关的统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel slaves mymaster</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;192.168.3.4:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.4&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;192.168.3.3:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.3&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">…………………………………………</span><br></pre></td></tr></table></figure>

<p><code>sentinel sentinels</code></p>
<p>展示指定 的<strong>sentinel</strong>节点集合（不包含当前<strong>sentinel</strong>节点）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel sentinels mymaster</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;570de1d8085ec8bd7974431c01c589847c857edf&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.13&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;26379&quot;</span><br><span class="line">………………………………………………</span><br></pre></td></tr></table></figure>

<p><code>sentinel get-master-addr-by-name</code></p>
<p>获取主节点信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel get-master-addr-by-name mymaster</span><br><span class="line">1) &quot;192.168.3.2&quot;</span><br><span class="line">2) &quot;6379&quot;</span><br></pre></td></tr></table></figure>

<p><code>sentinel failover</code></p>
<p>对进行强制故障转移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel failover mymaster</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:26380&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.3.3:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure>

<p>修改配置：</p>
<ul>
<li>  添加新的监听：<code>sentinel monitor test 127.0.0.1 6379 2</code></li>
<li>  放弃对某个<strong>master</strong>监听：<code>sentinel REMOVE test</code></li>
<li>  设置配置选项：<code>sentinel set failover-timeout mymaster 180000</code></li>
</ul>
<p><strong>Master</strong>可能会因为某些情况宕机了，如果客户端是固定一个地址去访问，肯定是不合理的，所以客户端请求是请求哨兵，从哨兵获取主机地址的信息，或者是从机的信息。可以实现一个例子：</p>
<ul>
<li>  随机选择一个哨兵连接，获取主机及从机信息。</li>
<li>  模拟客户端定时访问，实现简单轮询效果，轮询从节点。</li>
<li>  连接失败重试访问</li>
</ul>
<h2 id="Sentinel故障转移"><a href="#Sentinel故障转移" class="headerlink" title="Sentinel故障转移"></a>Sentinel故障转移</h2><p>执行<code>docker-composer up</code>之后<code>sentinel.conf</code>发生了变化，每个配置文件变化如下：</p>
<p><code>sentinel\conf\sentinel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.12 26379 497f733919cb5d41651b4a2b5648c4adffae0a73</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.13 26379 0d0ee41bcb5d765e9ff78ed59de66be049a23a82</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p><code>sentine2\conf\sentinel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.13 26379 0d0ee41bcb5d765e9ff78ed59de66be049a23a82</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.11 26379 f5f2a73dc0e60514e4f28c6f40517f48fa409eed</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p><code>sentine3\conf\sentinel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user default on nopass ~* +@all</span><br><span class="line">sentinel known-replica mymaster 192.168.3.3 6379</span><br><span class="line">sentinel known-replica mymaster 192.168.3.4 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.12 26379 497f733919cb5d41651b4a2b5648c4adffae0a73</span><br><span class="line">sentinel known-sentinel mymaster 192.168.3.11 26379 f5f2a73dc0e60514e4f28c6f40517f48fa409eed</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p>从变化中可以看出每台<strong>Sentinel</strong>分别记录了<strong>slave</strong>的节点信息和其它<strong>Sentinel</strong>节点信息。</p>
<p>在宿主机中随便进入一台<strong>Sentinel</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26380&gt; sentinel masters</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;192.168.3.2&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br></pre></td></tr></table></figure>

<p>可以观察到监听的所有<strong>master</strong>，将<strong>192.168.3.2</strong>这台<strong>master</strong>进行宕机</p>
<p><code>docker stop redis-master</code></p>
<p>宕机完之后等待<strong>Sentinel</strong>检测周期过了之后再对<code>sentinel.conf</code>和<code>redis.conf</code>进行观察。</p>
<p>3台<strong>Sentinel</strong>的<code>sentinel monitor mymaster 192.168.3.2 6379 2</code>变成了<code>sentinel monitor mymaster 192.168.3.4 6379 2</code></p>
<p>其次master对应的slave节点信息也进行更改。</p>
<p>而<strong>192.168.3.3</strong>的<code>redis.conf</code>中<code>replicaof 192.168.3.2 6379</code>也变成了<code>replicaof 192.168.3.4 6379</code>。</p>
<p><strong>192.168.3.2</strong>的<code>redis.conf</code>中<code>replicaof 192.168.3.2 6379</code>这行配置被删除掉了。</p>
<p>再次启动<strong>192.168.3.2</strong>的<strong>redis</strong>节点，而这台节点的<code>redis.conf</code>中增加了一行<code>replicaof 192.168.3.4 6379</code>。</p>
<p>其实就是将我们的操作自动化了。</p>
<h2 id="Sentinel实现原理"><a href="#Sentinel实现原理" class="headerlink" title="Sentinel实现原理"></a>Sentinel实现原理</h2><p><strong>Sentinel</strong>的实现原理，主要分为三个步骤：</p>
<ul>
<li>  检测问题：三个定时任务，这三个内部的执行任务可以保证出现问题马上让<strong>Sentinel</strong>知道。</li>
<li>  发现问题：主观下线和客观下线，当有一台<strong>Sentinel</strong>机器发现问题时，它就会对它主观下线。但是当多个<strong>Sentinel</strong>都发现问题的时候，才会出现客观下线。</li>
<li>  找到解决问题的<strong>Sentinel</strong>：进行领导者选举，如何在<strong>Sentinel</strong>内部多台节点做领导者选择。</li>
<li>  解决问题：就是要进行故障转移。</li>
</ul>
<h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ul>
<li>每10s每个<strong>Sentinel</strong>对<strong>Master</strong>和<strong>Slave</strong>执行一次<code>Info Replication</code>。  <strong>Redis Sentinel</strong>可以对<strong>Redis</strong>节点做失败判断和故障转移，来<code>Info Replication</code>发现<strong>Slave</strong>节点，来确定主从关系。</li>
<li>每2s每个<strong>Sentinel</strong>通过<strong>Master</strong>节点的<strong>channel</strong>交换信息（pub/sub）。  类似于发布订阅，<strong>Sentinel</strong>会对主从关系进行判断，通过<code>__sentinel__:hello</code>频道交互。了解主从关系可以帮助更好的自动化操作<strong>Redis</strong>。然后<strong>Sentinel</strong>会告知系统消息给其它<strong>Sentinel</strong>节点，最终达到共识，同时<strong>Sentinel</strong>节点能够互相感知到对方。</li>
<li>每1s每个<strong>Sentinel</strong>对其它<strong>Sentinel</strong>和<strong>Redis</strong>执行<code>ping</code>。  对每个节点和其它<strong>Sentinel</strong>进行心跳检测，它是失败判断的依据。</li>
</ul>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>回顾上一篇文章中<strong>Sentinel</strong>的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.3.2 6379 2</span><br><span class="line">sentinel down-after-millseconds mymaster 30000</span><br></pre></td></tr></table></figure>

<p>主观下线：每个<strong>Sentinel</strong>节点对<strong>Redis</strong>失败的“偏见”。之所以是偏见，只是因为某一台机器30s内没有得到回复。</p>
<p>客观下线：这个时候需要所以<strong>Sentinel</strong>节点都发现它30s内无回复，才会达到共识。</p>
<h3 id="领导者选举方式"><a href="#领导者选举方式" class="headerlink" title="领导者选举方式"></a>领导者选举方式</h3><ul>
<li>  每个做主观下线的Sentinel节点，会像其它的<strong>Sentinel</strong>节点发送命令，要求将它设置成为领导者。</li>
<li>  收到命令的<strong>Sentinel</strong>节点，如果没有同意通过其它节点发送的命令，那么就会同意请求，否则就会拒绝。</li>
<li>  如果<strong>Sentinel</strong>节点发现自己的票数超过半数，同时也超过了<code>sentinel monitor mymaster 192.168.3.2 6379 2</code>超过2个的时候，就会成为领导者。</li>
<li>  进行故障转移操作。</li>
</ul>
<h3 id="如何选择“合适”的Slave节点"><a href="#如何选择“合适”的Slave节点" class="headerlink" title="如何选择“合适”的Slave节点"></a>如何选择“合适”的Slave节点</h3><p>​ <strong>Redis</strong>内部其实是有一个优先级配置的，在配置文件中<code>replica-priority</code>，这个参数是<strong>slave</strong>节点的优先级配置，如果存在则返回，如果不存在则继续。当上面这个优先级不满足的时候，<strong>Redis</strong>还会选择复制偏移量最大的<strong>Slave</strong>节点，如果存在则返回，如果不存在则继续。之所以选择偏移量最大，这是因为偏移量越小，和<strong>Master</strong>的数据越不接近，现在<strong>Master</strong>挂掉了，说明这个偏移量小的机器数据可能存在问题，这就是为什么选择偏移量最大的<strong>Slave</strong>的原因。如果发现偏移量都一样，这个时候 <strong>Redis</strong> 会默认选择 <strong>runid</strong> 最小的节点。</p>
<p>生产环境部署技巧：</p>
<ul>
<li><strong>Sentinel</strong>节点不应该部署在一台物理机器上。  这里特意强调物理机是因为一台物理机做成了若干虚拟机或者现今比较流行的容器，它们虽然有不同的<strong>IP</strong>地址，但实际上它们都是同一台物理机，同一台物理机意味着如果这台机器有什么硬件故障，所有的虚拟机都会受到影响，为了实现<strong>Sentinel</strong>节点集合真正的高可用，请勿将<strong>Sentinel</strong>节点部署在同一台物理机器上。</li>
<li>  部署至少三个且奇数个的<strong>Sentinel</strong>节点。通过增加<strong>Sentinel</strong>节点的个数提高对于故障判定的准确性，因为领导者选举需要至少一半加1个节点。</li>
</ul>
<h2 id="Sentinel常见问题"><a href="#Sentinel常见问题" class="headerlink" title="Sentinel常见问题"></a>Sentinel常见问题</h2><p>哨兵集群在发现<strong>master node</strong>挂掉后会进行故障转移，也就是启动其中一个<strong>slave node</strong>为<strong>master node</strong>。在这过程中，可能会导致数据丢失的情况。</p>
<ul>
<li>异步复制导致数据丢失  因为<strong>master-&gt;slave</strong>的复制是异步，所以有可能部分还没来得及复制到<strong>slave</strong>就宕机了，此时这些部分数据就丢失了。</li>
<li>集群脑裂导致数据丢失  脑裂，也就是说。某个<strong>master</strong>所在机器突然脱离了正常的网络，跟其它<strong>slave</strong>机器不能连接，但是实际上<strong>master</strong>还运行着。</li>
</ul>
<p>造成的问题：</p>
<p>​ 此时哨兵可能就会认为<strong>master</strong>宕机了，然后开始选举，将其它<strong>slave</strong>切换成<strong>master</strong>。这时候集群里就会有2个<strong>master</strong>，也就是所谓的脑裂。此时虽然某个<strong>slave</strong>被切换成<strong>master</strong>，但是可能<strong>client</strong>还没来得及切换成新的<strong>master</strong>，还继续写向旧的<strong>master</strong>的数据可能就丢失了。因此旧<strong>master</strong>再次被恢复的时候，会被作为一个<strong>slave</strong>挂到新的<strong>master</strong>上去，自己的数据会被清空，重新从新的<strong>master</strong>复制数据。</p>
<p>怎么解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>要求至少有一个<strong>slave</strong>，数据复制和同步的延迟不能超过10s。</p>
<p>如果说一旦所有的<strong>slave</strong>，数据复制和同步的延迟都超过了10s，这个时候，<strong>master</strong>就不会再接收任何请求了。</p>
<p>上面两个配置可以减少异步复制和脑裂导致的数据丢失。</p>
<p>异步复制导致的数据丢失：</p>
<p>​ 在异步复制的过程当中，通过<code>min-slaves-max-lag</code>这个配置，就可以确保的说，一旦<strong>slave</strong>复制数据和<strong>ack</strong>延迟时间太长，就认为可能<strong>master</strong>宕机后损失的数据太多了，那么就拒绝写请求，这样就可以把<strong>master</strong>宕机时由于部分数据未同步到<strong>slave</strong>导致的数据丢失降低到可控范围内。</p>
<p>集群脑裂导致的数据丢失：</p>
<p>​ 集群脑裂因为<strong>client</strong>还没来得及切换成新的<strong>master</strong>，还继续写向旧的master的数据可能就丢失了通过<code>min-slaves-to-write</code>确保必须是有多少个从节点连接，并且延迟时间小于<code>min-slaves-max-lag</code>多少秒。</p>
<p>客户端需要怎么做：</p>
<p>​ 对于<strong>client</strong>来讲，就需要做些处理，比如先将数据缓存到内存当中，然后过一段时间处理，或者连接失败，接收到错误切换新的<strong>master</strong>处理。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-23T07:51:02.000Z" title="9/23/2020, 7:51:02 AM">2020-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-30T22:56:44.932Z" title="9/30/2021, 10:56:44 PM">2021-09-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/uncategorized/">uncategorized</a></span><span class="level-item">4 分钟读完 (大约581个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/23/sl-im-%E5%9F%BA%E4%BA%8E-swoft-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8D%8F%E7%A8%8B%E6%A1%86%E6%9E%B6%E5%92%8C-layim-%E7%BD%91%E9%A1%B5%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F-%E5%BC%80%E5%8F%91%E5%87%BA-6.html">sl-im 基于 Swoft 微服务协程框架和 Layim 网页聊天系统 开发出来的聊天室</a></h1><div class="content"><p><img src="http://qiniu.gaobinzhan.com/2020/04/13/562596a1c87ac.png?imageView2/2/w/300"></p>
<p><img src="http://img.shields.io/badge/php-%3E=7.1-brightgreen.svg?maxAge=2592000"><img src="http://img.shields.io/badge/swoole-%3E=4.3.3-brightgreen.svg?maxAge=2592000"><img src="http://img.shields.io/hexpm/l/plug.svg?maxAge=2592000"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>sl-im 是基于 Swoft 微服务协程框架和 Layim 网页聊天系统 所开发出来的聊天室。</p>
<p>当前分支为2.x开发版本，如需部署，请下载releases</p>
<h2 id="体验地址"><a href="#体验地址" class="headerlink" title="体验地址"></a>体验地址</h2><p>sl-im <a target="_blank" rel="noopener" href="https://im.gaobinzhan.com/">https://im.gaobinzhan.com</a></p>
<h2 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h2><p><img src="http://qiniu.gaobinzhan.com/2020/04/13/a96b031c660ca.jpg"></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>  登录注册（Http）</li>
<li>  单点登录（Websocket）</li>
<li>  私聊（Websocket）</li>
<li>  群聊（Websocket）</li>
<li>  在线人数（Websocket）</li>
<li>  获取未读消息（Websocket）</li>
<li>  好友在线状态（Websocket）</li>
<li>  好友 查找 添加 同意 拒绝（Http+Websocket）</li>
<li>  群 创建 查找 添加 同意 拒绝（Http+Websocket）</li>
<li>  聊天记录存储</li>
<li>  心跳检测</li>
<li>  消息重发</li>
<li>  断线重连</li>
</ul>
<h2 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h2><ul>
<li>  PHP 7.1+</li>
<li>  Swoole 4.3.4+</li>
<li>  Composer</li>
<li>  Swoft &gt;= 2.0.8</li>
</ul>
<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure>

<h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><p><code>app/bean.php</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x27;db&#x27; =&gt; [</span><br><span class="line">        &#x27;class&#x27;    =&gt; Database::class,</span><br><span class="line">        &#x27;dsn&#x27;      =&gt; &#x27;mysql:dbname=im;host=127.0.0.1:3306&#x27;,</span><br><span class="line">        &#x27;username&#x27; =&gt; &#x27;root&#x27;,</span><br><span class="line">        &#x27;password&#x27; =&gt; &#x27;gaobinzhan&#x27;,</span><br><span class="line">        &#x27;charset&#x27;  =&gt; &#x27;utf8mb4&#x27;,</span><br><span class="line">    ],</span><br><span class="line">&#x27;db.pool&#x27; =&gt; [</span><br><span class="line">        &#x27;class&#x27;     =&gt; \Swoft\Db\Pool::class,</span><br><span class="line">        &#x27;database&#x27;  =&gt; bean(&#x27;db&#x27;),</span><br><span class="line">        &#x27;minActive&#x27; =&gt; 5, // 自己调下连接池大小</span><br><span class="line">        &#x27;maxActive&#x27; =&gt; 10</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<h3 id="数据表迁移"><a href="#数据表迁移" class="headerlink" title="数据表迁移"></a>数据表迁移</h3><p><code>php bin/swoft mig:up</code></p>
<h3 id="env配置"><a href="#env配置" class="headerlink" title="env配置"></a>env配置</h3><p><code>vim .env</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># basic</span><br><span class="line">APP_DEBUG=0</span><br><span class="line">SWOFT_DEBUG=0</span><br><span class="line"></span><br><span class="line"># more ...</span><br><span class="line">APP_HOST=https://im.gaobinzhan.com/</span><br><span class="line">WS_URL=ws://im.gaobinzhan.com/im</span><br><span class="line"># 是否开启静态处理 这里我关了 让nginx去处理</span><br><span class="line">ENABLE_STATIC_HANDLER=false </span><br><span class="line"># swoole v4.4.0以下版本, 此处必须为绝对路径</span><br><span class="line">DOCUMENT_ROOT=/data/wwwroot/IM/public</span><br></pre></td></tr></table></figure>

<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name im.gaobinzhan.com;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    root /data/wwwroot/IM/public/;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;</span><br><span class="line">    server_name im.gaobinzhan.com;</span><br><span class="line">    access_log /data/wwwlog/im-gaobinzhan-com.access.log;</span><br><span class="line">    error_log /data/wwwlog/im-gaobinzhan-com.error.log;</span><br><span class="line">    client_max_body_size 100m;</span><br><span class="line">    ssl_certificate /etc/nginx/ssl/full_chain.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/private.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9091;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Real-PORT $remote_port;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">    location /im &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:9091;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_read_timeout   3600s;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ .*\.(jsicocssttfwoffwoff2pngjpgjpegsvggifhtm)$ &#123;</span><br><span class="line">        root /data/wwwroot/IM/public;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php bin/swoft ws:start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php bin/swoft ws:start -d</span><br></pre></td></tr></table></figure>

<p>怎么访问还用写吗？？？点个star吧 ✌️</p>
<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul>
<li>  WeChat：gaobinzhan</li>
<li>  QQ：975975398</li>
</ul>
<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/support-plan?invite%5C_code=14q93ezyewy0r">https://cloud.tencent.com/developer/support-plan?invite\_code=14q93ezyewy0r</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/uncategorized/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/uncategorized/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/uncategorized/">1</a></li><li><a class="pagination-link" href="/categories/uncategorized/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/uncategorized/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/44792981?s=400&amp;u=273c6d745868dcacf7889e5da4499b751179f773&amp;v=4" alt="Stitch"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Stitch</p><p class="is-size-6 is-block">Alien monster</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Alien</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Stitch-June" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Stitch-June"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/uncategorized/"><span class="level-start"><span class="level-item">uncategorized</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">43</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-30T22:56:44.928Z">2021-09-30</time></p><p class="title"><a href="/2021/09/30/hello-world.html">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-01T00:40:00.000Z">2021-04-01</time></p><p class="title"><a href="/2021/04/01/redis-%E9%93%BE%E8%A1%A8.html">Redis-链表</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-31T01:09:00.000Z">2021-03-31</time></p><p class="title"><a href="/2021/03/31/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds.html">Redis-简单动态字符串SDS</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-27T12:28:48.000Z">2020-09-27</time></p><p class="title"><a href="/2020/09/27/go%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88-binzs-blog.html">Go常用集合</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-27T12:15:12.000Z">2020-09-27</time></p><p class="title"><a href="/2020/09/27/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86-binzs-blog.html">redis之主从问题处理</a></p><p class="categories"><a href="/categories/uncategorized/">uncategorized</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Stitch&#039;s Blog</a><p class="is-size-7"><span>&copy; 2021 stitch</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>