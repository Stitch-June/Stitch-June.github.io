---
title: redis持久化rdb及aof
tags: []
id: '71'
categories:
  - - uncategorized
date: 2020-09-23 07:45:39
---

​ 持久化的功能：**Redis**是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将**Redis**中的数据以某种形式（数据或命令）从内存保存到硬盘中。当下次**Redis**重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。**Redis**持久化分为**RDB**和**AOF**，前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存的硬盘。

## RDB持久化

​ **RDB**是一种快照存储持久方式，具体就是将**Redis**某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为**dump.rdb**，而在Redis服务器启动时，会重新加载**dump.rdb**文件的数据到内存当中恢复数据。触发**RDB**持久化过程分为手动触发和自动触发。

### 触发机制

手动触发分别对应`save`和`bgsave`命令：

`save`命令：阻塞当前**Redis**服务器，直到**RDB**过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。

`bgsave`命令：**Redis**进程执行**fork**操作创建子进程，**RDB**持久化过程由子进程负责，完成后自动结束。阻塞只发生在**fork**阶段，一般时间很短。

显示`bgsave`命令是针对`save`阻塞问题做的优化。因此**Redis**内部所有的涉及**RDB**的操作都采用`bgsave`的方式。

除了执行命令手动触发之外，**Redis**内部还存在自动触发**RDB**的持久化机制，例如以下场景：

*   使用`save`相关配置，如`save m n`。表示**m**秒内数据集存在**n**次修改时，自动触发`bgsave`。
*   如果从节点执行全量复制操作，主节点自动执行`bgsave`生成**RDB**文件并发送给从节点。
*   执行`debug reload`命令重载**Redis**时，也会自动触发`save`操作。
*   默认情况下执行`shutdown`命令时，如果没有开启**AOF**持久化功能则自动执行`bgsave`。

### 执行流程

`bgsave`是主流的触发**RDB**持久化方式：

![](http://qiniu.gaobinzhan.com/2020/06/06/83dd261b57178.png)

*   执行`bgsave`命令，**Redis**父进程判断当前是否存在正在执行的子进程，如**RDB/AOF**子进程，如果存在`bgsave`命令直接返回。
*   父进程执行**fork**操作创建子进程，**fork**操作过程中父进程会阻塞，通过`info stats`命令查看`latest_fork_usec`选项，可以获得最近一个**fork**操作的耗时，单位为微妙。
*   父进程**fork**完成后，`bgsave`命令返回**Background saving started**信息并不再阻塞父进程，可以继续响应其它命令。
*   子进程创建**RDB**文件，根据父进程内存生成临时快照文件，完成后原有文件进行原子替换。执行`lastsave`命令可以获取最后一次生成**RDB**的时间，对应`info`统计的`rdb_last_save_time`选项。
*   进程发送信号给父进程表示完成，父进程更新统计信息，具体见`info Persistence`下的`rdb_*`相关选项。

### 服务器配置自动触发

​ 除了通过客户端发送命令外，还有一种方式，就是在**Redis**配置文件中的`save`指定到达触发**RDB**持久化的条件，比如【多少秒内至少达到多少写操作】就开启**RDB**数据同步。

例如我们可以在配置文件**redis.conf**指定如下的选项：

```
# 900s内至少达到1条写命令
save 900 1
# 300s内至少达到10条写命令
save 300 10
# 60s内至少达到1000条写命令
save 60 1000
```

这种通过服务器配置文件触发**RDB**的方式，与`bgsave`命令类似，达到触发条件时，会**fork**一个子进程进行数据同步，不过最好不要通过这种方式来触发**RDB**持久化，因为设置触发的时间太短，则容易频繁写入**rdb**文件，影响服务器性能，时间设置太长会造成数据丢失。

### RDB文件的处理

保存：

*   **RDB**文件保存在**dir**配置指定的目录下，文件名通过**dbfilename**配置指定。可通过执行`config set dir {newDir}`和`config set dbfilename {newFileName}`运行期动态执行，当下次运行时RDB文件会保存到新目录。

压缩：

*   **Redis**默认采用**LZF**算法对生存的**RDB**文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数`config set rdbcompression {yesno}`动态修改。
*   虽然压缩**RDB**会消耗**CPU**，但可大幅度降低文件的体积，方便保存到硬盘或通过网络发送给从节点，因此线上建议开启。

### RDB方式的优缺点

优点：

*   **RDB**是一个非常紧凑的文件，它保存了**Redis**在某个时间点上的数据集。这种文件非常适合用于备份；比如说，你可以在最近的24小时内，每小时备份一次**RDB**文件，并且在每个月的每一天，也备份一个**RDB**文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
*   **RDB**可以最大化**Redis**的性能；父进程在保存**RDB**文件时唯一要做的就是**fork**出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无需执行任何磁盘**I/O**操作。
*   **RDB**在恢复大数据集时的速度要比**AOF**的恢复速度快。

缺点：

*   **RDB**方式数据没办法做到实时持久化/秒级持久化。如果服务器宕机的话，采用**RDB**的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或者5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。
*   使用`bgsave`命令在**fork**子进程时，如果数据量太大，fork的过程也会发生阻塞，另外，**fork**子进程会消耗内存。针对**RDB**不适合做实时持久化的问题，**Redis**提供了**AOF**持久化方式来解决。

## AOF持久化

​ **AOF**（append only file）持久化；与**RDB**存储某个时刻的快照不同，**AOF**持久化方式会记录客户端对服务器的每一次写操作命令到日志当中，并将这些操作以**Redis**协议追加保存到以后缀为**aof**文件末尾。

### 使用AOF

​ 开启AOF功能需要设置配置；`appendonly yes`，默认不开启。**AOF**文件名通过`appendfilename`配置设置，默认文件名是**appendonly.aof**。保存路径同RDB持久化方式一致，通过dir配置指定。

### 持久化配置

```
appendonly yes #启用aof持久化方式
appendfsync always #每次收到命令就立即强制写入磁盘，最慢的大概只有几百的TPS，但是保证完全的持久化，不推荐使用
appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐
appendfsync no #完全依赖os，性能最好，持久化没保证，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切完全依赖于操作系统的调试了。对于大多数Linux操作系统，是每30s进行一次fsync，将缓冲区中的数据写的磁盘上。
```

### 执行流程

![](http://qiniu.gaobinzhan.com/2020/06/07/42bd8316078e8.png)

*   所以的写入命令会追加到**aof\_buf**（缓冲区）中。
*   **AOF**缓冲区根据对应的策略向硬盘做同步操作。
*   随着**AOF**文件越来越大，需要定期对**AOF**文件进行重写，达到压缩的目的。
*   当**Redis**服务器重启时，可以加载**AOF**文件进行数据恢复。

> 在同步期间可能会发生阻塞问题

![](http://qiniu.gaobinzhan.com/2020/06/07/29fb2a1372aaa.png)

*   若果**AOF**文件**fsync**同步时间大于**2s**，**Redis**主进程就会阻塞。
*   若果**AOF**文件**fsync**同步时间小于**2s**，**Redis**主进程就会返回。

其实这样做是为了保证文件安全性的一种策略。

**AOF**追加阻塞会产生的问题：

*   **fsync**大于**2s**时候，会阻塞**redis**主进程，我们都知道**redis**主进程是用来执行**redis**命令的，是不能阻塞的。
*   虽然每秒**everysec**刷盘策略，但是实际上不是丢失**1s**数据，实际有可能丢失**2s**数据。

### 重写机制

*   **AOF**将客户端的每一个写操作都追加到**aof**文件末尾，随着命令不断写入**AOF**，文件会越来越大，为了解决这个问题，**Redis**引入**AOF**重写机制压缩文件体积。
*   **AOF**文件重写是吧Redis进程内的数据转化为写命令同步到新AOF**文件的过程**。
    
    比如：多条命令可以合并为一个，`lpush list a、lpush list b`可以转化为`lpush list a b`。
    
*   **AOF**重写降低了文件占用空间，除此之外，另一个目的是：更小的**AOF**文件可以更快地被加载。

触发机制：

**AOF**重写过程可以手动触发和自动触发：

*   手动触发：直接调用`bgrewriteaof`命令。
*   自动触发：根据`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`参数确定自动触发。
    
    *   `auto-aof-rewrite-min-size`表示运行**AOF**重写时文件最小体积，默认为**64MB**。
    *   `auto-aof-rewrite-percentage`代表当前**AOF**文件空间（aof\_current\_size）和上一次重写后AOF文件空间（aof\_base\_size）的比值。
*   示例：
    
    *   `auto-aof-rewrite-percentage：100`
    *   `auto-aof-rewrite-min-size：64mb`
*   默认配置时当**AOF**文件大小是上次**rewrite**后大小的一倍且文件大于**64mb**时触发。

当触发AOF重写时，内部流程：

![](http://qiniu.gaobinzhan.com/2020/06/07/7548fdf5a9cfd.png)

执行**AOF**重写请求。如果当前进程正在执行**AOF**重写，请求不执行并返回如下响应：**ERR Background append only file rewriting already in progress**

*   父进程执行**fork**创建子进程，开销等同于**bgsave**过程。
    
    *   主进程**fork**操作完成后，继续响应其它命令。所以修改命令依然写入**AOF**缓冲区并根据`appendfsync`策略同步到硬盘，保证原有**AOF**机制正确性。
    *   由于**fork**操作运用写时复制技术，子进程只能共享**fork**操作时的内存数据。由于父进程依然响应命令，Redis使用**AOF**重写缓冲区保存这部分新数据，防止新**AOF**文件生成期间丢失这部分数据。
*   子进程根据内存快照，按照命令合并规则写入新的**AOF**文件，每次批量写入硬盘数据量由配置`aof-rewrite-incremental-fsync`控制，默认为**32MB**，防止单词刷盘数据过多造成硬盘阻塞。
    
    *   新**AOF**文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见`info persistence`的**aof\_**\*相关统计。
    *   父进程把**AOF**重写缓冲区的数据写入到新的AOF文件。
    *   使用新**AOF**文件替换老文件，完成**AOF**重写。

### 注意事项

​ 在写入**AOF**日志文件时，如果**Redis**服务器宕机，则**aof**日志文件会出现格式错误，在重启**Redis**服务器时，**Redis**服务器会拒绝载入这个**aof**文件，可以通过命令修复**aof**并恢复数据。

`redid-check-aof -fix appendonly.aof`

### AOF的优缺点

优点：

*   **AOF**可以设置完全不同步、每秒同步、每次操作同步，默认时每秒同步。因为**AOF**时操作指令的追加，所以可以频繁的大量的同步。
*   **AOF**文件是一个值追加日志的文件，即使服务宕机为写入完整的命令，也可以通过**redis-check-aof**工具修复这些问题。
*   如果**AOF**文件过大，**Redis**会在后台自动地重写**AOF**文件。重写后会使**AOF**文件压缩到最小所需的指令集。
*   **AOF**文件是有序保存数据看的所有写入操作，易读，易分析。即使如果不小心误操作数据看，也很容易找出业务错误指令，恢复到某个数据节点。例如不小`FLUSHALL`，可以非常容易恢复到执行命令之前。

缺点：

*   相同数据量下，**AOF**的文件通常体积会比RDB大。因为**AOF**是存指令的，而RDB是所有指令的结果快照。但**AOF**在日志重写后会压缩一些空间。
*   在大量写入和载入的时候，**AOF**的效率会比**RDB**低，因为大量写入，**AOF**会执行更多的保存命令，载入的时候也需要大量的重执行命令来得到最后的结果。**RDB**对此更有优势。

### AOF常用配置

`appendonly no`：是否开启**AOF**

`appendfilename "appendonly.aof"`：**AOF**文件名

`dir ./`：**RDB**文件和**AOF**文件所在目录

`appendfsync everysec`：fsync持久化策略

`no-appendfsync-on-rewrite no`：**AOF**重写期间是否禁止**fsync**；如果开启该选项，可以减轻文件重写时**CPU**和硬盘的负载（尤其是硬盘），但是可能会丢失**AOF**重写期间的数据；需要在负载和安全性之间进行平衡

`auto-aof-rewrite-percentage 100`：文件重写触发条件之一

`auto-aof-rewrite-min-size 64mb`：文件重写触发提交之一

`aof-load-truncated yes`：如果**AOF**文件结尾损坏，**Redis**启动时是否仍载入**AOF**文件

## 重启加载的选择

**AOF**和**RDB**文件都可以用于服务器重启时的数据恢复。

![](http://qiniu.gaobinzhan.com/2020/06/07/8836e280f5a12.png)

## 持久化的选择

​ 在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用**RDB**或**AOF**的一种，或同时开启**RDB**和AOF**持久化等**。

​ 此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机**master**和从机**slave**可以独立的选择持久化方案。

面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。

*   如果**Redis**中的数据完全丢弃也没有关系（如**Redis**完全用作**DB**层数据的**cache**），那么无论是单机，还是主从架构，都可以不进行任何持久化。
*   在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择**RDB**对**Redis**的性能更加有利；如果只能接受秒级别的数据丢失，应该选择**AOF**。
*   但在多数情况下，我们都会配置主从环境，**slave**的存在既可以实现数据的热备，也可以进行读写分离分担**Redis**读请求，以及在**master**宕掉后继续提供服务。在这种情况下的做法是：
    
    *   **master**：完全关闭持久化（包括**RDB**和**AOF**），这样可以让master的性能达到最好；
    *   slave：关闭**RDB**，开启**AOF**（如果对数据安全要求不高，开启**RDB**关闭**AOF**也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭**AOF**的自动重写，然后添加定时任务，在每天**Redis**闲时（如凌晨12点）调用`bgrewriteaof`。
    *   这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：
        
        *   **master**和**slave**进程同时停止：考虑这样一种场景，如果**master**和**slave**在同一个机房，则一次停电事故就可能导致**master**和**slave**机器同时关机，**Redis**进程停止；如果没有持久化，则面临的是数据的完全丢失。
        *   **master**误重启：考虑这样一种场景，**master**服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将**master**自动重启，由于没有持久化文件，那么**master**重启后数据是空的，**slave**同步数据也变成了空的；如果**master**和**slave**都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵进行自动的主从切换，也有可能在哨兵轮询到**master**之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。
*   异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。
    
    *   例如对于单机的情形，可以定时将**RDB**文件或重写后的**AOF**文件，通过**scp**拷贝到远程机器，如阿里云；对于主从的情形，可以定时在**master**上执行`bgsave`，然后将**RDB**文件拷贝到远程机器，或者在**slave**上执行`bgrewriteaof`重写**AOF**文件后，将**AOF**文件拷贝到远程机器上。
    *   一般来说，由于**RDB**文件文件小、恢复快，因此灾难恢复常用**RDB**文件；异地备份的频率根据数据安全性的需要及其它条件来确定，但最好不要低于一 天一次。

## 持久化配置方案

*   企业级的持久化的配置策略
    
    *   `save 60 10000`：如果你希望尽可能确保说，**RDB**最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，低峰期，数据量很少，也没必要 10000->生成RDB，1000->RDB，这个根据你自己的应用和业务的数据量，自己去决定
    *   **AOF**一定要打开。
    *   `auto-aof-rewrite-percentage 100`: 就是当前**AOF**大小膨胀到超过上次**100%**，上次的两倍
    *   `auto-aof-rewrite-min-size 64mb`: 根据你的数据量来定，**16mb**，**32mb**
*   数据备份方案 **RDB**非常适合做冷备，每次生成之后，就不会再有修改了
    
    *   写**crontab**定时调度脚本去做数据备份
    *   每小时都**copy**一份**rdb**的备份，到一个目录中去，仅仅保留最近**48**小时的备份
    *   每天都保留一份当日的**rdb**的备份，到一个目录中去，仅仅保留最近**1**个月的备份
    *   每次**copy**备份的时候，都把太旧的备份给删了
    *   每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去【crontab】